EllipseMorph subclass: #ChineseCheckerPiece	instanceVariableNames: 'boardLoc myBoard'	classVariableNames: ''	poolDictionaries: ''	category: 'Etoys-Squeakland-Morphic-Games'!!ChineseCheckerPiece commentStamp: '<historical>' prior: 0!I represent a player piece for Chinese Checkers.  Mostly I act as an ellipse, but my special methods ensure that I cannot be picked up or dropped except in the proper circumstances.Structure: myBoard		a ChineseCheckers morph boardLoc		my current logical position on the board.!!ChineseCheckerPiece methodsFor: 'accessing' stamp: 'di 4/9/2000 08:31'!boardLoc	^ boardLoc! !!ChineseCheckerPiece methodsFor: 'accessing' stamp: 'di 4/11/2000 08:34'!setBoard: aBoard loc: aBoardLoc	myBoard := aBoard.	boardLoc := aBoardLoc! !!ChineseCheckerPiece methodsFor: 'event handling' stamp: 'di 4/11/2000 08:36'!handlesMouseDown: evt	^ true! !!ChineseCheckerPiece methodsFor: 'event handling' stamp: 'di 4/9/2000 09:27'!mouseDown: evt	((owner isKindOf: ChineseCheckers)		and: [owner okToPickUpPieceAt: boardLoc])		ifTrue: [evt hand grabMorph: self]! !!ChineseCheckerPiece methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 20:02'!justDroppedInto: newOwner event: evt	newOwner == myBoard ifFalse:		["Only allow dropping into my board."		^self rejectDropMorphEvent: evt].	^super justDroppedInto: newOwner event: evt! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ChineseCheckerPiece class	instanceVariableNames: ''!!ChineseCheckerPiece class methodsFor: 'new-morph participation' stamp: 'di 4/9/2000 11:17'!includeInNewMorphMenu	^ false! !BorderedMorph subclass: #ChineseCheckers	instanceVariableNames: 'board sixDeltas teams homes autoPlay whoseMove plannedMove plannedMovePhase colors movePhase animateMoves pathMorphs'	classVariableNames: ''	poolDictionaries: ''	category: 'Etoys-Squeakland-Morphic-Games'!!ChineseCheckers commentStamp: '<historical>' prior: 0!An implementation of Chinese Checkers by Dan Ingalls.  April 9, 2000.board:  A 19x19 rhombic array, addressed by row@col points, in which is imbedded the familiar six-pointed layout of cells.  A cell outside the board is nil (-).  - - - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - 5 - - - - -    - - - - - - - - - - - - 5 5 - - - - -     - - - - - - - - - - - 5 5 5 - - - - -      - - - - - - - - - - 5 5 5 5 - - - - -       - - - - - 6 6 6 6 0 0 0 0 0 4 4 4 4 -        - - - - - 6 6 6 0 0 0 0 0 0 4 4 4 - -         - - - - - 6 6 0 0 0 0 0 0 0 4 4 - - -          - - - - - 6 0 0 0 0 0 0 0 0 4 - - - -           - - - - - 0 0 0 0 0 0 0 0 0 - - - - -            - - - - 1 0 0 0 0 0 0 0 0 3 - - - - -             - - - 1 1 0 0 0 0 0 0 0 3 3 - - - - -              - - 1 1 1 0 0 0 0 0 0 3 3 3 - - - - -               - 1 1 1 1 0 0 0 0 0 3 3 3 3 - - - - -                - - - - - 2 2 2 2 - - - - - - - - - -                 - - - - - 2 2 2 - - - - - - - - - - -                  - - - - - 2 2 - - - - - - - - - - - -                   - - - - - 2 - - - - - - - - - - - - -                    - - - - - - - - - - - - - - - - - - -Cells within the board contain 0 if empty, or a team number (1..6) if occupied by a piece of that team.  An extra border of nils around the whole reduces bounds checking to a nil test.sixDeltas:  An array giving the x@y deltas for the 6 valid steps in CCW order from a given cell.  For team 1 they are: in fr, fl, l, bl, br, r.  To get, eg fl for a given team, use (sixDeltas atWrap: team+1).teams:  An array of six teams, each of which is an array of the x@y locations of the 10 pieces.homes:  The x@y coordinates of the six home points, namely 14@2, 18@6, 14@14, 6@18, 2@14, 6@6.  The goal, or farthest point in destination triangle, is thus (homes atWrap: teamNo+3).autoPlay:  An array of booleans, parallel to teams, where true means that Squeak will make the moves for the corresponding team.whoseMove:  A team number specifying whose turn it is next.  Set to 0 when game is over.plannedMove:  If not nil, it means the board is in a state where it is animating the next move to be made so that it can be seen.movePhase:  Holds the state of display of the planned move so that, eg, it can appear one jump at a time.  Advances from 1 to (plannedMove size * 2).A move is an array of locs which are the path of the move.Once the morph is open, the menu command 'reset...' allows you to reset the board and change the number of players.  The circle at turnIndicatorLoc indicates the color of the team whose turn it is.  If it is a human, play waits for drag and drop of a piece of that color.The current strategy is very simple: generate all moves, score them and pick the best.  Beyond this, it will look ahead a number of moves, but this becomes very expensive without pruning.  Pruning would help the speed of play, especially in the end game where we look a little deeper.  A more effective strategy would consider opponents' possible moves as well, but this is left as an exercise for the serious programmer.!!ChineseCheckers methodsFor: 'layout' stamp: 'ajh 2/15/2001 21:11'!acceptDroppingMorph: aPiece event: evt	| dropLoc |	dropLoc := self boardLocAt: evt cursorPoint.	dropLoc = aPiece boardLoc ifTrue:  "Null move"		[^ aPiece rejectDropMorphEvent: evt].	(plannedMove := (self allMovesFrom: aPiece boardLoc)				detect: [:move | move last = dropLoc]				ifNone: [nil])		ifNil: [^ aPiece rejectDropMorphEvent: evt.   "Not a valid move"].	super acceptDroppingMorph: aPiece event: evt.	movePhase := 1.  "Start the animation if any."! !!ChineseCheckers methodsFor: 'menus' stamp: 'di 4/13/2000 13:23'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Include our modest command set in the ctrl-menu"	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	self addMenuItemsTo: aCustomMenu hand: aHandMorph! !!ChineseCheckers methodsFor: 'menu' stamp: 'KR 3/28/2008 02:17'!addMenuItemsTo: aMenu hand: aHandMorph	aMenu add: 'new game' translated target: self action: #newGame.	aMenu add: 'reset...' translated target: self action: #reset.	animateMoves		ifTrue: [aMenu add: 'don''t animate moves' translated target: self action: #dontAnimateMoves]		ifFalse: [aMenu add: 'animate moves' translated target: self action: #animateMoves]! !!ChineseCheckers methodsFor: 'menu' stamp: 'di 4/13/2000 13:36'!animateMoves	animateMoves := true! !!ChineseCheckers methodsFor: 'menu' stamp: 'di 4/13/2000 13:36'!dontAnimateMoves	animateMoves := false! !!ChineseCheckers methodsFor: 'menu' stamp: 'di 4/13/2000 13:32'!newGame	"Reset the board, with same teams."	| teamNumbers |	teamNumbers := (1 to: 6) reject: [:i | (teams at: i) isEmpty].	self teams: teamNumbers		 autoPlay: (teamNumbers collect: [:i | autoPlay at: i]).! !!ChineseCheckers methodsFor: 'menu' stamp: 'KR 3/28/2008 02:18'!reset	"Reset the board, choosing anew how many teams."	| nPlayers nHumans |	nPlayers := (SelectionMenu 					selections: (1 to: 6)) 					startUpWithCaption: 'How many players?' translated.	nPlayers ifNil: [nPlayers := 2].	nHumans := (SelectionMenu 					selections: (0 to: nPlayers)) 					startUpWithCaption: 'How many humans?' translated.	nHumans ifNil: [nHumans := 1].	self teams: (#((1) (2 5) (2 4 6) (1 2 4 5) (1 2 3 4 6) (1 2 3 4 5 6)) at: nPlayers)		 autoPlay: ((1 to: nPlayers) collect: [:i | i > nHumans]).! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/13/2000 14:18'!allMovesFrom: boardLoc  "boardLoc must be occupied"	| team stepMoves jumpDict |	team := self at: boardLoc.	stepMoves := (sixDeltas collect: [:d | boardLoc + d])		select: [:p | (self at: p) notNil and: [(self at: p) = 0]].	jumpDict := Dictionary new.	jumpDict at: boardLoc put: (Array with: boardLoc).	self jumpFor: team from: boardLoc havingVisited: jumpDict.	jumpDict removeKey: boardLoc.	^ (stepMoves collect: [:p | {boardLoc. p}]) , jumpDict values		reject:		[:move |  "Don't include any moves that land in other homes."		(self distFrom: move last to: self boardCenter) >= 5  "In a home..."			and: [(self distFrom: move last to: (homes atWrap: team+3)) > 3  "...not my goal..."			and: [(self distFrom: move last to: (homes at: team)) > 3  "...nor my home"]]]! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/12/2000 23:23'!bestMove: ply forTeam: team	| score bestScore bestMove |	bestScore := -999.	(teams at: team) do:		[:boardLoc |		(self allMovesFrom: boardLoc) do:			[:move |			score := self score: move for: team.			(score > -99 and: [ply > 0]) ifTrue: 				[score := score  "Add 0.7 * score of next move (my guess)"					+ (0 max: ((self score: ((self copyBoard makeMove: move)							bestMove: ply - 1 forTeam: team) for: team) * 0.7))].			score > bestScore ifTrue:				[bestScore := score.  bestMove := move]]].	^ bestMove! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/10/2000 08:27'!checkDoneAfter: move	| team locsAfterMove |	(team := self at: move first) = 0 ifTrue: [^ false].	(locsAfterMove := (teams at: team) copy) replaceAll: move first with: move last.	^ self testDone: locsAfterMove for: team! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/12/2000 23:40'!endGameFor: team	"Return true if we are in the end game (all players within 1 of home triangle)."	| goalLoc |	goalLoc := homes atWrap: team+3.  "Farthest cell across the board"	(teams at: team)		do: [:boardLoc | (self distFrom: boardLoc to: goalLoc) > 4 ifTrue: [^ false]].	^ true! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/12/2000 20:36'!jumpFor: team from: loc havingVisited: dict	"Recursively explore all jumps from loc, leaving in dict	the prior position from which we got there"	"Fasten seatbelts..."	((((sixDeltas		collect: [:d | loc + d])		select: [:p | (self at: p) notNil and: [(self at: p) > 0]])		collect: [:p | p + (p - loc)])		select: [:p | (self at: p) notNil and: [(self at: p) = 0]])		do: [:p | (dict includesKey: p) ifFalse:			[dict at: p put: ((dict at: loc) copyWith: p).			self jumpFor: team from: p havingVisited: dict]]! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/10/2000 08:17'!makeMove: move	| team |	team := self at: move first.	self at: move last put: team.	self at: move first put: 0.	(teams at: team) replaceAll: move first with: move last! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/13/2000 14:21'!score: move for: team	"Return the decrease in distance toward this team's goal"	| goal closerToGoal wasBack nowBack |	goal := homes atWrap: team+3.	wasBack := self distFrom: move first to: goal.	nowBack := self distFrom: move last to: goal.	closerToGoal := wasBack - nowBack.	closerToGoal < -1 ifTrue: [^ -99].  "Quick rejection if move backward more than 1"	(nowBack <= 3 and: [self checkDoneAfter: move]) ifTrue: [^ 999].	"Reward closerToGoal, but add bias to move those left far behind."	^ (closerToGoal*5) + wasBack! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/12/2000 23:40'!testDone: teamLocs for: team	"Return true if we are done (all players in home triangle)."	| goalLoc |	goalLoc := homes atWrap: team+3.	teamLocs		do: [:boardLoc | (self distFrom: boardLoc to: goalLoc) > 3 ifTrue: [^ false]].	^ true! !!ChineseCheckers methodsFor: 'accessing'!at: p	^ (board at: p x) at: p y! !!ChineseCheckers methodsFor: 'accessing'!at: p put: x	^ (board at: p x) at: p y put: x! !!ChineseCheckers methodsFor: 'initialization'!board: b teams: t	board := b.	teams := t! !!ChineseCheckers methodsFor: 'initialization' stamp: 'di 4/9/2000 20:55'!copyBoard	"Return a copy of the board for the purpose of looking ahead one or more moves."	^ self copy		board: (board collect: [:row | row copy])		teams: (teams collect: [:team | team copy])! !!ChineseCheckers methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:18'!defaultColor"answer the default color/fill style for the receiver"	^ Color		r: 0.6		g: 0.4		b: 0.0! !!ChineseCheckers methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:19'!initialize	"Default creation is for one person against Squeak."	super initialize.	""	self extent: 382 @ 413.	animateMoves := true.	self teams: #(2 5 ) autoPlay: {false. true}! !!ChineseCheckers methodsFor: 'initialization' stamp: 'di 4/12/2000 23:44'!teams: teamsPlaying autoPlay: ifAuto	"Initialize board, teams, steps, jumps"	| p q teamInPlay |	colors := (#(gray) , #(red green blue cyan magenta yellow white) shuffled)				collect: [:c | Color perform: c].  "New set of colors each time."	self removeAllMorphs.  "eg, from previous game."	board := (1 to: 19) collect: [:i | Array new: 19].	sixDeltas := {0@1. -1@1. -1@0. 0@ -1. 1@ -1. 1@0}.	homes := {14@2. 18@6. 14@14. 6@18. 2@14. 6@6}.	teams := (1 to: 6) collect: [:i | OrderedCollection new].	autoPlay := (1 to: 6) collect: [:i | false].	1 to: 6 do:		[:team | p:= homes at: team.		(teamInPlay := teamsPlaying includes: team) ifTrue:			[autoPlay at: team put: (ifAuto at: (teamsPlaying indexOf: team))].		"Place empty cells in rhombus extending out from each		home, and occupied cells in active home triangles."		1 to: 5 do: [:i | q := p.			1 to: 5 do: [:j |				(teamInPlay and: [j <= (5 - i)])					ifTrue: [self at: q put: team.							(teams at: team) add: q.							self addMorph:								((ChineseCheckerPiece									newBounds: ((self cellPointAt: q) extent: self pieceSize)									color: (colors at: team+1))										setBoard: self loc: q)]					ifFalse: [self at: q put: 0].				q := q + (sixDeltas at: team).  "right,forward"].			p := p + (sixDeltas atWrap: team+1).  "left,forward"].		teams at: team put: (teams at: team) asArray].	whoseMove := teamsPlaying first.	self addMorph:		((ChineseCheckerPiece			newBounds: ((self cellPointAt: self turnIndicatorLoc) extent: self pieceSize)			color: (colors at: whoseMove+1))				setBoard: self loc: self turnIndicatorLoc).	plannedMove := nil.	self changed! !!ChineseCheckers methodsFor: 'board geometry'!boardCenter	^ 10@10! !!ChineseCheckers methodsFor: 'board geometry' stamp: 'di 4/9/2000 10:00'!boardLocAt: cellPoint	| dx dy row col |	dx := self width/15.0.  dy := dx * 0.8660254037844385 "(Float pi / 3) sin".	row := (cellPoint y - self position y) // dy + 1.	col := (cellPoint x - self position x) / (dx/2.0) + 16 - row // 2.	^ row @ col! !!ChineseCheckers methodsFor: 'board geometry' stamp: 'di 4/11/2000 17:18'!cellPointAt: boardLoc	| dx dy row col |	dx := self width/15.0.  dy := dx * 0.8660254037844385 "(Float pi / 3) sin".	row := boardLoc x.	col := boardLoc y.	^ self position + ((col*2+row-16*dx//2)@(row-1*dy)) asIntegerPoint! !!ChineseCheckers methodsFor: 'board geometry' stamp: 'di 3/13/2000 19:50'!distFrom: a to: b	"The six possible moves are: 1@0, 1@ -1, 0@1, 0@ -1, -1@0, -1@1."	| dx dy |	dx := b x - a x.	dy := b y - a y.	dx abs >= dy abs	ifTrue: ["Major change is in x-coord..."			dx >= 0			ifTrue: [(dy between: (0-dx) and: 0)						ifTrue: [^ dx  "no lateral motion"].					^ dx + ((0-dx) - dy max: dy - 0)  "added lateral dist"]			ifFalse: ["Reverse sign and rerun same code"					^ self distFrom: b to: a]]	ifFalse: ["Transpose and re-run same code"			^ self distFrom: a transposed to: b transposed]! !!ChineseCheckers methodsFor: 'board geometry' stamp: 'di 4/11/2000 09:20'!pieceSize	^ self width asPoint // 20! !!ChineseCheckers methodsFor: 'board geometry' stamp: 'di 4/9/2000 09:44'!turnIndicatorLoc	^ 16@11! !!ChineseCheckers methodsFor: 'drawing' stamp: 'di 8/10/2000 09:40'!drawOn: aCanvas 	| row1 row2 offset dotExtent |	super drawOn: aCanvas.   "Draw square board"	"Only draw rows in the clipping region"	dotExtent := (self width//25) asPoint.	offset := self pieceSize - dotExtent + 1 // 2.  "Offset of smaller dots rel to larger"	row1 := (self boardLocAt: aCanvas clipRect topLeft) x max: 1.	row2 := (self boardLocAt: aCanvas clipRect bottomRight) x min: board size.	row1 to: row2 do:		[:row | (board at: row) doWithIndex:			[:cell :i | cell ifNotNil:				[aCanvas fillOval: ((self cellPointAt: (row@i)) + offset extent: dotExtent)					color: (colors at: cell+1)]]]! !!ChineseCheckers methodsFor: 'geometry' stamp: 'di 4/11/2000 09:21'!extent: newExtent	| extraY |	extraY := (newExtent x / 15.0 * 1.25) asInteger.	super extent: (newExtent x) @ (newExtent x + extraY).	self submorphsDo:		[:m | (m isKindOf: ChineseCheckerPiece) ifTrue:				[m position: (self cellPointAt: m boardLoc); extent: self pieceSize]]! !!ChineseCheckers methodsFor: 'event handling' stamp: 'sma 4/30/2000 09:23'!handlesMouseDown: evt	"Prevent stray clicks from picking up the whole game in MVC."	^ Smalltalk isMorphic not or: [evt yellowButtonPressed]! !!ChineseCheckers methodsFor: 'event handling' stamp: 'RAA 6/12/2000 08:57'!mouseDown: evt	| menu |	evt yellowButtonPressed ifFalse: [^ self].	menu := MenuMorph new defaultTarget: self.	self addMenuItemsTo: menu hand: evt hand.	menu popUpEvent: evt in: self world.! !!ChineseCheckers methodsFor: 'parts bin' stamp: 'sw 6/28/2001 11:32'!initializeToStandAlone 	"Default creation is for one person against Squeak."	super initializeToStandAlone.	self extent: 382@413.	self color: (Color r: 0.6 g: 0.4 b: 0.0).	self borderWidth: 2.	animateMoves := true.	self teams: #(2 5) autoPlay: {false. true}.! !!ChineseCheckers methodsFor: 'game sequence' stamp: 'di 4/13/2000 14:25'!nextTurn	(self testDone: (teams at: whoseMove) for: whoseMove) ifTrue:		[(self pieceAt: self turnIndicatorLoc) extent: self width asPoint//6; borderWidth: 2.		^ whoseMove := 0.  "Game over."].		[whoseMove := whoseMove\\6 + 1.	(teams at: whoseMove) isEmpty]  "Turn passes to the next player"		whileTrue: [].	(self pieceAt: self turnIndicatorLoc) color: (colors at: whoseMove+1)! !!ChineseCheckers methodsFor: 'game sequence' stamp: 'di 4/11/2000 08:35'!showNextMoveSegment	"Display the current move in progress.  Starts with movePhase = 1.	Increments movePhase at each tick.  Ends by setting movePhase to 0."	| dot p1 p2 delta secondPhase line |	delta := self width//40.	movePhase <= plannedMove size	ifTrue:		["First we trace the move with dots and lines..."		movePhase = 1 ifTrue: [pathMorphs := OrderedCollection new].		p1 := self cellPointAt: (plannedMove at: movePhase).		dot := (ImageMorph new image: (Form dotOfSize: 7)) position: p1 + delta - (7//2).		self addMorph: dot.  pathMorphs addLast: dot.		movePhase > 1 ifTrue:			[p2 := self cellPointAt: (plannedMove at: movePhase-1).			line := PolygonMorph vertices: {p2 + delta. p1 + delta} color: Color black					borderWidth: 3 borderColor: Color black.			self addMorph: line.  pathMorphs addLast: line]]	ifFalse:		["...then we erase the path while moving the piece."		secondPhase := movePhase - plannedMove size.		pathMorphs removeFirst delete.		secondPhase > 1 ifTrue:			[pathMorphs removeFirst delete.			self makeMove: {plannedMove at: secondPhase - 1. plannedMove at: secondPhase}.			(self pieceAt: (plannedMove at: secondPhase - 1))				position: (self cellPointAt: (plannedMove at: secondPhase));				setBoard: self loc: (plannedMove at: secondPhase).			self changed]].	(movePhase := movePhase + 1) > (plannedMove size * 2)		ifTrue: [movePhase := 0  "End of animated move"].! !!ChineseCheckers methodsFor: 'game sequence' stamp: 'dgd 2/21/2003 23:14'!step	whoseMove = 0 ifTrue: [^self].	"Game over."	plannedMove isNil 		ifTrue: 			[(autoPlay at: whoseMove) ifFalse: [^self].	"Waiting for a human."			plannedMove := (self endGameFor: whoseMove) 						ifTrue: 							["Look deeper at the end."							self bestMove: 2 forTeam: whoseMove]						ifFalse: [self bestMove: 1 forTeam: whoseMove].			movePhase := 1	"Start the animated move"].	animateMoves 		ifTrue: 			["Display the move in phases..."			movePhase > 0 ifTrue: [^self showNextMoveSegment]]		ifFalse: 			["... or skip the entire animated move if requested."			self makeMove: plannedMove.			(self pieceAt: plannedMove first)				position: (self cellPointAt: plannedMove last);				setBoard: self loc: plannedMove last.			self changed.			movePhase := 0].	plannedMove := nil.	"End the animated move"	self nextTurn! !!ChineseCheckers methodsFor: 'drag and drop' stamp: 'di 4/8/2000 23:45'!okToPickUpPieceAt: boardLoc	^ (self at: boardLoc) = whoseMove and: [(autoPlay at: whoseMove) not]! !!ChineseCheckers methodsFor: 'drag and drop' stamp: 'di 4/9/2000 08:30'!pieceAt: boardLoc	self submorphsDo:		[:m | ((m isMemberOf: ChineseCheckerPiece) and: [m boardLoc = boardLoc])				ifTrue: [^ m]].	^ nil! !!ChineseCheckers methodsFor: 'printing' stamp: 'dgd 2/21/2003 23:14'!printOn: s 	"For testing only"	1 to: board size		do: 			[:row | 			s				cr;				next: row put: $ .			(board at: row) do: 					[:cell | 					s						space;						nextPut: (cell isNil ifTrue: [$-] ifFalse: [cell printString last])]]! !!ChineseCheckers methodsFor: 'testing' stamp: 'di 4/12/2000 23:43'!stepTime	^ 200! !!ChineseCheckers methodsFor: 'dropping/grabbing' stamp: 'di 4/9/2000 10:44'!wantsDroppedMorph: aPiece event: evt	^ aPiece isKindOf: ChineseCheckerPiece! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ChineseCheckers class	instanceVariableNames: ''!!ChineseCheckers class methodsFor: 'parts bin' stamp: 'tak 7/25/2007 00:04'!descriptionForPartsBin	^ self partName:	'ChineseCheckers' translatedNoop		categories:		{'Games' translatedNoop}		documentation:	'Halma - the classic board game of Chinese Checkers, written by Dan Ingalls' translatedNoop! !AlignmentMorph subclass: #FreeCell	instanceVariableNames: 'board cardsRemainingDisplay elapsedTimeDisplay gameNumberDisplay lastGameLost state autoMoveRecursionCount myFillStyle'	classVariableNames: 'Statistics'	poolDictionaries: ''	category: 'Etoys-Squeakland-Morphic-Games'!!FreeCell methodsFor: 'actions' stamp: 'djp 10/31/1999 21:17'!autoMovingHome	elapsedTimeDisplay pause.	autoMoveRecursionCount := autoMoveRecursionCount + 1.! !!FreeCell methodsFor: 'actions' stamp: 'djp 10/31/1999 21:35'!boardAction: actionSymbol	actionSymbol = #cardMovedHome 	ifTrue: [^self cardMovedHome].	actionSymbol = #autoMovingHome	ifTrue: [^self autoMovingHome].! !!FreeCell methodsFor: 'actions' stamp: 'di 3/5/2000 15:30'!cardMovedHome	cardsRemainingDisplay value: (cardsRemainingDisplay value - 1).	autoMoveRecursionCount := autoMoveRecursionCount - 1 max: 0.	cardsRemainingDisplay value = 0 		ifTrue: [self gameWon]		ifFalse: [autoMoveRecursionCount = 0 ifTrue: [elapsedTimeDisplay continue]].! !!FreeCell methodsFor: 'actions' stamp: 'di 3/5/2000 16:20'!gameLost	state := #lost.	elapsedTimeDisplay stop.	cardsRemainingDisplay highlighted: true; flash: true.	Statistics gameLost: self currentGame! !!FreeCell methodsFor: 'actions' stamp: 'di 3/5/2000 16:20'!gameWon	state := #won.	elapsedTimeDisplay stop; highlighted: true; flash: true.	Statistics gameWon: self currentGame! !!FreeCell methodsFor: 'actions' stamp: 'asm 11/24/2003 22:49'!help	| window helpMorph |	window := SystemWindow labelled: 'FreeCell Help' translated.	window model: self.	helpMorph := (PluggableTextMorph new editString: self helpText) lock.	window		addMorph: helpMorph		frame: (0 @ 0 extent: 1 @ 1).	window openInWorld! !!FreeCell methodsFor: 'actions' stamp: 'di 12/12/2000 13:08'!inAutoMove	"Return true if an automove sequence is in progress"	^ autoMoveRecursionCount > 0! !!FreeCell methodsFor: 'actions' stamp: 'di 1/16/2000 10:35'!newGame	Collection initialize.	self newGameNumber: nil.	state := #newGame! !!FreeCell methodsFor: 'actions' stamp: 'di 3/5/2000 16:21'!newGameNumber: aSeedOrNil 	cardsRemainingDisplay value ~~ 0 ifTrue: [self gameLost].	cardsRemainingDisplay flash: false; highlighted: false; value: 52.	elapsedTimeDisplay flash: false; highlighted: false.	"board handles nil case"	self board pickGame: aSeedOrNil.	elapsedTimeDisplay reset; start.	gameNumberDisplay value: self currentGame! !!FreeCell methodsFor: 'actions' stamp: 'th 12/15/1999 15:05'!pickGame	| seed |	seed := self promptForSeed.	seed isNil ifTrue: [^ self].	self newGameNumber: seed.	state := #pickGame! !!FreeCell methodsFor: 'actions' stamp: 'asm 11/24/2003 22:50'!promptForSeed	| ss ii hh |	[hh := board hardness				ifNil: [0].	ss := FillInTheBlank request: 'Pick a game number between 1 and 32000.orset the hardness of the next game by typing ''H 30''.Above 100 is very hard.  Zero is standard game.Current hardness is: ' translated , hh printString.	"Let the user cancel."	ss isEmpty		ifTrue: [^ nil].	ss := ss withoutQuoting.	ss first asLowercase == $h		ifTrue: ["Set the hardness"			[ii := ss numericSuffix]				on: Error				do: [ii := 0].			board hardness: ii.			^ nil].	[ii := ss asNumber asInteger]		on: Error		do: [ii := 0].	ii between: 1 and: 32000] whileFalse.	^ ii! !!FreeCell methodsFor: 'actions' stamp: 'di 3/5/2000 15:35'!quit	cardsRemainingDisplay value ~~ 0 ifTrue: [self gameLost].	self owner == self world		ifTrue: [self delete]		ifFalse: [self owner delete].	Statistics close! !!FreeCell methodsFor: 'actions' stamp: 'th 12/15/1999 15:03'!sameGame	self newGameNumber: self currentGame.	state := #sameGame.! !!FreeCell methodsFor: 'actions' stamp: 'djp 10/24/1999 15:07'!statistics	Statistics display! !!FreeCell methodsFor: 'accessing' stamp: 'djp 10/31/1999 19:28'!board	board ifNil: 		[board := FreeCellBoard new			target: self;			actionSelector: #boardAction:].	^board! !!FreeCell methodsFor: 'accessing' stamp: 'djp 10/24/1999 21:36'!currentGame	^self board cardDeck seed! !!FreeCell methodsFor: 'accessing' stamp: 'asm 11/24/2003 22:48'!helpText	^ 'The objective of FreeCell is to move all of the cards to the four "home cells" in the upper right corner.  Each home cell will hold one suit and must be filled sequentially starting with the Ace.There are four "free cells" in the upper left corner that can each hold one card.  Cards can be moved from the bottom of a stack to a free cell or to another stack.  When moving a card to another stack, it must have a value that is one less than the exposed card and of a different color.' translated! !!FreeCell methodsFor: 'private' stamp: 'mt 4/10/2018 11:25'!buildButton: aButton target: aTarget label: aLabel selector: aSelector	"wrap a button or switch in an alignmentMorph to provide some space around the button"	| a |	aButton 		target: aTarget;		label: aLabel;		actionSelector: aSelector;		borderStyle: (BorderStyle raised width: 2);		color: Color gray.	a := AlignmentMorph newColumn		wrapCentering: #center; cellPositioning: #topCenter;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		color: Color transparent;		layoutInset: 1.	a addMorph: aButton.	^ a! !!FreeCell methodsFor: 'private' stamp: 'ar 11/9/2000 21:17'!wrapPanel: anLedPanel label: aLabel	"wrap an LED panel in an alignmentMorph with a label to its left"	| a |	a := AlignmentMorph newRow		wrapCentering: #center; cellPositioning: #leftCenter;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 0;		layoutInset: 5;		color: Color transparent.	a addMorph: anLedPanel.	a addMorph: (StringMorph contents: aLabel). 	^ a! !!FreeCell methodsFor: 'visual properties' stamp: 'RAA 3/3/2000 23:28'!colorNearBottom	^Color r: 0.0 g: 0.455 b: 0.18! !!FreeCell methodsFor: 'visual properties' stamp: 'RAA 3/4/2000 10:26'!colorNearTop	^ (Color r: 0.304 g: 0.833 b: 0.075)! !!FreeCell methodsFor: 'visual properties' stamp: 'RAA 3/4/2000 17:01'!fillStyle	myFillStyle ifNil: [		myFillStyle := GradientFillStyle ramp: {			0.0 -> self colorNearTop. 			1.0 -> self colorNearBottom		}.	].	^myFillStyle		origin: self position;		direction: (self width // 2)@self height! !!FreeCell methodsFor: 'user interface' stamp: 'RAA 3/3/2000 23:29'!defaultBackgroundColor	^Color r: 0.365 g: 1.0 b: 0.09! !!FreeCell methodsFor: 'user interface' stamp: 'th 12/15/1999 15:20'!modelSleep	"When fixing #contains: calls beware of reinventing #includes:"	(#(newGame sameGame pickGame won lost ) includes: state)		ifTrue: [elapsedTimeDisplay pause]! !!FreeCell methodsFor: 'user interface' stamp: 'th 12/15/1999 15:22'!modelWakeUp	"Maybe less performant but more readable"	(#(won lost) includes: state)		ifFalse: [elapsedTimeDisplay resume]! !!FreeCell methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:27'!defaultBorderWidth	"answer the default border width for the receiver"	^ 2! !!FreeCell methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:26'!defaultColor	"answer the default color/fill style for the receiver"	^ self colorNearTop! !!FreeCell methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:27'!initialize	"initialize the state of the receiver"	super initialize.	""	Statistics newSession.	autoMoveRecursionCount := 0.	self listDirection: #topToBottom.	self wrapCentering: #center;		 cellPositioning: #topCenter.	self vResizing: #shrinkWrap.	self hResizing: #shrinkWrap.	self		 addMorph: self makeControls;		 addMorph: self board;		 newGame! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:47'!makeCardsRemainingDisplay	cardsRemainingDisplay := LedMorph new digits: 2;				 extent: 2 * 10 @ 15.	^ self wrapPanel: cardsRemainingDisplay label: 'Cards Left: ' translated! !!FreeCell methodsFor: 'initialization' stamp: 'mt 4/10/2018 10:58'!makeControlBar	^AlignmentMorph newRow		color: self colorNearBottom;		borderStyle: (BorderStyle inset width: 2);		layoutInset: 0;		hResizing: #spaceFill; vResizing: #shrinkWrap; wrapCentering: #center; cellPositioning: #leftCenter;		yourself.! !!FreeCell methodsFor: 'initialization' stamp: 'djp 10/24/1999 14:38'!makeControls	^self makeControlBar		addMorph: AlignmentMorph newVariableTransparentSpacer;		addMorph: self makeHelpButton;		addMorph: self makeQuitButton;		addMorph: self makeStatisticsButton;		addMorph: self makeGameNumberDisplay;		addMorph: self makePickGameButton;		addMorph: self makeSameGameButton;		addMorph: self makeNewGameButton;		addMorph: self makeElapsedTimeDisplay;		addMorph: self makeCardsRemainingDisplay;		yourself.! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:47'!makeElapsedTimeDisplay	elapsedTimeDisplay := LedTimerMorph new digits: 3;				 extent: 3 * 10 @ 15.	^ self wrapPanel: elapsedTimeDisplay label: 'Elapsed Time: ' translated! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:47'!makeGameNumberDisplay	gameNumberDisplay := LedMorph new digits: 5;				 extent: 5 * 10 @ 15.	^ self wrapPanel: gameNumberDisplay label: 'Game #: ' translated! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:47'!makeHelpButton	^ self		buildButton: SimpleButtonMorph new		target: self		label: 'Help' translated		selector: #help! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:47'!makeNewGameButton	^ self		buildButton: SimpleButtonMorph new		target: self		label: 'New game' translated		selector: #newGame! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:47'!makePickGameButton	^ self		buildButton: SimpleButtonMorph new		target: self		label: 'Pick game' translated		selector: #pickGame! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:48'!makeQuitButton	^ self		buildButton: SimpleButtonMorph new		target: self		label: 'Quit' translated		selector: #quit! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:48'!makeSameGameButton	^ self		buildButton: SimpleButtonMorph new		target: self		label: 'Same game' translated		selector: #sameGame! !!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:48'!makeStatisticsButton	^ self		buildButton: SimpleButtonMorph new		target: self		label: 'Statistics' translated		selector: #statistics! !!FreeCell methodsFor: 'initialization' stamp: 'djp 10/31/1999 18:48'!openInWindowLabeled: aString inWorld: aWorld	^(super openInWindowLabeled: aString inWorld: aWorld)		model: self;		yourself! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FreeCell class	instanceVariableNames: ''!!FreeCell class methodsFor: 'parts bin' stamp: 'tak 7/25/2007 00:06'!descriptionForPartsBin	^ self partName:	'FreeCell' translatedNoop		categories:		{'Games' translatedNoop}		documentation:	'A unique solitaire card game' translatedNoop! !!FreeCell class methodsFor: 'class initialization' stamp: 'djp 10/24/1999 14:50'!initialize	Statistics := FreeCellStatistics new.! !AlignmentMorph subclass: #FreeCellBoard	instanceVariableNames: 'cardDeck lastCardDeck freeCells homeCells stacks target actionSelector hardness'	classVariableNames: ''	poolDictionaries: ''	category: 'Etoys-Squeakland-Morphic-Games'!!FreeCellBoard commentStamp: '<historical>' prior: 0!The model of a freecell game.  Holds the stacks of cards.cardDeck		lastCardDeck		freeCells		homeCells		stacks		array of CardDecks of the columns of cards.----Hardness: a number from 1 to 10000.  	After dealing, count down the number.  For each count, go to next column, pick a ramdom card (with same generator as deck) and move it one place in its stack.  This is a kind of bubble sort.  Interesting that the slowness of bubble sort is a plus -- gives fine gradation in the hardness.	Moving a card:  Move red cards to deep half, black to shallow (or vice versa).  Within a color, put low cards deep and high cards shallow.  	If speed is an issue, move several steps at once, decrementing counter. 		(May make it easier?  If running columns, need a way to make harder in other ways.)!!FreeCellBoard methodsFor: 'actions' stamp: 'th 12/9/1999 19:10'!acceptCard: aCard onStack: aDeck	" assumes that number of cards was check at drag time, need to reduce count if dropping	into an empty stack"	aCard hasSubmorphs 		ifTrue: [			aDeck ifEmpty: [				(aCard submorphCount+1) > (self maxDraggableStackSize: true)					ifTrue: [^false]]]		ifFalse: [^ nil].	^nil.! !!FreeCellBoard methodsFor: 'actions' stamp: 'th 12/15/1999 16:17'!acceptSingleCard: aCard on: aDeck 	"Home cells and free cells don't accept multiple cards on a home cell, 	defer to deck for other cases"	aCard hasSubmorphs		ifTrue: [^ false]		ifFalse: [^ nil]! !!FreeCellBoard methodsFor: 'actions' stamp: 'th 12/15/1999 16:15'!cardMoved	"Free cells and stacks do nothing special here - yet - th 12/15/1999 	16:15 "	self autoMoveCardsHome! !!FreeCellBoard methodsFor: 'actions' stamp: 'djp 10/31/1999 22:02'!cardMovedHome	self autoMoveCardsHome.	self performActionSelector: #cardMovedHome.! !!FreeCellBoard methodsFor: 'actions' stamp: 'RAA 3/4/2000 17:07'!doubleClickInStack: aDeck OnCard: aCard	"if there is an empty free cell, move the card there. otherwise try for an empty stack"	aCard == aDeck topCard ifFalse: [^self].	freeCells do: [:freeCell |		freeCell ifEmpty: [			self visiblyMove: aCard to: freeCell.			^ aCard		]	].	stacks do: [ :each |		each ifEmpty: [			self visiblyMove: aCard to: each.			^ aCard		]	].! !!FreeCellBoard methodsFor: 'actions' stamp: 'djp 10/24/1999 03:08'!dragCard: aCard fromHome: aCardDeck	^nil		"don't allow any cards to be dragged from a home cell"! !!FreeCellBoard methodsFor: 'actions' stamp: 'djp 10/24/1999 00:46'!dragCard: aCard fromStack: aCardDeck	| i cards |	cards := aCardDeck cards.	i := cards indexOf: aCard ifAbsent: [^ nil].	i > (self maxDraggableStackSize: false) ifTrue: [^ nil].	[i > 1] whileTrue:		[(aCardDeck inStackingOrder: (cards at: i-1) 					onTopOf: (cards at: i)) ifFalse: [^ nil].		i := i-1].	^ aCard! !!FreeCellBoard methodsFor: 'actions' stamp: 'di 12/12/2000 13:08'!inAutoMove	"Return true if an automove sequence is in progress"	^ owner inAutoMove! !!FreeCellBoard methodsFor: 'accessing' stamp: 'djp 10/16/1999 16:21'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector := nil].	actionSelector := aSymbolOrString asSymbol.! !!FreeCellBoard methodsFor: 'accessing' stamp: 'djp 10/11/1999 15:51'!cardDeck	^cardDeck! !!FreeCellBoard methodsFor: 'accessing' stamp: 'tk 3/30/2001 13:08'!hardness	^ hardness! !!FreeCellBoard methodsFor: 'accessing' stamp: 'tk 3/30/2001 13:08'!hardness: integer	hardness := integer	"or nil"! !!FreeCellBoard methodsFor: 'accessing' stamp: 'djp 10/16/1999 15:33'!target: anObject	target := anObject! !!FreeCellBoard methodsFor: 'hardness' stamp: 'tk 3/30/2001 11:53'!addHardness	| cnt rand pileInd pile |	"post process the layout of cards to make it harder.  See class comment."	hardness ifNil: [^ self].	cnt := hardness.	rand := Random new seed: cardDeck seed.  "Same numbers but different purpose"	pileInd := 1. 	[(cnt := cnt - 1) > 0] whileTrue: [		pile := stacks atWrap: (pileInd := pileInd + 1).		cnt := cnt - (self makeHarder: pile rand: rand toDo: cnt)].  "mostly 0, but moves cards"! !!FreeCellBoard methodsFor: 'hardness' stamp: 'tk 3/30/2001 12:22'!makeHarder: pile rand: rand toDo: cnt	| deepColor ind thisPile thisCard otherCard |	"Move cards in a stack to make it harder.  Pick a card from the pile.  Only consider moving it deeper (toward last of pile)."	deepColor := stacks first cards last suitColor.	ind := ((pile cards size - 1) atRandom: rand).	"front card"	thisPile := pile cards.  "submorphs array. We will stomp it."	thisCard := thisPile at: ind.	otherCard := thisPile at: ind+1.	"Move deepColor cards deeper, past cards of the other color"	(thisCard suitColor == deepColor) & (otherCard suitColor ~~ deepColor) ifTrue: [		thisPile at: ind put: otherCard.		thisPile at: ind+1 put: thisCard.		^ 0].	"single moves for now.  Make multiple when it's too slow this way"	"When colors the same, move low numbered cards deeper, past high cards"	(thisCard suitColor == otherCard suitColor) ifTrue: [		(thisCard cardNumber < otherCard cardNumber) ifTrue: [			thisPile at: ind put: otherCard.			thisPile at: ind+1 put: thisCard.			^ 0]].	"single moves for now.  Make multiple when it's too slow this way"	^ 0! !!FreeCellBoard methodsFor: 'private' stamp: 'RAA 3/4/2000 10:48'!autoMoveCardsHome	| first |	first := false.	(self stacks, self freeCells) do: [:deck |		self homeCells do: [ :homeCell |			deck hasCards ifTrue: [				(homeCell repelCard: deck topCard) ifFalse: [					(self isPlayableCardInHomeCells: deck topCard) ifTrue: [						first ifFalse: [ " trigger autoMoving event on first move."							first := true.							self performActionSelector: #autoMovingHome						].						self visiblyMove: deck topCard to: homeCell.					]				]			]		]	].! !!FreeCellBoard methodsFor: 'private' stamp: 'RAA 3/4/2000 17:11'!isPlayableCardInHomeCells: aPlayingCard	| unplayedOther topsThisColor topsOtherColor unplayedSame | 	" are all cards that could be played on this card if it stayed on the stack present in the	home cells?"	aPlayingCard cardNumber <= 2 ifTrue: [^true].	"special case for Aces and 2's"	topsThisColor := OrderedCollection new.	topsOtherColor := OrderedCollection new.	self homeCells do: [ :deck |		deck hasCards ifTrue: [			(aPlayingCard suitColor == deck topCard suitColor 					ifTrue: [topsThisColor] ifFalse: [topsOtherColor]) add: deck topCard cardNumber.		]	].	unplayedOther := topsOtherColor size < 2 ifTrue: [1] ifFalse: [topsOtherColor min + 1].	unplayedSame := topsThisColor size < 2 ifTrue: [1] ifFalse: [topsThisColor min + 1].	unplayedOther > (aPlayingCard cardNumber - 1) ifTrue: [^true].	unplayedOther < (aPlayingCard cardNumber - 1) ifTrue: [^false].	^unplayedSame >= (unplayedOther - 1)! !!FreeCellBoard methodsFor: 'private' stamp: 'djp 10/24/1999 00:50'!maxDraggableStackSize: dropIntoEmptyStack	"Note: dropIntoEmptyStack, means one less empty stack to work with.		This needs to be reevaluated at time of drop."	"Not super smart - doesn't use stacks that are buildable though not empty"	| nFree nEmptyStacks |	nFree := (freeCells select: [:d | d hasCards not]) size.	nEmptyStacks := (stacks select: [:d | d hasCards not]) size.	dropIntoEmptyStack ifTrue: [nEmptyStacks := nEmptyStacks - 1].	^ (1 + nFree) * (2 raisedTo: nEmptyStacks)! !!FreeCellBoard methodsFor: 'private' stamp: 'dgd 2/22/2003 18:45'!performActionSelector: actionSymbol 	(target notNil and: [actionSelector notNil]) 		ifTrue: [target perform: actionSelector with: actionSymbol]! !!FreeCellBoard methodsFor: 'private' stamp: 'di 12/12/2000 13:09'!visiblyMove: aCard to: aCell	| p1 p2 nSteps |	self inAutoMove ifFalse: [self captureStateBeforeGrab].	owner owner addMorphFront: aCard.	p1 := aCard position.	p2 := aCell position.	nSteps := 10.	1 to: nSteps-1 do: "Note final step happens with actual drop"		[:i | aCard position: ((p2*i) + (p1*(nSteps-i))) // nSteps.		self world displayWorld].	aCell acceptDroppingMorph: aCard event: nil! !!FreeCellBoard methodsFor: 'undo' stamp: 'di 12/12/2000 11:54'!captureStateBeforeGrab	self removeProperty: #stateBeforeGrab.	self setProperty: #stateBeforeGrab toValue: self capturedState! !!FreeCellBoard methodsFor: 'undo' stamp: 'di 12/12/2000 11:50'!capturedState	self valueOfProperty: #stateBeforeGrab ifPresentDo: [:st | ^ st].	^ {	freeCells collect: [:deck | deck submorphs].		homeCells collect: [:deck | deck submorphs].		stacks collect: [:deck | deck submorphs] }! !!FreeCellBoard methodsFor: 'undo' stamp: 'di 12/12/2000 12:14'!rememberUndoableAction: aBlock named: caption	self inAutoMove ifTrue: [^ aBlock value].	^ super rememberUndoableAction: aBlock named: caption! !!FreeCellBoard methodsFor: 'undo' stamp: 'di 12/12/2000 08:12'!undoFromCapturedState: st	freeCells with: st first do: [:deck :morphs | deck removeAllMorphs; addAllMorphs: morphs].	homeCells with: st second do: [:deck :morphs | deck removeAllMorphs; addAllMorphs: morphs].	stacks with: st third do: [:deck :morphs | deck removeAllMorphs; addAllMorphs: morphs]! !!FreeCellBoard methodsFor: 'layout' stamp: 'ar 11/20/2000 19:08'!cardCell	^PlayingCardDeck new		layout: #pile; 		listDirection: #topToBottom;		enableDragNDrop;		color: Color transparent;		borderColor: (Color gray alpha: 0.5);		borderWidth: 2;		layoutBounds: (0@0 extent: PlayingCardMorph width @ PlayingCardMorph height);		yourself! !!FreeCellBoard methodsFor: 'layout' stamp: 'RAA 3/3/2000 23:33'!cellsRow	| row |	row := (AlignmentMorph newRow)		vResizing: #shrinkWrap;		hResizing: #shrinkWrap;		color: Color transparent;		addAllMorphs: self freeCells;		addMorphBack: self cellsRowSpacer;		addAllMorphs: self homeCells;		yourself.	^row! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/17/1999 18:25'!cellsRowSpacer	| column |	column := (AlignmentMorph newColumn)		vResizing: #rigid;		hResizing: #rigid;		color: Color transparent;		extent: PlayingCardMorph cardSize;		yourself.	^column! !!FreeCellBoard methodsFor: 'layout' stamp: 'th 12/15/1999 16:14'!freeCell	| freeCell |	freeCell := self cardCell.	freeCell stackingPolicy: #single;	 emptyDropPolicy: #any;	 target: self;	 cardDroppedSelector: #cardMoved;	 acceptCardSelector: #acceptSingleCard:on:.	^ freeCell! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/11/1999 16:41'!freeCells	^freeCells ifNil: [freeCells := (1 to: 4) collect: [:i | self freeCell]]! !!FreeCellBoard methodsFor: 'layout' stamp: 'th 12/15/1999 16:12'!homeCell	| homeCell |	homeCell := self cardCell.	homeCell stackingPolicy: #straight;	 stackingOrder: #ascending;	 emptyDropPolicy: #inOrder;	 target: self;	 cardDroppedSelector: #cardMovedHome;	 cardDraggedSelector: #dragCard:fromHome:;	 acceptCardSelector: #acceptSingleCard:on:.	^ homeCell! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/11/1999 16:41'!homeCells	^homeCells ifNil: [homeCells := (1 to: 4) collect: [:i | self homeCell]]! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/11/1999 18:27'!layout	self 		addMorphBack: self cellsRow;		addMorphBack: self stacksRow.! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/11/1999 16:41'!stacks	^stacks ifNil: [stacks:= (1 to: 8) collect: [:i | self stack]]! !!FreeCellBoard methodsFor: 'layout' stamp: 'ar 11/20/2000 18:58'!stacksRow	| row |	row := (AlignmentMorph newRow)		vResizing: #spaceFill;		hResizing: #spaceFill;		wrapCentering: #topLeft;		cellPositioning: #topLeft;		color: Color transparent;		yourself.	self stacks do: [:stack |		row 			addMorphBack: AlignmentMorph newVariableTransparentSpacer;			addMorphBack: stack].	row addMorphBack: AlignmentMorph newVariableTransparentSpacer.	^row! !!FreeCellBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:27'!defaultColor	"answer the default color/fill style for the receiver"	^ Color green! !!FreeCellBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:31'!initialize	"initialize the state of the receiver"	super initialize.	""	self listDirection: #topToBottom;	  hResizing: #shrinkWrap;	  vResizing: #rigid;	  height: 500;	  layout! !!FreeCellBoard methodsFor: 'initialization' stamp: 'ul 3/13/2017 00:18'!pickGame: aSeedOrNil 	| sorted msg |	cardDeck := PlayingCardDeck newDeck.	aSeedOrNil == 1		ifTrue: ["Special case of game 1 does a time profile playing the entire 			(trivial) game."			sorted := cardDeck submorphs						sorted: [:a :b | a cardNumber >= b cardNumber].			cardDeck removeAllMorphs; addAllMorphs: sorted.			self resetBoard.			self world doOneCycle.			Utilities				informUser: 'Game #1 is a special casefor performance analysis' translated				during: [msg := self world firstSubmorph.					msg align: msg topRight with: owner bottomRight.					MessageTally						spyOn: [sorted last owner doubleClickOnCard: sorted last]]]		ifFalse: [aSeedOrNil				ifNotNil: [cardDeck seed: aSeedOrNil].			cardDeck shuffle.			self resetBoard]! !!FreeCellBoard methodsFor: 'initialization' stamp: 'tk 3/30/2001 12:20'!resetBoard	self purgeAllCommands.	self resetFreeCells;		resetHomeCells;		resetStacks;		addHardness;		changed.! !!FreeCellBoard methodsFor: 'initialization' stamp: 'djp 10/16/1999 20:06'!resetFreeCells	freeCells do: [:deck | deck removeAllCards]! !!FreeCellBoard methodsFor: 'initialization' stamp: 'djp 10/16/1999 20:06'!resetHomeCells	homeCells do: [:deck | deck removeAllCards]! !!FreeCellBoard methodsFor: 'initialization' stamp: 'djp 10/16/1999 20:06'!resetStacks	| card stackStream stack |	stacks do: [:deck | deck removeAllCards].	stackStream := ReadStream on: stacks.	[card := cardDeck deal.	card notNil] whileTrue: [		stack := stackStream next ifNil: [stackStream reset; next].		stack addCard: card].! !!FreeCellBoard methodsFor: 'drawing' stamp: 'RAA 3/4/2000 17:02'!drawOn: aCanvas	"we don't have anything to draw, but we need a color so the inset border of one of our submorphs will work"! !!FreeCellBoard methodsFor: 'card in a stack' stamp: 'ar 11/9/2000 20:55'!stack	^ PlayingCardDeck new color: Color transparent;	 layout: #stagger;	 listDirection: #topToBottom;	 enableDragNDrop;	 stackingPolicy: #altStraight;	 stackingOrder: #descending;	 emptyDropPolicy: #any;	 target: self;	 cardDroppedSelector: #cardMoved;	 cardDraggedSelector: #dragCard:fromStack:;	 acceptCardSelector: #acceptCard:onStack:;	 cardDoubleClickSelector: #doubleClickInStack:OnCard:! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FreeCellBoard class	instanceVariableNames: ''!!FreeCellBoard class methodsFor: 'new-morph participation' stamp: 'di 1/16/2000 10:39'!includeInNewMorphMenu	^false! !Object subclass: #FreeCellStatistics	instanceVariableNames: 'sessionWins sessionLosses totalWins totalLosses streakWins streakLosses winsWithReplay lossesWithReplay lastGameWon lastGameLost currentCount currentType window statsMorph'	classVariableNames: ''	poolDictionaries: ''	category: 'Etoys-Squeakland-Morphic-Games'!!FreeCellStatistics methodsFor: 'user interface' stamp: 'mt 4/10/2018 11:25'!buildButton: aButton target: aTarget label: aLabel selector: aSelector	"wrap a button or switch in an alignmentMorph to provide some space around the button"	| a |	aButton 		target: aTarget;		label: aLabel;		actionSelector: aSelector;		borderStyle: (BorderStyle raised width: 2);		color: Color gray.	a := AlignmentMorph newColumn		wrapCentering: #center; cellPositioning: #topCenter;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		color: Color transparent;		layoutInset: 1.	a addMorph: aButton.	^ a! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 19:20'!close	window ifNotNil: [		window delete.		window := nil].! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 16:42'!color	^Color green darker! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'asm 11/24/2003 22:55'!display	| panel |	(window notNil and: [window owner notNil]) ifTrue: [window activate. ^nil].	panel := AlignmentMorph newColumn.	panel		wrapCentering: #center; cellPositioning: #topCenter;		hResizing: #rigid;		vResizing: #rigid;		extent: 250@150;		color: self color;		addMorphBack: self makeStatistics;		addMorphBack: self makeControls.	window := panel openInWindowLabeled: 'FreeCell Statistics' translated.! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'mt 4/10/2018 10:59'!makeControls	| row |	row := AlignmentMorph newRow.	row		wrapCentering: #center; cellPositioning: #leftCenter;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		color: self color;		borderStyle: (BorderStyle inset width: 2);		addMorphBack: self makeOkButton;		addMorphBack: self makeResetButton.	^row.! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'KR 3/28/2008 02:11'!makeOkButton	^self		buildButton: SimpleButtonMorph new		target: self		label: 'OK' translated		selector: #ok! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'KR 3/28/2008 02:11'!makeResetButton	^self		buildButton: SimpleButtonMorph new		target: self		label: 'Reset' translated		selector: #reset! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'mt 4/10/2018 10:59'!makeStatistics	| row |	row := AlignmentMorph newRow.	row		wrapCentering: #center; cellPositioning: #leftCenter;		hResizing: #spaceFill;		vResizing: #spaceFill;		color: self color;		borderStyle: (BorderStyle inset width: 2);		addMorphBack: (AlignmentMorph newColumn			wrapCentering: #center; cellPositioning: #topCenter;			color: self color;			addMorph: (statsMorph := TextMorph new contents: self statsText)).	^row.! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 19:04'!statsText	^ String cr,self printString,String cr! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 15:56'!stringMorphFromPrintOn: aSelector		^StringMorph new 		contents: (String streamContents: [:s | self perform: aSelector with: s]);		yourself.! !!FreeCellStatistics methodsFor: 'updating' stamp: 'djp 10/24/1999 19:04'!changed	window ifNotNil: [		statsMorph ifNotNil: [statsMorph contents: self statsText]]! !!FreeCellStatistics methodsFor: 'initialization' stamp: 'asm 11/24/2003 23:10'!defaultColor	"answer the default color/fill style for the receiver"	^ Color green! !!FreeCellStatistics methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:56'!initialize	super initialize.	self reset! !!FreeCellStatistics methodsFor: 'actions' stamp: 'di 3/5/2000 14:30'!gameLost: gameNumber	"Don't count multiple losses of the same game"	gameNumber = lastGameLost ifTrue: [^ self].	lastGameLost := gameNumber.	sessionLosses := sessionLosses + 1.	totalLosses := totalLosses + 1.	lossesWithReplay := lossesWithReplay + 1.	currentType = #losses		ifTrue: [currentCount := currentCount + 1]		ifFalse: 			[currentCount := 1.			currentType := #losses].	self updateStreak.	self changed! !!FreeCellStatistics methodsFor: 'actions' stamp: 'di 3/5/2000 16:48'!gameWon: gameNumber	sessionWins := sessionWins + 1.	totalWins := totalWins + 1.	gameNumber = lastGameWon ifFalse:		[gameNumber = lastGameLost ifTrue:			["Finally won a game by replaying"			lossesWithReplay := lossesWithReplay - 1].		winsWithReplay := winsWithReplay + 1].	lastGameWon := gameNumber.	currentType = #wins		ifTrue: [currentCount := currentCount + 1]		ifFalse: [currentCount := 1.				currentType := #wins].	self updateStreak.	self changed! !!FreeCellStatistics methodsFor: 'actions' stamp: 'djp 10/24/1999 19:21'!newSession	sessionWins := 0.	sessionLosses := 0.	currentCount := 0.	currentType := nil.	self changed.! !!FreeCellStatistics methodsFor: 'actions' stamp: 'djp 10/24/1999 17:15'!ok	window delete.	window := nil.! !!FreeCellStatistics methodsFor: 'actions' stamp: 'di 3/5/2000 14:30'!reset	sessionWins 		_ 0.	sessionLosses 	_ 0.	totalWins 		_ 0.	totalLosses 		_ 0.	streakWins		_ 0.	streakLosses 	_ 0. 	winsWithReplay := 0.	lossesWithReplay := 0.	lastGameWon	_ 0.	lastGameLost 	_ 0.	currentCount 	_ 0.	currentType		_ nil.	self changed.		! !!FreeCellStatistics methodsFor: 'actions' stamp: 'th 12/20/1999 20:42'!updateStreak	"I moved the code from #printWins:on: and #printLosses:on: here because 	 it is basically the same. I hope this increases the maintainability. 	th 12/20/1999 20:41"	currentType = #losses ifTrue: [streakLosses := streakLosses max: currentCount].	currentType = #wins ifTrue: [streakWins := streakWins max: currentCount]! !!FreeCellStatistics methodsFor: 'printing' stamp: 'asm 11/24/2003 22:57'!print: aNumber type: type on: aStream 	"I moved the code from #printWins:on: and #printLosses:on: here because 	it is basically 	the same. I hope this increases the maintainability. - th 12/20/1999 20:37"	aStream print: aNumber.	type = #wins		ifTrue: [aNumber = 1				ifTrue: [aStream nextPutAll: ' win' translated]				ifFalse: [aStream nextPutAll: ' wins' translated]].	type = #losses		ifTrue: [aNumber = 1				ifTrue: [aStream nextPutAll: ' loss' translated]				ifFalse: [aStream nextPutAll: ' losses' translated]]! !!FreeCellStatistics methodsFor: 'printing' stamp: 'di 3/5/2000 15:22'!printOn: aStream	self printSessionOn: aStream.	aStream cr.	self printTotalOn: aStream.	aStream cr.	self printReplaysOn: aStream.	aStream cr.	self printStreaksOn: aStream.! !!FreeCellStatistics methodsFor: 'printing' stamp: 'asm 11/24/2003 23:02'!printReplaysOn: aStream 	| total |	aStream nextPutAll: 'With replays: ' translated;		 tab.	self		print: winsWithReplay		type: #wins		on: aStream.	aStream nextPutAll: ', '.	self		print: lossesWithReplay		type: #losses		on: aStream.	total := winsWithReplay + lossesWithReplay.	total ~~ 0		ifTrue: [aStream nextPutAll: ', ';				 print: (winsWithReplay / total * 100) asInteger;				 nextPut: $%]! !!FreeCellStatistics methodsFor: 'printing' stamp: 'asm 11/24/2003 23:02'!printSessionOn: aStream 	| total |	aStream nextPutAll: 'This session: ' translated, String tab.	self		print: sessionWins		type: #wins		on: aStream.	aStream nextPutAll: ', '.	self		print: sessionLosses		type: #losses		on: aStream.	total := sessionWins + sessionLosses.	total ~~ 0		ifTrue: [aStream nextPutAll: ', ';				 print: (sessionWins / total * 100) asInteger;				 nextPut: $%]! !!FreeCellStatistics methodsFor: 'printing' stamp: 'KR 3/28/2008 02:13'!printStreaksOn: aStream 	aStream nextPutAll: 'Streaks: ' translated;		 tab;		 tab.	self		print: streakWins		type: #wins		on: aStream.	aStream nextPutAll: ', '.	self		print: streakLosses		type: #losses		on: aStream.	aStream cr; tab; tab; tab; tab; nextPutAll: 'Current: ' translated.	self		print: currentCount		type: currentType		on: aStream! !!FreeCellStatistics methodsFor: 'printing' stamp: 'asm 11/24/2003 23:03'!printTotalOn: aStream 	| total |	aStream nextPutAll: 'Total: ' translated;		 tab;		 tab;		 tab.	self		print: totalWins		type: #wins		on: aStream.	aStream nextPutAll: ', '.	self		print: totalLosses		type: #losses		on: aStream.	total := totalWins + totalLosses.	total ~~ 0		ifTrue: [aStream nextPutAll: ', ';				 print: (totalWins / total * 100) asInteger;				 nextPut: $%]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FreeCellStatistics class	instanceVariableNames: ''!!FreeCellStatistics class methodsFor: 'instance creation' stamp: 'di 1/16/2000 10:39'!includeInNewMorphMenu	^false! !AlignmentMorph subclass: #Mines	instanceVariableNames: 'board minesDisplay timeDisplay helpText'	classVariableNames: ''	poolDictionaries: ''	category: 'Etoys-Squeakland-Morphic-Games'!!Mines methodsFor: 'access' stamp: 'DAS 7/8/2001 15:25'!board	board ifNil:		[board := MinesBoard new			target: self;			actionSelector: #selection].	^ board! !!Mines methodsFor: 'access' stamp: 'asm 11/25/2003 22:31'!helpString	^ 'Mines is a quick and dirty knock-off of the Minesweeper game found on Windows. I used this to teach myself Squeak. I liberally borrowed from the <SameGame> example, so the code should look pretty familiar, though like any project it has rapidly ...morphed... to reflect my own idiosyncracies. Note especially the lack of any idiomatic structure to the code - I simply haven''t learned them yet.Mines is a very simple, yet extremely frustrating, game to play. The rules are just this: there are 99 mines laid down on the board. Find them without ""finding"" them. Your first tile is free - click anywhere. The tiles will tell you how many mines are right next to it, including the diagonals. If you uncover the number ''2'', you know that there are two mines hidden in the adjacent tiles. If you think you have found a mine, you can flag it by either ''shift'' clicking, or click with the ''yellow'' mouse button. Once you have flagged all of the mines adjacent to a numbered tile, you can click on the tile again to uncover the rest. Of course, you could be wrong about those too... You win once you have uncovered all of the tiles that do not contain mines. Good luck...David A. Smithdastrs@bellsouth.net' translated! !!Mines methodsFor: 'access' stamp: 'DAS 7/8/2001 14:45'!helpText	helpText ifNil:		[helpText := PluggableTextMorph new			width: self width; "board width;"			editString: self helpString].	^ helpText! !!Mines methodsFor: 'access' stamp: 'DAS 7/13/2001 03:28'!minesDisplay	^ minesDisplay! !!Mines methodsFor: 'access' stamp: 'DAS 7/13/2001 03:40'!timeDisplay	^ timeDisplay! !!Mines methodsFor: 'initialize' stamp: 'mt 4/10/2018 11:28'!buildButton: aButton target: aTarget label: aLabel selector: aSelector	"wrap a button or switch in an alignmentMorph to allow a row of buttons to fill space"	| a |	aButton 		target: aTarget;		label: aLabel;		actionSelector: aSelector;		borderStyle: (BorderStyle raised width: 2);		color: color.	a := AlignmentMorph newColumn		wrapCentering: #center; cellPositioning: #topCenter;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		color: color.	a addMorph: aButton.	^ a! !!Mines methodsFor: 'initialize' stamp: 'mt 4/10/2018 11:00'!makeControls	| row |	row := AlignmentMorph newRow color: color;				 borderWidth: 2;				 layoutInset: 3.	row borderStyle: BorderStyle inset.	row hResizing: #spaceFill;		 vResizing: #shrinkWrap;		 wrapCentering: #center;		 cellPositioning: #leftCenter;		 extent: 5 @ 5.	row		addMorph: (self				buildButton: SimpleSwitchMorph new				target: self				label: '  Help  ' translated				selector: #help:).	row		addMorph: (self				buildButton: SimpleButtonMorph new				target: self				label: '  Quit  ' translated				selector: #delete).	"row 	addMorph: (self 	buildButton: SimpleButtonMorph new 	target: self 	label: ' Hint '  translated	selector: #hint)."	row		addMorph: (self				buildButton: SimpleButtonMorph new				target: self				label: '  New game  ' translated				selector: #newGame).	minesDisplay := LedMorph new digits: 2;				 extent: 2 * 10 @ 15.	row		addMorph: (self wrapPanel: minesDisplay label: 'Mines:' translated).	timeDisplay := LedTimerMorph new digits: 3;				 extent: 3 * 10 @ 15.	row		addMorph: (self wrapPanel: timeDisplay label: 'Time:' translated).	^ row! !!Mines methodsFor: 'initialize' stamp: 'DAS 7/8/2001 14:25'!wrapPanel: anLedPanel label: aLabel	"wrap an LED panel in an alignmentMorph with a label to its left"	| a |	a := AlignmentMorph newRow		wrapCentering: #center; cellPositioning: #leftCenter;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 0;		layoutInset: 3;		color: color lighter.	a addMorph: anLedPanel.	a addMorph: (StringMorph contents: aLabel). 	^ a! !!Mines methodsFor: 'initialization' stamp: 'mt 5/4/2018 15:20'!defaultBorderColor	^ Color transparent! !!Mines methodsFor: 'initialization' stamp: 'mt 4/11/2018 08:49'!defaultBorderStyle	^ BorderStyle raised! !!Mines methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:38'!defaultBorderWidth	"answer the default border width for the receiver"	^ 2! !!Mines methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:28'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGray! !!Mines methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:34'!initialize	"initialize the state of the receiver"	super initialize.	""	self listDirection: #topToBottom;	  wrapCentering: #center;		 cellPositioning: #topCenter;	  vResizing: #shrinkWrap;	  hResizing: #shrinkWrap;	  layoutInset: 3;	  addMorph: self makeControls;	  addMorph: self board.	helpText := nil.	self newGame! !!Mines methodsFor: 'actions' stamp: 'DAS 7/8/2001 14:38'!help: helpState	helpState		ifTrue: [self addMorphBack: self helpText]		ifFalse: [helpText delete]! !!Mines methodsFor: 'actions' stamp: 'DAS 7/13/2001 03:49'!newGame	timeDisplay value: 0; flash: false.	timeDisplay stop.	timeDisplay reset.	minesDisplay value: 99.	self board resetBoard.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Mines class	instanceVariableNames: ''!!Mines class methodsFor: 'parts bin' stamp: 'tak 7/25/2007 00:07'!descriptionForPartsBin	^ self partName: 	'Mines' translatedNoop		categories:		{'Games' translatedNoop}		documentation:	'Find those mines' translatedNoop! !AlignmentMorph subclass: #MinesBoard	instanceVariableNames: 'protoTile rows columns flashCount tileCount target actionSelector arguments gameStart gameOver'	classVariableNames: ''	poolDictionaries: ''	category: 'Etoys-Squeakland-Morphic-Games'!!MinesBoard methodsFor: 'accessing' stamp: 'DAS 7/8/2001 15:32'!actionSelector	^ actionSelector! !!MinesBoard methodsFor: 'accessing' stamp: 'DAS 7/8/2001 15:32'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector := nil].	actionSelector := aSymbolOrString asSymbol.! !!MinesBoard methodsFor: 'accessing' stamp: 'DAS 7/13/2001 01:50'!adjustTiles	"reset tiles"	| newSubmorphs count r c |	submorphs do: "clear out all of the tiles."		[:m | m privateOwner: nil].	newSubmorphs := OrderedCollection new.	r := 0.	c := 0.	count := columns * rows.	1 to: count do:				[:m |				newSubmorphs add:					(protoTile copy						position: self position + (self protoTile extent * (c @ r));						actionSelector: #tileClickedAt:newSelection:modifier:;						arguments: (Array with: (c+1) @ (r+1));						target: self;						privateOwner: self).				c := c + 1.				c >= columns ifTrue: [c := 0. r := r + 1]].	submorphs := newSubmorphs asArray.! !!MinesBoard methodsFor: 'accessing' stamp: 'DAS 7/9/2001 13:19'!protoTile	protoTile ifNil: [protoTile := MinesTile new].	^ protoTile! !!MinesBoard methodsFor: 'accessing' stamp: 'DAS 7/8/2001 15:40'!protoTile: aTile	protoTile := aTile! !!MinesBoard methodsFor: 'accessing' stamp: 'DAS 7/8/2001 15:31'!target	^ target! !!MinesBoard methodsFor: 'accessing' stamp: 'DAS 7/8/2001 15:31'!target: anObject	target := anObject! !!MinesBoard methodsFor: 'accessing' stamp: 'DAS 7/10/2001 14:59'!tileAt: aPoint	^ submorphs at: (aPoint x + ((aPoint y - 1) * columns))! !!MinesBoard methodsFor: 'actions' stamp: 'das 7/22/2001 19:34'!blowUp	owner timeDisplay stop.	self submorphsDo:		[:m |		m isMine ifTrue:				[m switchState: true.].		].	flashCount := 2.	gameOver := true.! !!MinesBoard methodsFor: 'actions' stamp: 'das 7/22/2001 19:45'!clearMines: location	| al tile |	(self countFlags: location) = (self findMines: location) ifTrue:		[		{-1@ -1. -1@0. -1@1. 0@1. 1@1. 1@0. 1@ -1. 0@ -1} do:			[:offsetPoint |			al := location + offsetPoint.			((al x between: 1 and: columns) and: [al y between: 1 and: rows]) ifTrue: [				tile := self tileAt: al.				(tile mineFlag or: [tile switchState]) ifFalse:[		   		self stepOnTile: al].].].		].! !!MinesBoard methodsFor: 'actions' stamp: 'das 7/22/2001 19:45'!countFlags: location	| al at flags |	flags := 0.	{-1@ -1. -1@0. -1@1. 0@1. 1@1. 1@0. 1@ -1. 0@ -1} do:		[:offsetPoint |		al := location + offsetPoint.		((al x between: 1 and: columns) and: [al y between: 1 and: rows]) ifTrue:			[at := self tileAt: al.			(at mineFlag ) ifTrue:				[flags := flags+1]]].		^flags.! !!MinesBoard methodsFor: 'actions' stamp: 'DAS 7/10/2001 14:58'!findMines: location	| al at mines |	mines := 0.	{-1@ -1. -1@0. -1@1. 0@1. 1@1. 1@0. 1@ -1. 0@ -1} do:		[:offsetPoint |		al := location + offsetPoint.		((al x between: 1 and: columns) and: [al y between: 1 and: rows]) ifTrue:			[at := self tileAt: al.			(at isMine ) ifTrue:				[mines := mines+1]]].		^mines.! !!MinesBoard methodsFor: 'actions' stamp: 'das 7/22/2001 19:47'!selectTilesAdjacentTo: location	| al at mines |"	{-1@0. 0@ -1. 1@0. 0@1} do:"	{-1@ -1. -1@0. -1@1. 0@1. 1@1. 1@0. 1@ -1. 0@ -1} do:		[:offsetPoint |		al := location + offsetPoint.		((al x between: 1 and: columns) and: [al y between: 1 and: rows]) ifTrue:			[at := self tileAt: al.			(at switchState not and: [at disabled not]) ifTrue:				[				mines := (self tileAt: al) nearMines.				at mineFlag ifTrue: [at mineFlag: false.].  "just in case we flagged it as a mine."				at switchState: true.				tileCount := tileCount + 1.				mines=0 ifTrue: [self selectTilesAdjacentTo: al]]]]! !!MinesBoard methodsFor: 'actions' stamp: 'das 7/22/2001 19:46'!stepOnTile: location	| mines tile |	tile := self tileAt: location.	tile mineFlag ifFalse:[		tile isMine ifTrue: [tile color: Color gray darker darker. self blowUp. ^false.]			ifFalse:[				mines := self findMines: location.				tile switchState: true.				tileCount := tileCount + 1.				mines = 0 ifTrue: 					[self selectTilesAdjacentTo: location]].		tileCount = ((columns*rows) - self preferredMines) ifTrue:[ gameOver := true. flashCount := 2. 	owner timeDisplay stop.].		^ true.] 		ifTrue: [^ false.]! !!MinesBoard methodsFor: 'actions' stamp: 'das 7/22/2001 19:55'!tileClickedAt: location newSelection: isNewSelection modifier: mod	| tile |	"self halt."	gameOver ifTrue: [^ false].	tile := self tileAt: location.	isNewSelection ifFalse: [		mod ifTrue: [				tile mineFlag: ((tile mineFlag) not).				tile mineFlag ifTrue: [owner minesDisplay value: (owner minesDisplay value - 1)]						ifFalse: [owner minesDisplay value: (owner minesDisplay value + 1)].				^ true.].		gameStart ifFalse: [ 			self setMines: location.			gameStart := true. 			owner timeDisplay start.].		^ self stepOnTile: location.		]	ifTrue:[ self clearMines: location.].! !!MinesBoard methodsFor: 'initialization' stamp: 'mt 5/4/2018 15:19'!defaultBorderColor	^ Color transparent! !!MinesBoard methodsFor: 'initialization' stamp: 'mt 4/11/2018 08:49'!defaultBorderStyle	^ BorderStyle inset! !!MinesBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:38'!defaultBorderWidth	"answer the default border width for the receiver"	^ 2! !!MinesBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:28'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGray! !!MinesBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:06'!initialize	"initialize the state of the receiver"	super initialize.	""	target := nil.	actionSelector := #selection.	arguments := #().	""	self layoutPolicy: nil;	  hResizing: #rigid;	  vResizing: #rigid.	""	rows := self preferredRows.	columns := self preferredColumns.	flashCount := 0.	""	self extent: self protoTile extent * (columns @ rows).	self adjustTiles.	self resetBoard! !!MinesBoard methodsFor: 'initialization' stamp: 'di 11/26/2001 21:24'!resetBoard	gameStart := false.	gameOver := false.	[flashCount = 0] whileFalse: [self step].	flashCount := 0.	tileCount := 0.	Collection initialize.  "randomize the Collection class"	self purgeAllCommands.	self submorphsDo: "set tiles to original state."		[:m | m privateOwner: nil.  "Don't propagate all these changes..."		m mineFlag: false.		m disabled: false.		m switchState: false.		m isMine: false.		m privateOwner: self].	self changed  "Now note the change in bulk"! !!MinesBoard methodsFor: 'initialization' stamp: 'das 7/22/2001 19:49'!setMines: notHere	| count total c r sm |	count := 0.	total := self preferredMines.	[count < total] whileTrue:[		c := columns atRandom.		r := rows atRandom.		c@r = notHere ifFalse: [			sm := self tileAt: c@r.			sm isMine ifFalse: [				"sm color: Color red lighter lighter lighter lighter."				sm isMine: true.				count := count + 1.]]		].	1 to: columns do: [ :col |		1 to: rows do: [ :row |			(self tileAt: col @ row) nearMines: (self findMines: (col @ row))			]].			! !!MinesBoard methodsFor: 'geometry' stamp: 'DAS 7/8/2001 19:38'!extent: aPoint	"constrain the extent to be a multiple of the protoTile size during resizing"	super extent: (aPoint truncateTo: protoTile extent).! !!MinesBoard methodsFor: 'preferences' stamp: 'DAS 7/8/2001 15:41'!preferredColumns	^ 30! !!MinesBoard methodsFor: 'preferences' stamp: 'DAS 7/9/2001 01:25'!preferredMines	^ 99! !!MinesBoard methodsFor: 'preferences' stamp: 'DAS 7/8/2001 15:41'!preferredRows	^ 16! !!MinesBoard methodsFor: 'stepping and presenter' stamp: 'DAS 7/14/2001 18:16'!step	flashCount = 0 ifFalse: [		self submorphsDo:			[:m |				m color: m color negated.].			flashCount := flashCount - 1.			].! !!MinesBoard methodsFor: 'testing' stamp: 'DAS 7/14/2001 18:12'!stepTime	^ 300! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MinesBoard class	instanceVariableNames: ''!!MinesBoard class methodsFor: 'new-morph participation' stamp: 'das 7/24/2001 00:11'!includeInNewMorphMenu	^false! !SimpleSwitchMorph subclass: #MinesTile	instanceVariableNames: 'switchState disabled oldSwitchState isMine nearMines palette mineFlag'	classVariableNames: 'PreferredColor'	poolDictionaries: ''	category: 'Etoys-Squeakland-Morphic-Games'!!MinesTile methodsFor: 'accessing' stamp: 'dgd 2/14/2003 21:59'!color: aColor 	super color: aColor.	onColor := aColor.	offColor := aColor.	self changed! !!MinesTile methodsFor: 'accessing' stamp: 'DAS 7/9/2001 13:14'!disabled	^ disabled! !!MinesTile methodsFor: 'accessing' stamp: 'DAS 7/9/2001 13:14'!disabled: aBoolean	disabled := aBoolean.	disabled		ifTrue:			[self color: owner color.			self borderColor: owner color]		ifFalse:			[self setSwitchState: self switchState]! !!MinesTile methodsFor: 'accessing' stamp: 'dgd 2/22/2003 19:09'!doButtonAction: modifier 	"Perform the action of this button. The first argument of the message sent to the target is the current state of this switch, 	the second argument is the modifier button state."	(target notNil and: [actionSelector notNil]) 		ifTrue: 			[^target perform: actionSelector				withArguments: ((arguments copyWith: switchState) copyWith: modifier)]! !!MinesTile methodsFor: 'accessing' stamp: 'DAS 7/9/2001 15:47'!isMine	^ isMine! !!MinesTile methodsFor: 'accessing' stamp: 'das 7/22/2001 19:49'!isMine: aBoolean	isMine := aBoolean.! !!MinesTile methodsFor: 'accessing' stamp: 'das 7/22/2001 19:44'!mineFlag	^ mineFlag.! !!MinesTile methodsFor: 'accessing' stamp: 'das 7/22/2001 19:47'!mineFlag: boolean	mineFlag := boolean.	mineFlag ifTrue: [		self color: Color red lighter lighter lighter lighter.]		ifFalse: [		self color: self preferredColor.].	^ mineFlag.! !!MinesTile methodsFor: 'accessing' stamp: 'DAS 7/10/2001 14:27'!nearMines	^ nearMines.! !!MinesTile methodsFor: 'accessing' stamp: 'das 7/22/2001 19:48'!nearMines: nMines	nearMines := nMines.! !!MinesTile methodsFor: 'accessing' stamp: 'DAS 7/9/2001 13:15'!switchState	^ switchState! !!MinesTile methodsFor: 'accessing' stamp: 'mt 5/4/2018 10:52'!switchState: aBoolean	switchState := aBoolean.	disabled ifFalse:		[switchState			ifTrue:[				"flag ifTrue: [self setFlag]." "if this is a flagged tile, unflag it."				self borderStyle: (BorderStyle inset width: 1).				self color: onColor]			ifFalse:[				self borderStyle: (BorderStyle raised width: 3).				self color: offColor]]! !!MinesTile methodsFor: 'drawing' stamp: 'mt 5/4/2018 11:27'!drawOn: aCanvas 	"Draw a rectangle with a solid, inset, or raised border.	Note: the raised border color *and* the inset border color are generated	from the receiver's own color, instead of having the inset border color	generated from the owner's color, as in BorderedMorph."	| font rct |	super drawOn: aCanvas.		self borderStyle style == #inset ifTrue: [		self isMine ifTrue: [  			font  := StrikeFont familyName: 'Atlanta' size: 22 emphasized: 1.			rct := self bounds insetBy: ((self bounds width) - (font widthOfString: '*'))/2@0.			rct := rct top: rct top + 1.			aCanvas drawString: '*' in: (rct translateBy: 1@1) font: font color: Color black.			^ aCanvas drawString: '*' in: rct font: font color: Color red .].		self nearMines > 0 ifTrue: [ 			font := StrikeFont familyName: 'ComicBold' size: 22 emphasized: 1.			rct := self bounds insetBy: ((self bounds width) - (font widthOfString: nearMines asString))/2@0.			rct := rct top: rct top + 1.			aCanvas drawString: nearMines asString in: (rct translateBy: 1@1) font: font color: Color black.			^ aCanvas drawString: nearMines asString in: rct font: font color: ((palette at: nearMines) ) .]].! !!MinesTile methodsFor: 'initialization' stamp: 'ar 11/25/2001 14:56'!initialize	super initialize.	self label: ''.	self borderWidth: 3.	bounds := 0@0 corner: 20@20.	offColor := self preferredColor.	onColor := self preferredColor.	switchState := false.	oldSwitchState := false.	disabled := false.	isMine := false.	nearMines := 0.	self useSquareCorners.	palette := (Color wheel: 8) asOrderedCollection reverse."	flashColor := palette removeLast."! !!MinesTile methodsFor: 'initialization' stamp: 'di 11/26/2001 21:27'!preferredColor		"PreferredColor := nil  <-- to reset cache"	PreferredColor ifNil:		["This actually takes a while to compute..."		PreferredColor := Color gray lighter lighter lighter].	^ PreferredColor! !!MinesTile methodsFor: 'event handling' stamp: 'das 7/21/2001 16:08'!mouseDown: evt 	"The only real alternative mouse clicks are the yellow button or the shift key. I will treat them as the same thing, and ignore two button presses for now. I am keeping this code around, because it is the only documentation I have of MouseButtonEvent."	| mod |"	Transcript show: 'anyModifierKeyPressed - '; show: evt anyModifierKeyPressed printString ; cr;			 show: 'commandKeyPressed - '; show: evt commandKeyPressed printString ;  cr;			 show: 'controlKeyPressed - '; show:evt controlKeyPressed printString ; cr;			 show: 'shiftPressed - '; show: evt shiftPressed printString ; cr;			 show: 'buttons - '; show: evt buttons printString ; cr;			 show: 'handler - '; show: evt handler printString ;  cr;			 show: 'position - '; show: evt position printString ; cr;			 show: 'type - '; show: evt type printString ; cr;			 show: 'anyButtonPressed - '; show: evt anyButtonPressed printString ; cr;			 show: 'blueButtonPressed - '; show: evt blueButtonPressed printString ; cr;			 show: 'redButtonPressed - '; show: evt redButtonPressed printString ; cr;			 show: 'yellowButtonPressed - '; show: evt yellowButtonPressed printString ; cr; cr; cr."					mod :=  (evt yellowButtonPressed) | (evt shiftPressed). 	switchState ifFalse:[		(self doButtonAction: mod) ifTrue:			[mod ifFalse: [ self setSwitchState: true. ].].	] ifTrue: [			self doButtonAction: mod.].! !!MinesTile methodsFor: 'event handling' stamp: 'DAS 7/9/2001 13:16'!mouseMove: evt	"don't do anything, here"! !!MinesTile methodsFor: 'event handling' stamp: 'DAS 7/9/2001 13:16'!mouseUp: evt	"don't do anything, here"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MinesTile class	instanceVariableNames: ''!!MinesTile class methodsFor: 'new-morph participation' stamp: 'das 7/24/2001 00:11'!includeInNewMorphMenu	^false! !Object subclass: #PlayingCard	instanceVariableNames: 'cardNo suit suitNo cardForm'	classVariableNames: 'ASpadesLoc CachedBlank CachedDepth CardSize FaceForms FaceLoc FaceSuitLoc MidSpotLocs NumberForms NumberLoc SuitForms SuitLoc TopSpotLocs'	poolDictionaries: ''	category: 'Etoys-Squeakland-Morphic-Games'!!PlayingCard commentStamp: '<historical>' prior: 0!This class assembles card images from their parts.  The images are broken down so that the image data is very compact, and the code is written to display properly at all color depths.  The method imageData may be removed after initialization to save space, but must be re-built prior to fileOut if you wish to retain the images.To use in morphic, one can simply put these forms into ImageMorphs (see example in buildImage).  However it should be possible to define a subclass of ImageMorph that simply creates playingCard instances on the fly whenever the image form is needed.  This would avoid storing all the images.!!PlayingCard methodsFor: 'all' stamp: 'di 10/18/1999 23:38'!blankCard 	CachedDepth = Display depth ifFalse:		[CachedDepth := Display depth.		CachedBlank := Form extent: CardSize depth: CachedDepth.		CachedBlank fillWhite; border: CachedBlank boundingBox width: 1.		CachedBlank fill: (0@0 extent: 2@2) fillColor: Color transparent.  "Round the top corners"		CachedBlank fill: (1@1 extent: 1@1) fillColor: Color black.		CachedBlank fill: (CachedBlank width-2@0 extent: 2@2) fillColor: Color transparent.		CachedBlank fill: (CachedBlank width-2@1 extent: 1@1) fillColor: Color black].	^ CachedBlank! !!PlayingCard methodsFor: 'all' stamp: 'ar 5/14/2001 23:39'!buildImage     "(PlayingCard the: 12 of: #hearts) cardForm display"	"World addMorph: (ImageMorph new image: (PlayingCard the: 12 of: #hearts) cardForm)"	"PlayingCard test"	| blt numForm suitForm spot face ace sloc colorMap fillColor |		"Set up blt to copy in color for 1-bit forms"	blt := BitBlt current toForm: cardForm.	fillColor := self color.	colorMap := (((Array with: Color white with: fillColor)				collect: [:c | cardForm pixelWordFor: c])					 as: Bitmap).	blt copy: cardForm boundingBox from: 0@0 in: self blankCard.  "Start with a blank card image"	numForm := NumberForms at: cardNo.  "Put number in topLeft"	blt copyForm: numForm to: NumberLoc rule: Form over colorMap: colorMap.	suitForm := SuitForms at: suitNo*3-2.   "Put small suit just below number"	sloc := SuitLoc.	cardNo > 10 ifTrue:		[suitForm := SuitForms at: suitNo*3-1.   "Smaller for face cards"		sloc := SuitLoc - (1@0)].	blt copyForm: suitForm to: sloc rule: Form over colorMap: colorMap.	cardNo <= 10	ifTrue:		["Copy top-half spots to the number cards"		spot := SuitForms at: suitNo*3.   "Large suit spots"		(TopSpotLocs at: cardNo) do:			[:loc | blt copyForm: spot to: loc rule: Form over colorMap: colorMap]]	ifFalse:		["Copy top half of face cards"		face := FaceForms at: suitNo-1*3 + 14-cardNo.		blt colorMap: self faceColorMap;			copy: (FaceLoc extent: face extent) from: 0@0 in: face].	"Now copy top half to bottom"	self copyTopToBottomHalf.	cardNo <= 10 ifTrue:		["Copy middle spots to the number cards"		(MidSpotLocs at: cardNo) do:			[:loc | blt copyForm: spot to: loc rule: Form over colorMap: colorMap]].	(cardNo = 1 and: [suitNo = 4]) ifTrue:		["Special treatment for the ace of spades"		ace := FaceForms at: 13.		blt colorMap: self faceColorMap;			copy: (ASpadesLoc extent: ace extent) from: 0@0 in: ace]	! !!PlayingCard methodsFor: 'all' stamp: 'di 10/18/1999 23:31'!cardForm	^ cardForm! !!PlayingCard methodsFor: 'all' stamp: 'di 10/15/1999 09:12'!color	CachedDepth = 1 ifTrue: [^ Color black].	CachedDepth = 2 ifTrue: [^ Color perform: (#(black gray gray black) at: suitNo)].	^ Color perform: (#(black red red black) at: suitNo)! !!PlayingCard methodsFor: 'all' stamp: 'ar 5/28/2000 12:13'!copyTopToBottomHalf	"The bottom half is a 180-degree rotation of the top half (except for 7)"	| topHalf corners |	topHalf := 0@0 corner: cardForm width@(cardForm height+1//2).	corners := topHalf corners.	(WarpBlt current toForm: cardForm)		sourceForm: cardForm;		combinationRule: 3;		copyQuad: ((3 to: 6) collect: [:i | corners atWrap: i])		toRect: (CardSize - topHalf extent corner: CardSize).	! !!PlayingCard methodsFor: 'all' stamp: 'di 10/14/1999 20:17'!faceColorMap	| map |	map := Color colorMapIfNeededFrom: 4 to: Display depth.	^ map! !!PlayingCard methodsFor: 'all' stamp: 'di 10/18/1999 23:23'!setCardNo: c suitNo: s cardForm: f	cardNo := c.	suitNo := s.	cardForm := f.	self buildImage! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PlayingCard class	instanceVariableNames: ''!!PlayingCard class methodsFor: 'all' stamp: 'di 10/13/1999 17:26'!imageData ^ 'AgQALwAlAAAAAIDjaN4VEeFDEREREBIiIiIiIiIiIYiBiIGIgYiIiIgSIiIiEBIiIiIREiIiIhgRGBEYERiBiIEiIiIiEBIiIiERESIiIiFEREREREQRGBIiIiIiEBIiIhERERIiIiIRERERERFEQSIiIiISEBIiIhERERIiIiIRERERERERESIiIiEREBIiIhERERIiIiESIiIiISERESIiIhIUEBIiIiERESIiIhISIiIiISEhESIiIhIUEBIiERIREhESIhIRESERESEhISIiIhIUEBIhERERERERIhEREhESESEhISIiIhIUEBIREREREREREhISIhIiISEhISIiIhIUEBIREREREREREhISIhIiISEhISIiIhIUEBIREREREREREhISIhIiISEhISIiIhIUEBIhEREhIRERIhISIREiISEhISIiIhIUEBIiERIKISIREuIfIhEhISEhESIiEhQQEiIiIhESIiIhERIhESIhISEhIhIiEhQQEiIiIRERIiIiEhIiIiIhISISEhEiEhQQEiIiIiIiIiIREhISIhIRISERIRQREhQQEiIiIiIiIiEiEhISEhISESEhIUREEhQQEiIiIiIiIiEhIhISEhIRISIhFIREEhQQEiIiIiIiEREiISEhQSEiFBEUSIREEhQQEiIiIiERERERERQURBQRREQURESBEhQQEiIiERRBiBEhGBFERERERBFIREQSEhQQEiIhREREGIEREYERREREERSIRIEiEhQQEiEUJCQkIYgRIYGBEUQRGBRERBIhEhQQEhEURERERBiBERgYERERgUREgSIREhQQFBESQkJCQkGIERgYgREYgUhEQSEREhQQFBEUREREREEYQRGBGBGBFIhEEiEREhQQFBEUJCQkJCERhBGBiIiIFERIEhFBEhQQFBEUREQREUEUGBEYERQRFEREEhEREhQQEYgRQkEiIhEREYEYGIiIFISBIhFBEhQQGIiBRBIhEiEUQYEYERQRSIRBIREREhQQEYgRFBIUQSERERgRgYiBRESBIRERERQQERERERIUQSEURBgRgRQRRERBIREiEiEQEUQRERIhEiERERGBgYiBRISBIRIiIREQEREREREiIhERERERERERSIRBIRIRIiEQESISIREREUQSIiFEQRERFESBIRIiEREQBAAvACUAAAAAgONk3hURExERERAYiIiIiIQRQhISESEJIuNPIiIiEBGIiIiIhBFCESEhESIiIiIiIhESIiIiEBIYiIgRhBFCEiESESIiIiIiIRERIiIiEBIhiIgYRBFCEhIhISIiIiIiEREREiIiEBIhiIiEQRRCESIiERIiIiIiEREREiIiEBIiGIiEQRQiEiIiIRIiIiIiEREREiIiEBIiGBGEERQiERIREUEiIiIiIRERIiIiEBIiGBhEEUQhIRIhEUEiIiIREhESERIiEBIhiIRBEUIhIiEiIRQSIiEREREREREiEBIhiIRBFEISIiEiIRQSIhERERERERESEBIYEUQRRCISIiEiIRFBIhERERERERESEBGIFEERQiEiIhESIUFEEhERERERERESEBIRRBEUQiEiIiIiIUQUQSERESEhEREiEBIiERFEIhQSIhESERQRRBIREiEiERIiEBIiIRFCIhFBIiEiERFBFEEiIhESIiIiEBIiERRCIRgREiIhgREUEUQSIRERIiIiEBIhEUQhFISBgREYFIhBRBFBIiIiIiIiEBIRFEISIUhEgYGESIQSFEEUEiIRIiIiEBERQRERERSIRERIiEEREUQUEiFEESIiEBEUiIERESEUiIiIRBISGBQUEhQRRBIiEBGIGIgSISIRFBEUESIRgYFBIUREQSIiEBiIgYGBISERIURBIREYiBESIhEUEhESEBRERBiIEREhIUhBISGBgRGBIiIhIYiBEBREREGIGBEhIURBIRiIFBGBEhESGIESEBREREQRiIgRERQREYGBRBGBEYiBEREiEBgYGBREEYGIiBEYiIERhBGBGIgSEiISEBGBgYGBRBEYiIiIgRERhEEYERESIRESEBgYEREREUSBERERERgRhEERRBQRISISEBGBGIiIiBFEgREYEYEYREQUIkERERESEBgYiBERGIgUQRERgYEYREGBQkQUEiISEBGIERgYERiBSBERGBEYRBiBFERBEREiEBQRGBgYGBGIFBERgYEYRBgYgUIkFBIiEBRBGBEREYgYFIEYERgYQYgRERQkQREiEBQkEUREQREYgUGBEREYQYGIFEFERBQSEBQiQUIiRBiBgRERGIEREYERFCIUIkEREBFERBIRJBERgURBREQYgYGIFCEhQkQUEAQALwAlAAAAAIDjaN4VEeE/EREREBIiIiEUFEFEQUFEFBREFBIiIiIiIiIiEBEiIiIRQUQUQUFEFBRBQSIiIhESIiIiEBQSIiIhFBRBEUERFBEUEiIiIRERIiIiEBRBIiIiFERERERERERBEiIiEREREiIiEBREEiIiERERERERERERIiIiEREREiIiEBERESIiGBIiIiIhgYGBIiIiEREREiIiEBiIEiIiGBIiIiIhgYGBIiIiIRERIiIiEBGIEiIiGBERIREhgYGBIiIREhESERIiEBiIEiIiGBESERIRgYGBIiEREREREREiEBGIEiIiGBIiEiIhgYGBIhERERERERESEBiIEiIhGBIiEiIhgYGBIhERERERERESEBGIEiIYGBIiEiIhgYGBIhERERERERESEBiIEiIYGBIhESIhgYGBEiERESEhEREiEAoRGBIi4iMiIiGBgRiBIhESISIREiIQGIgSIYgYISERIiGBEYgRIiIiERIiIiIQERgSIYGIESIiIhGBiBERESIhEREiIiIQGIgSIYiBFBIiIUGBGBESEhIiIiIiIiIQGIgRIhEUFEERFEQYiBEhEkESIiIiIiEQEYEiEUFBFERBFEQREREYEkRBEiIiIhgQEhIiIRQUFIhBEUESIRIYEkSEIRIiIYgQERERIUFBFERBIREiESGIEkiIQhERGIgQEiESIRQUFIhBIhIhEhiIEohIghERGIgQERgSIUFBFERBEiIRIYgREkiIQhERGIgQEhgSIRQUFIhBESESQYiIEkSEQhERGIgQEYgSIUFBFERBIREkGIEREkREQhERGIgQEhgSFBQRFIhBEhIRiIiIEkSEQhERGIgQEYgREUERFERBQSFBgYEREkiIQhERGIgQGIgRERERSIQYFBQYiIiIEohIghERGIgQGIgRIREhREQRgUGBgREREkiIQRFEGIgQGIgSIhIhSIQYiBiIiIiIEkSEQUSIGIgQGIgSEiIRREQREYgYEREREhERREREGIgQGIgRISEhSIQYiIiIiIiIESIUSIREGIgQGIgSEhIRREQRhBgRGBSBIiFEREQRGIgQGIgRISEkiEGIgUEiIUESIiFIhEESGIgQGIgSEhIUREEYiBIREhIiIhRERBISGIgQGIgRISEUiEGBESFEQSEiIRSIQSEhGIgQBAAvACUAAAAAgONg3hUR4dsREREQEiIiIiIiIhiIgYiBiIiIiIiIgSIiIiIQEiIiIkIiIiGIERgRGIGIiIiIEiIREiEQEiIiJEQiIiIURERESBEYgYiBIiGBIhQQEiIiRERCIiIRERERFERIERgRIhiBIhQQEiIpRERJIiIhEREREREUREQSIhiBIhQQEiKUREREkiIhIiIiESERERESIYgSEREQEiKUREREkiIhIRIiEhIRERESIYEiQkIQEiRERERERCIhESEiEhISEhISIRIiQkIQEkREREREREImIiIiEhISEhISIYEiEhIQEiRERERERCISIiIiEhISEhISIYgSEREQEiKUREREkiEiIiIiEhISEhISIhiBIhQQEiKUREREkiEWIiIiISEhISEhIhiBIhQQEiIpRERJIiIhERISISEhISEhIiGBIhQQEiIiRERCIiIhIhESIhISEhISEiIREhQQEiIiJEQiIiIiESIiIiEhISEhISIiIhQQEiIiIkIiIiIhIiIiERIhISEhISIiIhQQEiERIiIiIiIhEiIhIiEhISEhISIiIhQQEhISERIiIhEhIiIhIRIhISEhISIiIhQQEhEhISEiISESIiIhEiISEhISEiIiIhQQERISEhISISIiIiIiCRFbIiIUEBEhISIiIRgSIiIRERERiBIiGIEiEREREBISEiIhERGBEREREREhGIEhEYgSIYgSEBIhIhERFEEYERRBERIRIYgREhiBIRiBEBIiEUEYFEERgUFEEQkR4ScRIYIQEhFEREGBEhGBRBQRiIiIiIiIiBEREREQEUREQRgYEUQRFEESEhISEhISIYEREREQFERBGIiBgUQYERIiIiIiIiIiGBRBEiEQFEEYiIERGBEYEiIRERERERIhgYFEESEQFBiIgRERGBIYEhGIiIiIiBIYEUgUQREQEYiBEREhGBEYEYgRERERgSGBiBSBRBEQGIgRESIhEYERGBERREQYEiGBGIFIFEEQGIFEERIiEYERgRFEREQYEhgREYEREREQGBQUQREiEYERgRERERGBIhgRERSBSBQQEYhBRBESERgRgUREREGBIYERGBSBSBQQEUiEFEERIRgRgRERERgSIYEUSBQREREQFEFIhBERERERGBIiIhgRERERERSIQUQQBAAvACUAAAAAgONo3hUR4bsREREQEhiIiIiIFEEiEhIRgSIiIiIiIiIiIiIQEiGIiIEYFEEhISEhiBIiIiIiIkIiIiIQEiGIiIiIFEEiIRIRGBIiIiIiJEQiIiIQEiIYiIEYFEEiEiEhEYEiIiIiRERCIiIQEiIYiIiBFBIRIiIRERgSIiIpRERJIiIQEiIYiBGBRBEiIiIhQRgSIiKUREREkiIQEiIYiIgRQSIREhERQRGBIiKUREREkiIQEiIYgRgUQSEhESERRBGBIiRERERERCIQEiIYiIEUESIiISIhRBEYEkREREREREIQEiGIEYFEEhIiISIhREEYEiRERERERCIQEiGIiBFBISEiISIhREEYEiKUREREkiIQEhiBgRRBIRIiERIhREEYEiKUREREkiIQEiGIEUQSISIiIiIhREQRgSIpRERJIiIQEiIRFEEiFBIiERIYFEQRgSIiRERCIiIQEiIhRBIiEUEiISIYEUQRgSIiJEQiIiIQEiIUQSIhiBESIiGIEhQRgSIiIkIiIiIQEiFEERESGIgRERGIEhERgSIiIiIiIiIQEhRBEhERIREYiIERIRERgSIiIhESIiIQEUQRIQohERIi4acREhGBIiIRiBEiIhAUQSESERERESIiIhESERgRIiIYEYgSEhAUGBIRESESEREREREhIRGBIiGIiIEiERAREYEhEREhIRESERESERIYEiIRGBIhgRARGBgSEREhISEhISERESGIESIiIRIYgRARgRGBIhESEREhIREREhiBERIiIhGBEhAYEUEYESERERESERESIYGBEhEiIRERIhARFBGBiBEYERERERIhGBGBIRESEiIREhARQRgUEYgRESIiIiEYgRGBIRERIhESEhAUEYERQhGIgRERERiBEUGBIREYEiEhEhARGBFBFCERGIiIiIEYEUGBEhGIESISEhARgRgUEUJBgRERERiIEUIYERiBERISEhAYERgRQSQhGBERGIEYEUIYgYgSEhEhIhASEhGBQUJCGBJBGIiIEUJBiIERERESIhARERGBQSQhGBJBGBEYEUEUGBESEhIRIhASEhIYEUJCGBJBGIiIERRBgRgREREREhAREREYFCQhGBERERERREhBgUGBEhISERASEhIRgUJCGBREREREiIQYESQYERERERAEAC8AJQAAAACA42neFRHjZxERERASIiIiIhQkRCRCRCRCRCQRIiIiIiIiIhASIiIiIiFCRCRCRCRCQkESIiIiQiIiIhASIiIiIiIUIiRCIiRCJBEiIiIkRCIiIhARIiIiIiIhRERERERERBIiIiJEREIiIhAREiIiIiIhERERERERERIiIilEREkiIhARgSIiIiIhERGBIiIiIhEiIpRERESSIhARgSIiIiIhEYGBIiIiIhEiIpRERESSIhARgSIiIiIhgYGBIREhERgSJEREREREIhARgSIiEiIhgYGBEhESERgSREREREREQhARgSIhEiIhgYGBIiISIhgSJEREREREIhARgSEYEiIhgYGBIiISIhgSIpRERESSIhARERiBIiIhgYGBIiISIhgSIpRERESSIhAUiIERIiIhgYGBIiERIhgSIilEREkiIhARgRESIiIhgYGBIiIiIhgREiJEREIiIhAUgRIiIiEYgYGBIiERISgYgSIkRCIiIhARgSIiIhiBgYGBEiIiIRiBgSIiQiIiIhAUgSIiIhgRgRgUISIiEkGIgSIiIiIiIRARgSIiIhiIGIFERBERREQRERIiIiIiFBAUgSIiIhERERFEREREREESGBESIiIhgRARgSIiEUERIRERREREQRERGBIREiIhhBAUgSIRGBQRESEREREREREhGBEYgRIhgRARgREREYFBEREhERERESERGBIYgUERhBAUgRERERgUERERISEhIRFBGBERgURBgRARgRFBERGBQREREREREUFBGIEhiBFBhBARESEUEREYFBFBQUFBQUFBIYERGIgRgRASISGBQRERgUEUhISEhISBIYgSERiBhBARESEYFBERGBQRQUFBQUFBIRiBEhERgRASIRGBgUEREYFBEUFBQUFBIRGIgREhhBAREUQYERgRERgUEUFBQUFBIRIRiIERgRASESQYGIFBERGBQRSEhISBIRISEYiBhBARgURBgRFIEREYFBFBQUFBIRIRgRERgRARgSJBgYFIQRERgUERQUFBIRIREYFBhBAUgURBgRFISBEhGBQRQUFBIRIYgYEhgRARgSJBgYFIQRERFIFBFISBERIRGBRBhBAUgURBgRFIESERhEgUEUFBERGIGBQhgRARgSJBgYFBEREUGESBQRQRIRERgURBhBAEAC8AJQAAAACA42neFRHjZxERERASIiIiIiIiIhgYiBiIGIgYiIiBIiIiIhASIkRJIilEQiERgRGBEYERgRgSIiIiIhASJEREkpRERCIYiIiIiIiBiBEiESIiIhASREREQkREREIhREREREiIiBIhiBIiIhASREREREREREIhERERERRERBIhiBESIhASREREREREREIhIiIiIhERERERgSIRIhASREREREREREIhIiIiIhISEhIhgSIYEhASlERERERERJIRERIRERISEhEYgREYEhASKURERERESSEhESERIRISEhEYgRIhIhASKURERERESSEhIiEiIhISEhIYgSIhIhASIpREREREQiEhIiEiIhISEhIhERERIhASIiREREREIiEhIiEiIhISEiEiFERBIhASIiJERERCIhISIhESIiEhISEhEREREhASIiIkREQiIhISIiIiIiEiEhIRQUFBQRASIiIiREIiIiESEhESIiISEhIUREREERASIiIiJCIhEREiEiIiISEhISIRRERBIhASIiIiIiERQRIhISIhISEhIiEiERQSRBASIiIiERERFBESISEhIREiIRISIhEUQRASIiIRFBIhFEEhEiEhIhIREiIiEUERERASIhEiFBIiEUQRIhEhEhiBIhIhQUGBERASERISFBISIRRBEYESEYiBISIUgUERgRARiEEhIUEhIhRBGBgRiIgSIiFIFBERGBAYREESIUEiIhFEEYEYiIgRIiGEFBgRERAUQRERIhQSEiFEQRGIiIgSIhhBQRSIERAUEREUEhRBISEUQRiIiIEiEhQUQREYgRARgRFEQSFEEiIURBiIiBEhIhFEERFEiBAYRIERRBIURBIRQYiIgUEiIRRBERRESBAUSIhBEREhFEESEYiIgRIhFEEREUSEGBAUiIFIgRESIREREREREREUQRERFEREiBAYiBQRGBEREiIiRERERERBERERRIQYgRAYiBSIiBgSIiQRERERERESEREURESIgRAYiBQRGBgSIiIiIhREQSIiERFEhBiIERAYiBSIiBgSIiIiERJEQSEhERSERIiBERARiIFIgRERERERIRERQRIREREUGIgRFBARGIiBERERESIhGIiIESIREUQYiIERQRAUEYEREYiIgSIhGBQYEiEhiIiIiBERRBAEAC8AJQAAAACA42neFRHjZxERERASIiIiIiIRISEiERSIiIEiIiIiIiIiIhASIiIiIiESEhISERSBiBIiREkiKURCIhASIiIiIhERIRIiERSIiBIkRESSlEREIhASIiIiIhgSEiEiIRSBgSJERERCREREQhASIiIiIRgRIiIRIRRIgSJEREREREREQhASIiIiIYQSIiIiERFIgSJEREREREREQhASIiIiEYQRESERIRFEiBJEREREREREQhASIiIiGEQREhESEREUSBKUREREREREkhASIiIhGEQSIhIiISERQSIpRERERERJIhASIiIhhEgSIhIiISEREiIpRERERERJIhASIiIhhEgSIhIiISIRESIiRERERESSIhASIiIhhEgSIREiIhIRERIiJEREREQiIhASIiIYRIgSIiIiIhIhEREiIkREREIiIhASIiIYRIERIREiIYEiERESIiRERCIiIhASIiIYRBGBIhIiGIEiIREREiJEQiIiIhASIiIYQYEYEiIhiBESIhERERIkIiIiIhASIiIYEoERgREYgRGBIiERERIiIiIiIhASIiIRghgRGIiBERgSEiIRESIiESESIhASIiEYGEKBEREREYQoERIiEiIhiBiBIhASIhiIgYIYgREYiBKBEREREiIhhEQSIhASIRGBGBhCGIiBJIgRESIiISIiGEiBIhASGIiIiIGIhCFIiBEhEiEhIRIREYgSEhARERgRGIERGIiBERgRISIiFEGIgRGBEhAYiIiIiBEiEREYERgRIiIRRBiIEiEYEhAREYERGBISERERgYESEhFEERERIiGIEhAYiIiIgRIRESIRgYESIURBiIEhERGBIhARgYERgREhEiEhGBEhIUQYREEhQSESIhAYiIiIgSEhQRIhGBEiFEGESEESESESIhARGBgRgREhhEEiGBISFEGERBESEhIhIhAYiIiIgRIRiEQSERIhRBhEhBEhEhIhIhARgREYESEYGIQRERIhRBhERBIREiERIhAYiIiIESEYEYQRiBERRBhIRBISEiIUEhARgRiBESEYQYhBEYiBFBhEERIREhFEQRAYiIgUERIYQYRBgREYgRERRBEhEURERBAREYFEEhIYEYhBgYiBGIFESBISFEREQRAYiBREESEYGIQYGERIERRIiBESFERBGBAEAC8AJQAAAACA42jeFRHiZxERERASIiIiIhRCREJCRCQkRCQSIiIiIiIiIhARIhESIiFEJEJCRCQkQkEiREkiKURCIhAUEiGBIiIUQiJCIiQiJBEkRESSlEREIhAUEiGIEiIUREREREREQRJERERCREREQhAUEiGIEiIRERERERERERJEREREREREQhARERIYgSIhgYGBgSIiISJEREREREREQhASQkIhgSIhgYGBgSIRISJEREREREREQhASQkIiESIYGBgYEhEhISKUREREREREkhASEhIhgSIYGBgYEiIiJiIpRERERERJIhARERIYgSIYGBgYEiIiIhIpRERERERJIhAUEiGIEiIYGBgYEiIiIiEiRERERESSIhAUEiGIEiIYGBgYEiIRJhEiJEREREQiIhAUEiGBIiIYGBgYEhESISIiIkREREIiIhAUEhESIhEYGBgYEiIiISIiIiRERCIiIhAUEiIiIYiBGBgYEiIhESIiIiJEQiISIhAUEiIiGIGBgYEYEiIiISIiIiIkIhFBEhAUEiIiGBiBgYGBREIiIREREiIiIhREEhAUEiIiGIEYgYEUREQRGIGIgSIiIiFBIhAUEiIiIYiIGBFEREREQYgRgSIiERFBIhAUEiIiIREREYgRREREQRiIgSIhIiFBIhAUEiIhFCQYiIiIERERiIGIESISIiIREhAUEiERERQhGIiIiIiIiIgRJBESIRISEhAUERIkQREUIRGIiIiIgREkRBERIhEREhAUFEIiJEERFCQRERERFCREERFEEiEiEhARERRCIiRBERQkJCQkJEQREUQiIREREhAYiBEUQiIkQQoRFBER4PtEIiJBESEiEBiBiIEUQiIkQRFBIiFBEUQiIkQRIhEiEBgYiBiBFEIiJEEUEhQRRCIiRBGBISESEBERgYhBERRCIiQRQUEUIiJEEYiBIiIREBIiGIQRiIEUQiJBFBFCIiQRiIiBISEREBEiIUEYiIiBRCIkERQiJEGIiIiBIiIREBIhIRGBEREREUIiQUIiQRERERGBISEREBEiIhiBIiIiIUQiERIkQSIiIiGBIiIREBESEhiBIRERIRRBIiFEESERESGBISEREBESIiGBIYgRESESERIRIREYgSGBIiIREBERISGBIYgRIhEhREEhEiEYgSGBISEREAQALwAlAAAAAIDjad4VEeNnEREREBIiIiIiIiIiGIiIiIiIiIiIiIEiIiIiEBIiIiIhIiIiIYiIiIGBgYGBgRIiIiIiEBIiIiIREiIiIhGBgYFBQUFBQSIiIiIiEBIiIiERESIiIkFBQUREREREEiIiIiIhEBIiIhERERIiIiFEREEREREREiIiIiIREBIiIREREREiIiEREREiIiIiESIiIiGBEBIiERERERESIiEhISEiIiIiEhIiIiGBEBIhERERERERIiEhISERESEREhIiIiGBEBIhERERERERIiEhISESERIRESIiIiGBEBIREREREREREiEhISEiIhIiEhIiIiGBEBIREREREREREiEhISEiIhIiEhIiIiGBEBIREREREREREiEhISEiIhIiEhIiIiGBEBIREREhIREREiEhISEiIREiEhIiIiGBEBIhERIhIhERIiEhISEhEiISEhIiIiGBEBIiIiIREiIiIREhISEhIREiESESIiGBEBIiIiERESIiEiEhISEiIiIiEhIhIiGBEBIiIiIiIiIhISEhISEiEiISEhIhIiGBEBIiIiIiIiERIRIhISESEhISEiEYESGBEBIiIiIiIRGBEiISISEiEhESIRGBEhGBEBIiIiIhGBSBEREhEhIhISGBQRgRIUGBEBIiIiERGBEYEYERERESEhGBEYESERGBEBIiIRgYEYEYFBGBgYERERgUGBEhREGBEBIhFEEREYFBgUQRERGBgRgRGBEhQRGBEBIUiBGBEYERgURIiIEREYFBgRIUREGBEBGEQRERgRgRgURIERiEQYERgRIUERGBEBSIQRgYGBgUGBRIiIiEQYEYESFEREGBEBRIEREYERgRGBERERERGBQYESFBEREREBhEEYGBiIGBGBEiISIhGBEYESFBiIgREBiEERGBgRGBGBIhIiEiGBGBEhQYERiIEBSIEYGBiIGBQYEhISEiGBGBEhQYgSGIEBRIERGBgRGBEYEiISIhgUGBERRBERIREBhEEYGBiIgYEYEhIiEhgRGBgRFEREEREBSEERGBgREYEYERERERgRgRERERERIiEBRIEYEYGIgYEYGIiIiIgRgRERERIiEREBEUEREYGBEYEYERERERgRgYgRGBEhIiEBIhIRgRgYgYFIERREERgRgRGIEREiEREAQALwAlAAAAAIDjWd4VEeMnEREREBIiIiIiIRIRISEkGBGIiBIiIiIiIiIiEBIhIiIiERESEhEkGIGIgSIiIiEiIiIiEBIhIiIiESEhEiEkGIiIgSIiIhESIiIiEBIhIiIiERISISIUGBGIEiIiIRERIiIiEBIYEiIiEhEiIhIUGIGIEiIiEREREiIiEBIYEiIhEhIiIiEUQYiIgSIhERERESIiEBIYEiIhQhERIREUQYEYgSIRERERERIiEBIYEiIhQhESERIURBgYEiEREREREREiEBGIgSIhQhIiEiISRBiBIiEREREREREiEBGBgSIhQhIiEiIhREGBIhERERERERESEBGIgSIUQhIiEiIhJEQRIhERERERERESEBIYEiIUIRIhESIiFEQRIhERERERERESEBIYEiIUIRIiIiIiEkRBIhERESEhERESEBERESISEREhESIhQSREEiEREiEiEREiEBGIgSFCEREiEiIUESREESIiIhESIiIiEBIREiFCERgSIiERgRJEQRIiIRERIiIiEBGIgSFCGBGBERgYGIEkRBEiIiIiIiIiEBGIgSERGIEYGBgRiBESIiESIiIiRCIiEBIREiERGIiBERGIgRERERQRIiJEEUQiEBIUEhESEYGIiIgYERIhFERBgiRBiBRCEBIYEYESEYgYGBiBEiERREIYESJEEUQhEBIYFIgRERiIiIgRIRFERCGBGBEiRCIUEBEYFEgRIRgYGIESERREIhgRGIgSEiGEEBEYFEgRERGIiBEhFERCIYFBEYiBEhEYEBEYFEiBEhGIgRIRREQkQYEREREYEREYEBEYEkSBESERgSEURCJEQYFEQRERIiIYEBEYEUSIERGIEhFEQkRBEYERERESIiIYEBEYEhRIERhEgRREJEEREYgUREEiIiIYEBEYESRIgRhEgURCQREiERgRERIhIhGEEBEYEhFEiBhEgUQkERIiIRGBRBIREREUEBEYESFESIGIFEIRFCIRIhEYEREYEREREBEYEhIURIgRFCERIhEREiERgUGIGBEYEBEYESEhRERERBESIiIiIiIRGBiIGIiBEBEYEhISERERCRETERERiIiBGBARGBEhIURERAlED0REQRERGIEQERgSEg4REhESCxESERiIgREQBAAvACUAAAAAgONM3hUR4dcREREQEiIRIiFBREFBRBQURBRBIiIiIiIiIiIQEiGIEiIUFEFBRBQUQUQSIiIiISIiIiIQEhgUgSIhQRFBERQRFEEiIiIiERIiIiIQEhgUgSIiFEREREREREEiIiIhEREiIiIQEhgUgSIiEREREREREREiIiIRERESIiIQEiGIEiIiEiIiGBgYGBIiIiERERERIiIQEiIRIiIiEhEiGBgYGBIiIhEREREREiIQEiGIEiIiEhIRIYGBgYEiIRERERERESIQEhgUgSIiYiIiIYGBgYEiIRERERERESIQEiGIEiIhIiIiIYGBgYEiERERERERERIQEiIRIiISIiIiIYGBgYEiERERERERERIQEiGIEiIRIhEmIYGBgYEiERERERERERIQEhgUgSIiEiEWIYGBgYEiERERISERERIQEhgUgSIiEiIiIYGBgYgRIRESISIRESIQEhgUgSIiERIiGIGBgYiIEiIiERIiIiIQEiGIEiIiEiIiGIGIGBgYgSIhEREiIiIQEhEREiIhEiIiQRgYGBiBgSIiIiIiIiIQEhIiESERFiJERBgRgYEYgSIiIiIiIiIQEiESIRERERRERBGIGBiIESIiIiIiIiIQEhIhERIREREJEeDrESIiIiIiIhASEhESEhEREREREREREREhIREiIiIiIhASERIRESGBgYGBgYGBgYEhESERIiIiIhARQREhISEREREREREREREhISEUESIiIhAUEUEhERIUREREREREREEhESFEQREiERARFBESEhIRSESESESESEEhISFBEUQRgRARQRgSEREhREgYSEgYREEhESERRBGIgRAUEYGBISEhFIGEiISBhEEhISFEEYgRERARGBgRIRERgUhEgYRIREEhESERGIiIERARgYGBEhGBERESERIREhEhISERiBERGBAYGBgRERgRgQkhKxERGIiIgRgQEYGBFBGBGIESERIREhERISERiBgREYEQGIgRJBgREYEJERMRGIiIiBGBEBgRFEGBGIiBCSITIhiBgREYFBARESQYEYERgQlEE0GIiIiBGEQQERRBgRiIiBEJESMRgYEREYFEEBGEGBERgRgRGBEhIiESESEYiIiIGEREEAQAJwAnAAAAAIDi8MMJIg8iISIiIiIiIiIiIiAJIg8iERIiIiIiIiIiIiAJIg8hEREiIiIiIiIiIiAJIuJ7EREREiIiIiIiIiIgIiIiIiIiIiEREhERIiIiIiIiIiAiIiIiIiIiEREhIRESIiIiIiIiICIiIiIiIiEREhESEREiIiIiIiIgIiIiIiIiEREhEREhERIiIiIiIiAiIiIiIiEREhERERIRESIiIiIiICIiIiIiEREhERIRESEREiIiIiIgIiIiIiEREhERISEREhERIiIiIiAiIiIiEREhERIREhERIRESIiIiICIiIiEREhERIRIRIRESEREiIiIgIiIiEREhERIRISESEREhERIiIiAiIiEREhERIRIREhEhERIRESIiICIiEREhERIREhESERIRESEREiIgIiEREhERIRERISERESEREhERIiAiEREhERESERESERESERERIRESICIREhEREREhESEhESERERESERIgIRESERIRERISERISERESERIRESAhESERESESESESESESESERESERICERIRERIRESEhESEhERIRERIREgERIRESIRESERISERIRESIRESERAREhESERESERESERESERESERIREBESERIRESEREREREREhERIREhEQERIREhESERESERIRERIREhESERAREhERIiERESEhISERESIhERIREBESERERERESERIREhEREREREhEQERIRERERESERERERIRERERESERARESERERESERERERESERERESERECERIhEREiEREhESEREiERESIREgIRERIiIhEREiERIhEREiIiERESAiEREREREREiIREiIRERERERESICIhEREREREiIRERIiERERERESIgIiIhERERIiIhEREiIiEREREiIiAJIg8RERESIiIiIiIiIiAJIjcRERESIiIiIiIiIiAiIiIiIiIiIREREREiIiIiIiIiICIiIiIiIiIRERERERIiIiIiIiIgAQALAAsAAAAAgB8LBw4AAAAOHwAAAAduwAAADv/gAAAHdcAAAAoOAAAAAQAJAAoAAAAAgB8KBxwAAAAKPgAAAAddAAAADv+AAAAHawAAAAocAAAAAQAPAA8AAAAAgDIPCwOAAAAHwAAADg/gAAAPB8AAADu4AAB//AAADv/+AAATfXwAADk4AAADgAAAB8AAAAEACwALAAAAAIAiCw8IAAAAHAAAAD4AAAAOfwAAAA8+AAAAHAAAAAgAAAAJAAEACQAKAAAAAIAkCg8IAAAAHAAAAD4AAAAOfwAAABM+AAAAHAAAAAgAAAAAAAAAAQAPAA8AAAAAgDoPEwEAAAADgAAAB8AAAA/gAAAKH/AAAA8/+AAAf/wAAD/4AAAKH/AAABMP4AAAB8AAAAOAAAABAAAAAQALAAsAAAAAgCYLBQALdwAAAPeAAAAO/4AAABd/AAAAPgAAABwAAAAIAAAAAAAAAAEACQAKAAAAAIAkCgt3AAAA94AAAA7/gAAAF38AAAA+AAAAHAAAAAgAAAAAAAAAAQAPAA8AAAAAgDEPDzx4AAB+/AAA/v4AABL//gAACn/8AAAbP/gAAB/wAAAP4AAAB8AAAAOAAAABAAAAAQALAAsAAAAAgCMLBQATCAAAABwAAAA+AAAAfwAAAA7/gAAAB2sAAAAKHAAAAAEACQAKAAAAAIAhChMIAAAAHAAAAD4AAAB/AAAADv+AAAAHawAAAAocAAAAAQAPAA8AAAAAgDUPGwEAAAADgAAAB8AAAA/gAAAf8AAAP/gAAAp//AAADv/+AAAT/X4AAHk8AAADgAAAB8AAAAEADAAMAAAAAIAmDAoCAAAACgcAAAAKDYAAABMYwAAAH8AAAD/gAAAwYAAACnjwAAABAAoADAAAAACALwwrHwAAAD+AAAAxgAAAAYAAAAOAAAAHAAAADgAAABwAAAA5gAAAMYAAAAo/gAAAAQAKAAwAAAAAgC0MCj+AAAAXMwAAAAYAAAAMAAAAHwAAAB+AAAAKAYAAAA8xgAAAP4AAAB8AAAABAAoADAAAAACAKQwbAwAAAAcAAAAPAAAAHwAAADsAAABzAAAACn/AAAAKAwAAAAoHgAAAAQAKAAwAAAAAgCcMCn8AAAAKYAAAAAt+AAAAfwAAAAoDAAAACmMAAAALfwAAAD4AAAABAAoADAAAAACAKAwbDwAAAB8AAAA4AAAAMAAAAD8AAAA/gAAAEjGAAAALP4AAAB8AAAABAAoADAAAAACAGgwKP4AAAAcxgAAACgMAAAAOBgAAABIMAAAAAQAKAAwAAAAAgCYMCx8AAAA/gAAADjGAAAALHwAAAD+AAAAOMYAAAAs/gAAAHwAAAAEACgAMAAAAAIAoDAsfAAAAP4AAABIxgAAAGz+AAAAfgAAAAYAAAAOAAAAfAAAAHgAAAAEACgAMAAAAAIAYDAtngAAAb8AAACJswAAAC2/AAABngAAAAQAKAAwAAAAAgBkMCg8AAAAaBgAAAApmAAAAC34AAAA8AAAAAQAKAA4AAAAAgCAOCz4AAAB/AAAAImMAAAATfwAAAD4AAAAHAAAAAwAAAAEACgAMAAAAAIAsDAr3gAAAI2YAAABsAAAAeAAAAHAAAAB4AAAAbAAAAGYAAABjAAAACveAAAA='! !!PlayingCard class methodsFor: 'all' stamp: 'di 1/16/2000 10:38'!includeInNewMorphMenu	^false! !!PlayingCard class methodsFor: 'all' stamp: 'di 10/18/1999 23:36'!test    "Display all cards in the deck"	"MessageTally spyOn: [20 timesRepeat: [PlayingCard test]]"	1 to: 13 do: [:i | 1 to: 4 do: [:j |		(PlayingCard the: i of: (#(clubs diamonds hearts spades) at: j)) cardForm				displayAt: (i-1*CardSize x)@(j-1*CardSize y)]]! !!PlayingCard class methodsFor: 'all' stamp: 'di 10/18/1999 23:22'!the: cardNo of: suitOrNumber	^ self new setCardNo: cardNo		suitNo: (suitOrNumber isNumber				ifTrue: [suitOrNumber]				ifFalse: [#(clubs diamonds hearts spades) indexOf: suitOrNumber])		cardForm: (Form extent: CardSize depth: Display depth)! !!PlayingCard class methodsFor: 'class initialization' stamp: 'asm 11/25/2003 22:35'!initialize	"PlayingCard initialize"	"Read the stored forms from mime-encoded data in imageData."	| forms f |	f := Base64MimeConverter				mimeDecodeToBytes: (ReadStream on: self imageData).	forms := OrderedCollection new.	f next = 2		ifFalse: [self error: 'corrupted imageData' translated].	[f atEnd]		whileFalse: [forms				add: (Form new readFrom: f)].	"1/2 image of Kc, Qc, Jc, ... d, h, s, and center image of As"	FaceForms := forms copyFrom: 1 to: 13.	"Images of small club, smaller club (for face cards), large club (for 	2-10, A), 	followed by 3 more each for diamonds, heardt, spaces, all as 1-bit 	forms. "	SuitForms := forms copyFrom: 14 to: 25.	"Images of A, 2, 3 ... J, Q, K as 1-bit forms"	NumberForms := forms copyFrom: 26 to: 38.	CardSize := 71 @ 96.	FaceLoc := 12 @ 11.	NumberLoc := 2 @ 4.	SuitLoc := 3 @ 18.	FaceSuitLoc := 2 @ 18.	TopSpotLocs := {{}. {28 @ 10}. {28 @ 10}. {15 @ 10. 41 @ 10}. {15 @ 10. 41 @ 10}. {14 @ 10. 42 @ 10}. {14 @ 10. 42 @ 10}. {14 @ 10. 28 @ 26. 42 @ 10}. {14 @ 10. 14 @ 30. 42 @ 10. 42 @ 30}. {14 @ 10. 14 @ 30. 42 @ 10. 42 @ 30. 28 @ 21}}.	"A"	"2"	"3"	"4"	"5"	"6"	"7"	"8"	"9"	"10"	MidSpotLocs := {{28 @ 40}. {}. {28 @ 40}. {}. {28 @ 40}. {14 @ 40. 42 @ 40}. {14 @ 40. 42 @ 40. 28 @ 26}. {14 @ 40. 42 @ 40}. {28 @ 40}. {}}.	"A"	"2"	"3"	"4"	"5"	"6"	"7"	"8"	"9"	"10"	ASpadesLoc := 16 @ 27! !AlignmentMorph subclass: #PlayingCardDeck	instanceVariableNames: 'layout stackingPolicy stackingOrder emptyDropPolicy target acceptCardSelector cardDroppedSelector cardDoubleClickSelector cardDraggedSelector seed'	classVariableNames: ''	poolDictionaries: ''	category: 'Etoys-Squeakland-Morphic-Games'!!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'th 12/10/1999 16:07'!acceptCard: aCard default: aBoolean 	"if target and acceptCardSelector are both not nil, send to target, if not  	nil answer  	else answer aBoolean"	"Rewrote this a little (SmallLint calls this 'intention revealing')-th"	^ (target isNil or: [acceptCardSelector isNil])		ifTrue: [aBoolean]		ifFalse: [(target				perform: acceptCardSelector				with: aCard				with: self)				ifNil: [aBoolean]]! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/16/1999 13:14'!emptyDropNotOk: aPlayingCard	^(self emptyDropOk: aPlayingCard) not! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/16/1999 13:15'!emptyDropOk: aPlayingCard	emptyDropPolicy = #any 			ifTrue: [^true].	emptyDropPolicy = #inOrder			ifTrue: [^self inStackingOrder: aPlayingCard].	emptyDropPolicy = #anyClub 		ifTrue: [^aPlayingCard suit = #club].	emptyDropPolicy = #anyDiamond		ifTrue: [^aPlayingCard suit = #diamond].	emptyDropPolicy = #anyHeart		ifTrue: [^aPlayingCard suit = #heart].	emptyDropPolicy = #anySpade		ifTrue: [^aPlayingCard suit = #spade].! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/16/1999 13:10'!ifEmpty: aBlock	self hasSubmorphs not ifTrue: [^aBlock value]! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/24/1999 02:17'!ifEmpty: aBlock1 ifNotEmpty: aBlock2	self hasSubmorphs not 		ifTrue: [^aBlock1 value]		ifFalse: [^aBlock2 value]! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/16/1999 21:54'!inStackingOrder: aPlayingCard	^self inStackingOrder: aPlayingCard event: nil! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'di 10/19/1999 15:45'!inStackingOrder: aCard event: evt	self hasSubmorphs 		ifTrue: [^ self inStackingOrder: aCard onTopOf: self topCard]		ifFalse: [stackingOrder = #ascending ifTrue: [^ aCard cardNumber = 1].				stackingOrder = #descending ifTrue: [^ aCard cardNumber = 13]].	^ false.! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'di 10/21/1999 22:03'!inStackingOrder: aCard onTopOf: cardBelow	| diff |	(stackingPolicy = #altStraight and: [aCard suitColor = cardBelow suitColor]) ifTrue: [^ false].	(stackingPolicy = #straight and: [aCard suit ~= cardBelow suit]) ifTrue: [^ false].	diff := aCard cardNumber - cardBelow cardNumber.	stackingOrder = #ascending 	ifTrue: [^ diff = 1].	stackingOrder = #descending	ifTrue: [^ diff = -1].	^ false.! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/15/1999 12:43'!insertionIndexFor: aMorph	"Return the index at which the given morph should be inserted into the submorphs of the receiver."	^1! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'th 12/10/1999 18:34'!repelCard: aCard 	stackingPolicy = #none ifTrue: [^ self repelCard: aCard default: true].	stackingPolicy = #single ifTrue: [^ self ifEmpty: [self repelCard: aCard default: false]			ifNotEmpty: [true]].	(stackingPolicy = #altStraight or: [stackingPolicy = #straight])		ifTrue: [self ifEmpty: [^ self repelCard: aCard default: (self emptyDropNotOk: aCard)]				ifNotEmpty: [(self inStackingOrder: aCard onTopOf: self topCard)						ifFalse: [^ self repelCard: aCard default: true]]].	^ false! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/24/1999 04:09'!repelCard: aCard default: aBoolean		^(self acceptCard: aCard default: aBoolean not) not! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/24/1999 02:20'!repelsMorph: aMorph event: evt	(aMorph isKindOf: PlayingCardMorph) 		ifTrue: [^self repelCard: aMorph]		ifFalse: [^true]! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'dgd 2/22/2003 18:49'!rootForGrabOf: aCard 	self hasSubmorphs ifFalse: [^nil].	(target notNil and: [cardDraggedSelector notNil]) 		ifTrue: 			[^target 				perform: cardDraggedSelector				with: aCard				with: self]		ifFalse: [^self firstSubmorph]! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 01:40'!acceptCardSelector: aSymbolOrString	acceptCardSelector := self nilOrSymbol: aSymbolOrString.! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/15/1999 11:07'!addCard: aPlayingCard	self addMorph: aPlayingCard! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 03:13'!cardDoubleClickSelector: aSymbolOrString	cardDoubleClickSelector := self nilOrSymbol: aSymbolOrString.! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 01:39'!cardDraggedSelector: aSymbolOrString	cardDraggedSelector := self nilOrSymbol: aSymbolOrString.! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 17:27'!cardDroppedSelector: aSymbolOrString	cardDroppedSelector := self nilOrSymbol: aSymbolOrString.! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/15/1999 10:46'!cards	^submorphs! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 13:18'!emptyDropPolicy: aSymbol	"#any #inOrder #anyClub #anyDiamond #anyHeart #anySpade"	emptyDropPolicy := aSymbol! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 19:41'!hasCards	^self hasSubmorphs! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'ar 11/20/2000 18:43'!layout: aSymbol	" #grid #pile #stagger"	layout := aSymbol.	layout == #grid 		ifTrue:[self maxCellSize: SmallInteger maxVal].	layout == #pile 		ifTrue:[self maxCellSize: 0].	layout == #stagger 		ifTrue:[self maxCellSize: self staggerOffset].! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/23/1999 22:44'!newSeed	seed := (1 to: 32000) atRandom! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 20:05'!removeAllCards	self removeAllMorphs! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/23/1999 22:22'!seed		^seed! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/23/1999 22:21'!seed: anInteger		seed := anInteger! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/15/1999 16:39'!stackingOrder: aSymbol	"#ascending #descending"	stackingOrder := aSymbol! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 00:08'!stackingPolicy	^ stackingPolicy! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 00:08'!stackingPolicy: aSymbol	"#straight #altStraight #single #none"	stackingPolicy := aSymbol! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 20:20'!subDeckStartingAt: aCard	| i subDeck |	i := submorphs indexOf: aCard ifAbsent: [^ aCard].	i = 1 ifTrue: [^aCard].	subDeck := PlayingCardDeck new.	(submorphs copyFrom: 1 to: i-1) do:			[:m | m class = aCard class ifTrue: [subDeck addMorphBack: m]].	^subDeck.	! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 17:21'!target: anObject	target := anObject! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 19:24'!topCard	^self firstSubmorph! !!PlayingCardDeck methodsFor: 'layout' stamp: 'asm 11/25/2003 22:37'!acceptDroppingMorph: aMorph event: evt 	target		rememberUndoableAction: [target inAutoMove				ifFalse: [target removeProperty: #stateBeforeGrab].			self addMorph: aMorph.			aMorph hasSubmorphs				ifTrue: ["Just dropped a sub-deck of cards"					aMorph submorphs						reverseDo: [:m | self addMorphFront: m]].			(target notNil					and: [cardDroppedSelector notNil])				ifTrue: [target perform: cardDroppedSelector]]		named: 'move card' translated! !!PlayingCardDeck methodsFor: 'layout' stamp: 'djp 10/15/1999 11:25'!staggerOffset	^18! !!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'dgd 2/22/2003 13:37'!deal	| card |	^ self cards notEmpty 		ifTrue: 			[card := self topCard.			card delete.			card]		ifFalse: [nil]! !!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'djp 10/10/1999 18:48'!deal: anInteger	^(1 to: anInteger) collect: [:i | self deal]! !!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'ar 11/12/2000 22:40'!reverse	self invalidRect: self fullBounds.	submorphs := submorphs reversed.	self layoutChanged.! !!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'ar 11/12/2000 22:40'!shuffle	self invalidRect: self fullBounds.	submorphs := submorphs shuffledBy: (Random new seed: seed).	self layoutChanged.! !!PlayingCardDeck methodsFor: 'events' stamp: 'dgd 2/22/2003 18:49'!doubleClickOnCard: aCard 	(target notNil and: [cardDoubleClickSelector notNil]) 		ifTrue: 			[^target 				perform: cardDoubleClickSelector				with: self				with: aCard]! !!PlayingCardDeck methodsFor: 'initialization' stamp: 'mt 4/11/2018 08:15'!initialize	super initialize.	self cellPositioning: #topLeft.	self reverseTableCells: true.	self layout: #grid.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	self borderWidth: 0.	self layoutInset: 0.	stackingPolicy := #stagger.	stackingOrder := #ascending.	emptyDropPolicy := #any.	self newSeed.	^self! !!PlayingCardDeck methodsFor: 'initialization' stamp: 'djp 10/17/1999 18:25'!newDeck	| cards |	cards := OrderedCollection new: 52.	PlayingCardMorph suits 		do: [:suit | 1 to: 13			do: [:cardNo | cards add: (PlayingCardMorph the: cardNo of: suit)]].	self addAllMorphs: cards.	^self! !!PlayingCardDeck methodsFor: 'initialization' stamp: 'djp 10/17/1999 18:25'!newSuit: suit	| cards |	cards := OrderedCollection new: 13.	1 to: 13 do: [:cardNo | cards add: (PlayingCardMorph the: cardNo of: suit)].	self addAllMorphs: cards.	^self! !!PlayingCardDeck methodsFor: 'private' stamp: 'djp 10/16/1999 17:27'!nilOrSymbol: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^nil]		ifFalse: [^aSymbolOrString asSymbol]! !!PlayingCardDeck methodsFor: 'printing' stamp: 'dgd 2/22/2003 13:38'!printOn: aStream 	| cards |	cards := self cards.	aStream nextPutAll: 'aCardDeck('.	cards size > 1 		ifTrue: 			[cards allButLast do: 					[:card | 					aStream						print: card;						nextPutAll: ', ']].	cards notEmpty ifTrue: [aStream print: cards last].	aStream nextPut: $)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PlayingCardDeck class	instanceVariableNames: ''!!PlayingCardDeck class methodsFor: 'new-morph participation' stamp: 'di 1/16/2000 10:38'!includeInNewMorphMenu	^false! !!PlayingCardDeck class methodsFor: 'instance creation' stamp: 'djp 10/15/1999 11:01'!newDeck	^self new newDeck! !!PlayingCardDeck class methodsFor: 'instance creation' stamp: 'djp 10/15/1999 09:53'!newSuit: suit	^self new newSuit: suit! !!PlayingCardDeck class methodsFor: 'symbols' stamp: 'djp 10/10/1999 18:06'!suits	^{#Clubs. #Diamonds. #Hearts. #Spades}! !!PlayingCardDeck class methodsFor: 'symbols' stamp: 'djp 10/17/1999 18:05'!values	^#(Ace),((2 to: 9) collect: [:i | i printString asSymbol]), #(Jack Queen King)! !ImageMorph subclass: #PlayingCardMorph	instanceVariableNames: 'cardNumber suitNumber'	classVariableNames: ''	poolDictionaries: ''	category: 'Etoys-Squeakland-Morphic-Games'!!PlayingCardMorph commentStamp: '<historical>' prior: 0!This class displays images from the PlayingCard class as morphs.  It attempts to be space-efficient by only producing its images on demand.!!PlayingCardMorph methodsFor: 'dropping/grabbing' stamp: 'di 12/12/2000 11:47'!aboutToBeGrabbedBy: aHand	"I'm about to be grabbed by the hand.  If other cards are above me in a deck,	then move them from the deck to being submorphs of me"	| i |	super aboutToBeGrabbedBy: aHand.	self removeProperty: #undoGrabCommand.  "So it won't interfere with overall move"	self board captureStateBeforeGrab.	i := owner submorphs indexOf: self ifAbsent: [^ self].	i = 1 ifTrue: [^ self].	(owner submorphs copyFrom: 1 to: i-1) do:		[:m | m class = self class ifTrue: [self addMorphBack: m]].! !!PlayingCardMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 20:05'!justDroppedInto: newOwner event: evt	(newOwner isKindOf: PlayingCardDeck)		ifFalse: ["Can't drop a card anywhere but on a deck"				self rejectDropMorphEvent: evt].	^super justDroppedInto: newOwner event: evt! !!PlayingCardMorph methodsFor: 'dropping/grabbing' stamp: 'di 12/12/2000 14:52'!slideBackToFormerSituation: evt	super slideBackToFormerSituation: evt.	self board removeProperty: #stateBeforeGrab.	self hasSubmorphs ifTrue:		["Just cancelled a drop of multiple cards -- have to unload submorphs"		self submorphs reverseDo: [:m | owner addMorphFront: m]].! !!PlayingCardMorph methodsFor: 'access' stamp: 'di 10/21/1999 21:41'!board	^ owner owner owner! !!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/24/1999 03:11'!cardDeck	^self owner! !!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!cardNumber	^cardNumber! !!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!cardNumber: c suitNumber: s	cardNumber := c.	suitNumber := s.! !!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!suit	^self class suits at: suitNumber! !!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!suitColor	^#(black red red black) at: suitNumber! !!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!suitNumber	^suitNumber! !!PlayingCardMorph methodsFor: 'event handling' stamp: 'RAA 2/12/2001 19:22'!click: evt		"since we really want to know about double-clicks before making our move, ignore this and wait until #firstClickTimedOut: arrives"! !!PlayingCardMorph methodsFor: 'event handling' stamp: 'djp 10/24/1999 03:12'!doubleClick: evt	^self cardDeck doubleClickOnCard: self! !!PlayingCardMorph methodsFor: 'event handling' stamp: 'dgd 2/22/2003 14:14'!firstClickTimedOut: evt 	| root popUp |	root := owner rootForGrabOf: self.	root isNil 		ifTrue: 			["Display hidden card in front"			popUp := self copy.			self board owner owner addMorphFront: popUp.			self world displayWorld.			(Delay forMilliseconds: 750) wait.			popUp delete]		ifFalse: [evt hand grabMorph: root]! !!PlayingCardMorph methodsFor: 'event handling' stamp: 'di 10/19/1999 00:01'!handlesMouseDown: evt	^ true! !!PlayingCardMorph methodsFor: 'event handling' stamp: 'jcg 9/21/2001 13:25'!mouseDown: evt	"Do nothing upon mouse-down except inform the hand to watch for a double-click; wait until an ensuing click:, doubleClick:, or drag: message gets dispatched"	evt hand waitForClicksOrDrag: self event: evt selectors: { #click:. #doubleClick:. #firstClickTimedOut:. nil} threshold: 5! !!PlayingCardMorph methodsFor: 'printing' stamp: 'djp 10/17/1999 20:27'!printOn: aStream	aStream		print: cardNumber;		nextPutAll: ' of ';		print: (self class suits at: suitNumber).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PlayingCardMorph class	instanceVariableNames: ''!!PlayingCardMorph class methodsFor: 'access' stamp: 'djp 10/17/1999 18:39'!cardSize	" a real hack, but I don't want to muck with Dan's class "	^71@96.! !!PlayingCardMorph class methodsFor: 'access' stamp: 'djp 10/17/1999 18:32'!height	^self cardSize y! !!PlayingCardMorph class methodsFor: 'access' stamp: 'djp 10/15/1999 07:14'!suits	^ #(clubs diamonds hearts spades)! !!PlayingCardMorph class methodsFor: 'access' stamp: 'djp 10/17/1999 18:32'!width	^self cardSize x! !!PlayingCardMorph class methodsFor: 'new-morph participation' stamp: 'di 1/16/2000 10:40'!includeInNewMorphMenu	^false! !!PlayingCardMorph class methodsFor: 'testing' stamp: 'djp 10/17/1999 18:24'!test    "Display all cards in the deck"	"MessageTally spyOn: [20 timesRepeat: [PlayingCardMorph test]]"	| table row |	table := AlignmentMorph newColumn.	self suits do: [:suit | 		row := AlignmentMorph newRow.		table addMorph: row.		1 to: 13 do: [:cn |			row addMorph: 			(PlayingCardMorph the: cn of: suit)]].	table openInWorld.! !!PlayingCardMorph class methodsFor: 'initialize-release' stamp: 'di 10/18/1999 23:45'!the: cardNumber of: suit	^ self new 		image: (PlayingCard the: cardNumber of: suit) cardForm;		cardNumber: cardNumber suitNumber: (self suits indexOf: suit)! !AlignmentMorph subclass: #SameGame	instanceVariableNames: 'board scoreDisplay selectionDisplay helpText'	classVariableNames: ''	poolDictionaries: ''	category: 'Etoys-Squeakland-Morphic-Games'!!SameGame commentStamp: '<historical>' prior: 0!See SameGame>>helpString for an explanation of how to play!!SameGame methodsFor: 'access' stamp: 'tao 5/18/1998 18:07'!board	board ifNil:		[board := SameGameBoard new			target: self;			actionSelector: #selection].	^ board! !!SameGame methodsFor: 'access' stamp: 'tao 5/18/1998 16:19'!board: aSameGameBoard	board := aSameGameBoard! !!SameGame methodsFor: 'access' stamp: 'asm 11/25/2003 22:40'!helpString	^ 'The object of SameGame is to maximize your score by removing tiles from the board.  Tiles are selected and removed by clicking on a tile that has at least one adjacent tile of the same color (where adjacent is defined as up, down, left, or right).The first click selects a group of adjacent tiles, a second click in that group will remove it from the board, sliding tiles down and right to fill the space of the removed group.  If you wish to select a different group, simply click on it instead.The score increases by "(selection - 2) squared", so you want to maximize the selection size as much as possible.  However, making small strategic selections may allow you to increase the size of a later selection.If you are having a hard time finding a group, the "Hint" button will find one and select it for you (although it is likely not the best group to select!!).When there are no more groups available, the score display will flash with your final score.  Your final score is reduced by 1 for each tile remaining on the board.  If you manage to remove all tiles, your final score is increased by a bonus of 5 times the number of tiles on a full board.Come on, you can beat that last score!!  Click "New game"  ;-)SameGame was originally written by Eiji Fukumoto for UNIX and X; this version is based upon the same game concept, but was rewritten from scratch.' translated! !!SameGame methodsFor: 'access' stamp: 'tao 5/18/1998 19:43'!helpText	helpText ifNil:		[helpText := PluggableTextMorph new			width: board width;			editString: self helpString].	^ helpText! !!SameGame methodsFor: 'access' stamp: 'di 9/12/2000 08:07'!scoreDisplay	^ scoreDisplay! !!SameGame methodsFor: 'initialization' stamp: 'mt 4/10/2018 11:34'!buildButton: aButton target: aTarget label: aLabel selector: aSelector	"wrap a button or switch in an alignmentMorph to allow a row of buttons to fill space"	| a |	aButton 		target: aTarget;		label: aLabel;		actionSelector: aSelector;		borderStyle: (BorderStyle raised width: 2);		color: color.	a := AlignmentMorph newColumn		wrapCentering: #center; cellPositioning: #topCenter;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		color: color.	a addMorph: aButton.	^ a! !!SameGame methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:30'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGray! !!SameGame methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:02'!initialize	"initialize the state of the receiver"	super initialize.	""	self listDirection: #topToBottom;	  wrapCentering: #center;		 cellPositioning: #topCenter;	  vResizing: #shrinkWrap;	  hResizing: #shrinkWrap;	  layoutInset: 3;	  addMorph: self makeControls;	  addMorph: self board.	helpText := nil.	self newGame! !!SameGame methodsFor: 'initialization' stamp: 'KR 3/28/2008 02:33'!makeControls	| row |	row := AlignmentMorph newRow		color: color;		borderWidth: 0;		layoutInset: 3.	row hResizing: #spaceFill; vResizing: #shrinkWrap; wrapCentering: #center; cellPositioning: #leftCenter; extent: 5@5.	row addMorph:		(self			buildButton: SimpleSwitchMorph new			target: self			label: 'Help' translated			selector: #help:).	row addMorph:		(self			buildButton: SimpleButtonMorph new			target: self			label: 'Quit' translated			selector: #delete).	row addMorph:		(self			buildButton: SimpleButtonMorph new			target: self board			label: 'Hint' translated			selector: #hint).	row addMorph:		(self			buildButton: SimpleButtonMorph new			target: self			label: 'New game' translated			selector: #newGame).	selectionDisplay := LedMorph new		digits: 2;		extent: (2*10@15).	row addMorph: (self wrapPanel: selectionDisplay label: 'Selection:' translated).	scoreDisplay := LedMorph new		digits: 4;		extent: (4*10@15).	row addMorph: (self wrapPanel: scoreDisplay label: 'Score:' translated).	^ row! !!SameGame methodsFor: 'initialization' stamp: 'ar 11/9/2000 21:22'!wrapPanel: anLedPanel label: aLabel	"wrap an LED panel in an alignmentMorph with a label to its left"	| a |	a := AlignmentMorph newRow		wrapCentering: #center; cellPositioning: #leftCenter;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 0;		layoutInset: 3;		color: color lighter.	a addMorph: anLedPanel.	a addMorph: (StringMorph contents: aLabel). 	^ a! !!SameGame methodsFor: 'actions' stamp: 'tao 5/18/1998 19:45'!help: helpState	helpState		ifTrue: [self addMorphBack: self helpText]		ifFalse: [helpText delete]! !!SameGame methodsFor: 'actions' stamp: 'tao 5/18/1998 18:35'!newGame	scoreDisplay value: 0; flash: false.	selectionDisplay value: 0.	self board resetBoard.! !!SameGame methodsFor: 'actions' stamp: 'aoy 2/15/2003 21:40'!selection	"a selection was made on the board; get its count and update the displays"	| count score |	count := self board selectionCount.	count = 0 		ifTrue: 			[score := scoreDisplay value + (selectionDisplay value - 2) squared.			board findSelection ifNil: 					[count := board tilesRemaining.					score := count = 0 						ifTrue: [score + (5 * board rows * board columns)]						ifFalse: [score - count].					scoreDisplay flash: true].			scoreDisplay value: score].	selectionDisplay value: count! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SameGame class	instanceVariableNames: ''!!SameGame class methodsFor: 'parts bin' stamp: 'tak 7/25/2007 00:11'!descriptionForPartsBin	^ self partName:	'Same' translatedNoop		categories:		{'Games' translatedNoop}		documentation:	'A board game implementedby Tim Olson, based on a game originally written for UNIX by Eiji Fukumoto.' translatedNoop! !AlignmentMorph subclass: #SameGameBoard	instanceVariableNames: 'protoTile rows columns palette selection selectionColor flashColor flash target actionSelector arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'Etoys-Squeakland-Morphic-Games'!!SameGameBoard commentStamp: '<historical>' prior: 0!I am an MxN array of SameGameTiles, and implement most of the logic to play the SameGame, including adjacent tile selection and removal.!!SameGameBoard methodsFor: 'layout' stamp: 'tao 5/15/1998 14:15'!acceptDroppingMorph: aMorph event: evt	"Allow the user to set the protoTile just by dropping it on this morph."	self protoTile: aMorph.	self removeAllMorphs.! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:59'!actionSelector	^ actionSelector! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 17:00'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector := nil].	actionSelector := aSymbolOrString asSymbol.! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:45'!columns	^ columns! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:57'!columns: newColumns	self extent: self protoTile extent * (newColumns @ rows)! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:57'!columns: newColumns rows: newRows	self extent: self protoTile extent * (newColumns @ newRows)! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:47'!protoTile	protoTile ifNil: [protoTile := SameGameTile new].	^ protoTile! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:48'!protoTile: aTile	protoTile := aTile! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:45'!rows	^ rows! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:57'!rows: newRows	self extent: self protoTile extent * (columns @ newRows)! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:56'!selectionCount	^ selection isNil		ifTrue: [0]		ifFalse: [selection size]! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:59'!target	^ target! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:59'!target: anObject	target := anObject! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 10:31'!tileAt: aPoint	^ submorphs at: (aPoint x + (aPoint y * columns) + 1)! !!SameGameBoard methodsFor: 'private' stamp: 'ar 11/20/2000 19:26'!adjustTiles	"add or remove new protoTile submorphs to fill out my new bounds"	| newSubmorphs requiredSubmorphs count r c |	columns := self width // protoTile width.	rows := self height // protoTile height.	requiredSubmorphs := rows * columns.	newSubmorphs := OrderedCollection new.	r := 0.	c := 0.	self submorphCount > requiredSubmorphs		ifTrue: "resized smaller -- delete rows or columns"			[count := 0.			submorphs do:				[:m | 				count < requiredSubmorphs					ifTrue:						[m position: self position + (protoTile extent * (c @ r)).						m arguments: (Array with: c @ r).						newSubmorphs add: m]					ifFalse: [m privateOwner: nil].				count := count + 1.				c := c + 1.				c >= columns ifTrue: [c := 0. r := r + 1]]]		ifFalse: "resized larger -- add rows or columns"			[submorphs do:				[:m |				m position: self position + (self protoTile extent * (c @ r)).				m arguments: (Array with: c @ r).				newSubmorphs add: m.				c := c + 1.				c >= columns ifTrue: [c := 0. r := r + 1]].			1 to: (requiredSubmorphs - self submorphCount) do:				[:m |				newSubmorphs add:					(protoTile copy						position: self position + (self protoTile extent * (c @ r));						actionSelector: #tileClickedAt:newSelection:;						arguments: (Array with: c @ r);						target: self;						privateOwner: self).				c := c + 1.				c >= columns ifTrue: [c := 0. r := r + 1]]].	submorphs := newSubmorphs asArray.! !!SameGameBoard methodsFor: 'private' stamp: 'di 7/1/1998 00:04'!tilesRemaining	^ (submorphs reject: [:m | m disabled]) size! !!SameGameBoard methodsFor: 'undo' stamp: 'dgd 2/22/2003 13:36'!capturedState	"Note the state stored in the second element is an array of associations	from submorph index to a shallowCopy of the morph, but only for those	morphs that change.  Therefore the capturedState record *first* delivers	all the morphs, and *then* computes the difference and stores this back.	In the end, both undo and redo records follow this format."	| prior state oldMorphs priorChanges newChanges |	(prior := self valueOfProperty: #priorState) isNil 		ifTrue: 			[state := { 						self shallowCopy.	"selection, etc."						self submorphs collect: [:m | m shallowCopy].	"state of all tiles"						owner scoreDisplay flash.	"score display"						owner scoreDisplay value}.			self setProperty: #priorState toValue: state.			^state].	oldMorphs := prior second.	priorChanges := OrderedCollection new.	newChanges := OrderedCollection new.	1 to: oldMorphs size		do: 			[:i | 			(oldMorphs at: i) color = (submorphs at: i) color 				ifFalse: 					[priorChanges addLast: i -> (oldMorphs at: i).					newChanges addLast: i -> (submorphs at: i) shallowCopy]].	self removeProperty: #priorState.	prior at: 2 put: priorChanges asArray.	"Store back into undo state.2"	^{ 		self shallowCopy.	"selection, etc."		newChanges asArray.	"state of tiles that changed"		owner scoreDisplay flash.	"score display"		owner scoreDisplay value}! !!SameGameBoard methodsFor: 'undo' stamp: 'di 12/12/2000 16:44'!undoFromCapturedState: st 	self copyFrom: st first.	st second do: [:assn | (submorphs at: assn key) copyFrom: assn value].	selection ifNotNil:		[selection do: [:loc | (self tileAt: loc) setSwitchState: false; color: selectionColor].		selection := nil].	owner scoreDisplay flash: st third.  "score display"	owner scoreDisplay value: st fourth.	self changed.! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 12:01'!collapseColumn: col fromRow: row	| targetTile sourceTile |	(targetTile := self tileAt: col@row) disabled ifTrue:		[row - 1 to: 0 by: -1 do:			[:r |			(sourceTile := self tileAt: col@r) disabled ifFalse:				[targetTile color: sourceTile color.				targetTile disabled: false.				sourceTile disabled: true.				^ true]]].	^ false! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/18/1998 18:47'!collapseColumns: columnsToCollapse	| columnsToRemove |	columnsToRemove := OrderedCollection new.	columnsToCollapse do:		[:c |		rows - 1 to: 0 by: -1 do: [:r | self collapseColumn: c fromRow: r].		(self tileAt: c@(rows-1)) disabled ifTrue: [columnsToRemove add: c]].	self world displayWorld.	columnsToRemove reverseDo: [:c | self removeColumn: c].! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 11:38'!deselectSelection	selection ifNotNil:		[selection do: [:loc | (self tileAt: loc) setSwitchState: false; color: selectionColor].		selection := nil.		flash := false]! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/18/1998 18:52'!findSelection	"find a possible selection and return it, or nil if no selection"	| tile k testTile |	0 to: rows-1 do:		[:r |		0 to: columns-1 do:			[:c |			tile := self tileAt: c@r.			tile disabled  ifFalse:				[k := tile color.				c+1 < columns ifTrue:					[testTile := self tileAt: (c+1)@r.					(testTile disabled not and: [testTile color = k]) ifTrue: [^ tile]].				r+1 < rows ifTrue:					[testTile := self tileAt: c@(r+1).					(testTile disabled not and: [testTile color = k]) ifTrue: [^ tile]]]]].	 ^ nil			! !!SameGameBoard methodsFor: 'actions' stamp: 'ar 10/25/2000 23:13'!hint	"find a possible selection and select it"	| tile |	self deselectSelection.	tile := self findSelection.	tile ifNotNil: [tile mouseDown: MouseButtonEvent new]! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 15:54'!removeColumn: column	| sourceTile |	column+1 to: columns-1 do:		[:c |		0 to: rows-1 do:			[:r |			sourceTile := self tileAt: c@r.			(self tileAt: c-1@r)				color: sourceTile color;				disabled: sourceTile disabled]].	0 to: rows-1 do:		[:r | (self tileAt: columns-1@r) disabled: true]! !!SameGameBoard methodsFor: 'actions' stamp: 'ul 3/13/2017 01:35'!removeSelection	selection		ifNil: [^ self].	self		rememberUndoableAction: [selection				do: [:loc | (self tileAt: loc) disabled: true;						 setSwitchState: false].			self collapseColumns: (selection					collect: [:loc | loc x] as: Set) sorted.			selection := nil.			flash := false.			(target notNil					and: [actionSelector notNil])				ifTrue: [target perform: actionSelector withArguments: arguments]]		named: 'remove selection' translated! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 11:37'!selectTilesAdjacentTo: location	| al at |	{-1@0. 0@ -1. 1@0. 0@1} do:		[:offsetPoint |		al := location + offsetPoint.		((al x between: 0 and: columns - 1) and: [al y between: 0 and: rows - 1]) ifTrue:			[at := self tileAt: al.			(at color = selectionColor and: [at switchState not and: [at disabled not]]) ifTrue:				[selection add: al.				at setSwitchState: true.				self selectTilesAdjacentTo: al]]]! !!SameGameBoard methodsFor: 'actions' stamp: 'dgd 2/22/2003 18:51'!tileClickedAt: location newSelection: isNewSelection 	| tile |	isNewSelection 		ifTrue: 			[self deselectSelection.			tile := self tileAt: location.			selectionColor := tile color.			selection := OrderedCollection with: location.			self selectTilesAdjacentTo: location.			selection size = 1 				ifTrue: [self deselectSelection]				ifFalse: 					[(target notNil and: [actionSelector notNil]) 						ifTrue: [target perform: actionSelector withArguments: arguments]]]		ifFalse: [self removeSelection]! !!SameGameBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:39'!defaultBorderWidth	"answer the default border width for the receiver"	^ 2! !!SameGameBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:30'!defaultColor	"answer the default color/fill style for the receiver"	^ Color gray! !!SameGameBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:12'!initialize	"initialize the state of the receiver"	super initialize.	target := nil.	actionSelector := #selection.	arguments := #().	self layoutPolicy: nil.	self hResizing: #rigid.	self vResizing: #rigid.	rows := self preferredRows.	columns := self preferredColumns.	palette := (Color wheel: self preferredTileTypes + 1) asOrderedCollection.	flashColor := palette removeLast.	flash := false.	self extent: self protoTile extent * (columns @ rows).	self resetBoard! !!SameGameBoard methodsFor: 'initialization' stamp: 'di 12/12/2000 15:03'!resetBoard	Collection initialize.  "randomize"	selection := nil.	self purgeAllCommands.	self submorphsDo:		[:m |		m disabled: false.		m setSwitchState: false.		m color: palette atRandom].! !!SameGameBoard methodsFor: 'geometry' stamp: 'ar 11/20/2000 19:28'!extent: aPoint	"constrain the extent to be a multiple of the protoTile size during resizing"	super extent: (aPoint truncateTo: protoTile extent).	self adjustTiles.! !!SameGameBoard methodsFor: 'preferences' stamp: 'tao 5/17/1998 09:24'!preferredColumns	^ 20! !!SameGameBoard methodsFor: 'preferences' stamp: 'tao 5/17/1998 09:24'!preferredRows	^ 10! !!SameGameBoard methodsFor: 'preferences' stamp: 'tao 5/17/1998 09:34'!preferredTileTypes	^ 5! !!SameGameBoard methodsFor: 'stepping and presenter' stamp: 'tao 5/17/1998 11:38'!step	| newColor |	selection ifNotNil:		[newColor := flash			ifTrue: [selectionColor]			ifFalse: [flashColor].		selection do: [:loc | (self tileAt: loc) color: newColor].		flash := flash not]! !!SameGameBoard methodsFor: 'testing' stamp: 'tao 5/18/1998 11:16'!stepTime	^ 500! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SameGameBoard class	instanceVariableNames: ''!!SameGameBoard class methodsFor: 'new-morph participation' stamp: 'di 1/16/2000 10:37'!includeInNewMorphMenu	^false! !SimpleSwitchMorph subclass: #SameGameTile	instanceVariableNames: 'switchState disabled oldSwitchState'	classVariableNames: ''	poolDictionaries: ''	category: 'Etoys-Squeakland-Morphic-Games'!!SameGameTile commentStamp: '<historical>' prior: 0!I am a single tile for the SameGame.  I act much like a switch.!!SameGameTile methodsFor: 'accessing' stamp: 'dgd 2/14/2003 21:59'!color: aColor 	super color: aColor.	onColor := aColor.	offColor := aColor.	self changed! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 08:46'!disabled	^ disabled! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 09:21'!disabled: aBoolean	disabled := aBoolean.	disabled		ifTrue:			[self color: owner color.			self borderColor: owner color]		ifFalse:			[self setSwitchState: self switchState]! !!SameGameTile methodsFor: 'accessing' stamp: 'ar 8/26/2001 17:14'!insetColor	"Use my own color for insets"	^color! !!SameGameTile methodsFor: 'accessing' stamp: 'mt 5/4/2018 11:42'!setSwitchState: aBoolean	switchState := aBoolean.	disabled ifFalse:		[switchState			ifTrue:				[self borderInset.				self color: onColor]			ifFalse:				[self borderRaised.				self color: offColor]]! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 09:19'!switchState	^ switchState! !!SameGameTile methodsFor: 'button' stamp: 'dgd 2/22/2003 19:00'!doButtonAction	"Perform the action of this button. The last argument of the message sent to the target is the new state of this switch."	(target notNil and: [actionSelector notNil]) 		ifTrue: 			[target perform: actionSelector				withArguments: (arguments copyWith: switchState)]! !!SameGameTile methodsFor: 'initialization' stamp: 'sw 11/30/1999 08:21'!initialize	super initialize.	self label: ''.	self borderWidth: 2.	bounds := 0@0 corner: 16@16.	offColor := Color gray.	onColor := Color gray.	switchState := false.	oldSwitchState := false.	disabled := false.	self useSquareCorners	! !!SameGameTile methodsFor: 'event handling' stamp: 'tao 5/18/1998 17:43'!mouseDown: evt	disabled ifFalse:		[oldSwitchState := switchState.		self setSwitchState: (oldSwitchState = false).		self doButtonAction].! !!SameGameTile methodsFor: 'event handling' stamp: 'tao 5/18/1998 17:43'!mouseMove: evt	"don't do anything, here"! !!SameGameTile methodsFor: 'event handling' stamp: 'tao 5/18/1998 17:42'!mouseUp: evt	"don't do anything, here"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SameGameTile class	instanceVariableNames: ''!!SameGameTile class methodsFor: 'new-morph participation' stamp: 'di 1/16/2000 10:37'!includeInNewMorphMenu	^false! !AlignmentMorph subclass: #Tetris	instanceVariableNames: 'board scoreDisplay'	classVariableNames: ''	poolDictionaries: ''	category: 'Etoys-Squeakland-Morphic-Games'!!Tetris commentStamp: '<historical>' prior: 0!This is a port of JTetris.java 1.0.0.How to start:choose new morph.../Games/TetrisHow to play:1) using buttons2) using keyboard:	drop - spacebar	move to left - left arrow	move to right - right arrow	rotate clockwise - up arrow	rotate anticlockwise - down arrowNOTE: mouse must be over Tetris!!Tetris methodsFor: 'initialization' stamp: 'mt 4/10/2018 11:42'!buildButtonTarget: aTarget label: aLabel selector: aSelector help: aString	^self rowForButtons		addMorph: (			SimpleButtonMorph new 				target: aTarget;				label: aLabel;				actionSelector: aSelector;				borderStyle: (BorderStyle raised width: 2);				color: color		)! !!Tetris methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:31'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGray! !!Tetris methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:26'!initialize	"initialize the state of the receiver"	super initialize.	""	board := TetrisBoard new game: self.	self listDirection: #topToBottom;	  wrapCentering: #center;	  vResizing: #shrinkWrap;	  hResizing: #shrinkWrap;	  layoutInset: 3;	  addMorphBack: self makeGameControls;		 addMorphBack: self makeMovementControls;		 addMorphBack: self showScoreDisplay;		 addMorphBack: board.	board newGame! !!Tetris methodsFor: 'initialization' stamp: 'asm 11/25/2003 22:45'!makeGameControls	^ self rowForButtons		addMorph: (self				buildButtonTarget: self				label: 'Quit' translated				selector: #delete				help: 'quit' translated);				addMorph: (self				buildButtonTarget: board				label: 'Pause' translated				selector: #pause				help: 'pause' translated);				addMorph: (self				buildButtonTarget: board				label: 'New game' translated				selector: #newGame				help: 'new game' translated)! !!Tetris methodsFor: 'initialization' stamp: 'asm 11/25/2003 22:45'!makeMovementControls	^ self rowForButtons		addMorph: (self				buildButtonTarget: board				label: '->'				selector: #moveRight				help: 'move to the right' translated);				addMorph: (self				buildButtonTarget: board				label: ' ) '				selector: #rotateClockWise				help: 'rotate clockwise' translated);				addMorph: (self				buildButtonTarget: board				label: ' | '				selector: #dropAllTheWay				help: 'drop' translated);				addMorph: (self				buildButtonTarget: board				label: ' ( '				selector: #rotateAntiClockWise				help: 'rotate anticlockwise' translated);				addMorph: (self				buildButtonTarget: board				label: '<-'				selector: #moveLeft				help: 'move to the left' translated)! !!Tetris methodsFor: 'initialization' stamp: 'ar 11/9/2000 21:24'!rowForButtons	^AlignmentMorph newRow		color: color;		borderWidth: 0;		layoutInset: 3;		vResizing: #shrinkWrap;		wrapCentering: #center! !!Tetris methodsFor: 'initialization' stamp: 'asm 11/25/2003 22:45'!showScoreDisplay	^ self rowForButtons hResizing: #shrinkWrap;				addMorph: (self wrapPanel: ((scoreDisplay := LedMorph new) digits: 5;					 extent: 4 * 10 @ 15) label: 'Score:' translated)! !!Tetris methodsFor: 'initialization' stamp: 'RAA 1/8/2000 14:38'!wrapPanel: anLedPanel label: aLabel	"wrap an LED panel in an alignmentMorph with a label to its left"	^self rowForButtons		color: color lighter;		addMorph: anLedPanel;		addMorph: (StringMorph contents: aLabel)! !!Tetris methodsFor: 'event handling' stamp: 'ar 9/15/2000 22:58'!handlesKeyboard: evt	^true! !!Tetris methodsFor: 'event handling' stamp: 'tak 9/25/2008 14:57'!handlesMouseOver: evt	^true! !!Tetris methodsFor: 'event handling' stamp: 'RAA 1/8/2000 15:42'!keyStroke: evt	| charValue |	charValue := evt keyCharacter asciiValue.	charValue = 28 ifTrue: [board moveLeft].	charValue = 29 ifTrue: [board moveRight].	charValue = 30 ifTrue: [board rotateClockWise].	charValue = 31 ifTrue: [board rotateAntiClockWise].	charValue = 32 ifTrue: [board dropAllTheWay].! !!Tetris methodsFor: 'event handling' stamp: 'ar 9/15/2000 23:07'!mouseEnter: evt        evt hand newKeyboardFocus: self! !!Tetris methodsFor: 'events' stamp: 'RAA 1/7/2000 22:37'!score: anInteger	scoreDisplay value: anInteger! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Tetris class	instanceVariableNames: ''!!Tetris class methodsFor: 'as yet unclassified' stamp: 'RAA 1/7/2000 23:19'!colors	^{		Color r: 0.5 g: 0 b: 0.		Color r: 0 g: 0.5 b: 0.		Color r: 0 g: 0 b: 0.5.		Color r: 0.5 g: 0.5 b: 0.		Color r: 0.5 g: 0 b: 0.5.		Color r: 0 g: 0.5 b: 0.5	}! !!Tetris class methodsFor: 'parts bin' stamp: 'topa 10/4/2017 10:04'!descriptionForPartsBin	^ self partName:	'Tetris' translatedNoop		categories:		{'Games' translatedNoop}		documentation:	'Tetris, yes Tetris' translatedNoop! !Morph subclass: #TetrisBlock	instanceVariableNames: 'angle shapeInfo board baseCellNumber'	classVariableNames: 'ShapeChoices'	poolDictionaries: ''	category: 'Etoys-Squeakland-Morphic-Games'!!TetrisBlock methodsFor: 'as yet unclassified' stamp: 'RAA 1/8/2000 15:58'!board: theBoard	board := theBoard.	4 timesRepeat: [		self addMorph: (			RectangleMorph new				color: color;				extent: board cellSize;				borderRaised		 )	].	self positionCellMorphs.! !!TetrisBlock methodsFor: 'as yet unclassified' stamp: 'RAA 1/8/2000 12:37'!dropByOne 	^self moveDeltaX: 0 deltaY: 1 deltaAngle: 0! !!TetrisBlock methodsFor: 'as yet unclassified' stamp: 'RAA 1/8/2000 13:56'!moveDeltaX: deltaX deltaY: deltaY deltaAngle: deltaAngle 	| delta |	delta := deltaX @ deltaY.	(shapeInfo atWrap: angle + deltaAngle) do: [ :offsetThisCell | 		(board emptyAt: baseCellNumber + offsetThisCell + delta) ifFalse: [^ false]	].	baseCellNumber := baseCellNumber + delta.	angle := angle + deltaAngle - 1 \\ 4 + 1.	self positionCellMorphs.	^ true ! !!TetrisBlock methodsFor: 'as yet unclassified' stamp: 'RAA 1/8/2000 13:41'!positionCellMorphs	(shapeInfo atWrap: angle) withIndexDo: [ :each :index |		(submorphs at: index)			position: (board originForCell: baseCellNumber + each)	].	fullBounds := nil.	self changed.	 ! !!TetrisBlock methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:07'!defaultBounds"answer the default bounds for the receiver"	^ (2 @ 2) negated extent: 1 @ 1! !!TetrisBlock methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:31'!defaultColor	"answer the default color/fill style for the receiver"	^ Tetris colors atRandom! !!TetrisBlock methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:50'!initialize	"initialize the state of the receiver"	super initialize.	""		"keep this puppy out of sight"	shapeInfo := self class shapeChoices atRandom.	baseCellNumber := 4 atRandom + 2 @ 1.	angle := 4 atRandom! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TetrisBlock class	instanceVariableNames: ''!!TetrisBlock class methodsFor: 'as yet unclassified' stamp: 'RAA 1/8/2000 15:29'!flipShapes: anArray	^OrderedCollection new 		add: anArray;		add: (anArray collect: [ :each | each y negated @ each x]);		add: (anArray collect: [ :each | each x negated @ each y negated]);		add: (anArray collect: [ :each | each y @ each x negated]);		yourself	! !!TetrisBlock class methodsFor: 'as yet unclassified' stamp: 'RAA 1/8/2000 15:32'!shapeChoices	^ ShapeChoices ifNil: [		ShapeChoices := {			{ {  0 @ 0 .  1 @ 0 .  0 @ 1 .  1 @ 1  } }.	"square - one is sufficient here"			self flipShapes: {  0 @  0 . -1 @  0 .  1 @  0 .  0 @ -1  }.	"T"			{ 				{  0 @ 0 . -1 @ 0 .  1 @ 0 .  2 @ 0  }.				{  0 @ 0 .  0 @ -1 .  0 @ 1 .  0 @ 2  } 	"long - two are sufficient here"			}.			self flipShapes: { 0 @ 0 .  0 @ -1 .  0 @  1 .  1 @  1  }.	"L"			self flipShapes: { 0 @ 0 .  0 @ -1 .  0 @  1 . -1 @  1  }.	"inverted L"			self flipShapes: { 0 @ 0 . -1 @  0 .  0 @ -1 .  1 @ -1  }.	"S"			self flipShapes: {  0 @ 0 .  1 @ 0 .  0 @ -1 . -1 @ -1  } "Z"		}.	]! !!TetrisBlock class methodsFor: 'new-morph participation' stamp: 'RAA 1/8/2000 11:55'!includeInNewMorphMenu	^false! !PasteUpMorph subclass: #TetrisBoard	instanceVariableNames: 'paused gameOver delay score currentBlock game'	classVariableNames: ''	poolDictionaries: ''	category: 'Etoys-Squeakland-Morphic-Games'!!TetrisBoard methodsFor: 'as yet unclassified' stamp: 'RAA 1/7/2000 23:12'!cellSize	^12@12! !!TetrisBoard methodsFor: 'as yet unclassified' stamp: 'RAA 1/8/2000 13:11'!originForCell: aPoint	^aPoint - (1@1) * self cellSize + self position! !!TetrisBoard methodsFor: 'other' stamp: 'RAA 1/8/2000 13:20'!checkForFullRows	| targetY morphsInRow bonus |	self numRows to: 2 by: -1 do: [ :row |		targetY := (self originForCell: 1@row) y.		[			morphsInRow := self submorphsSatisfying: [ :each | each top = targetY].			morphsInRow size = self numColumns		] whileTrue: [			bonus := (morphsInRow collect: [:each | each color]) asSet size = 1 				ifTrue: [1000] 				ifFalse: [100].			self score: score + bonus.			submorphs copy do: [ :each |				each top = targetY ifTrue: [					each delete				].				each top < targetY ifTrue: [					each position: each position + (0@self cellSize y)				].			].		].	].! !!TetrisBoard methodsFor: 'other' stamp: 'RAA 1/8/2000 13:59'!storePieceOnBoard	currentBlock submorphs do: [ :each |		self addMorph: each.		((each top - self top) // self cellSize y) < 3 ifTrue: [			paused := gameOver := true.		].	].	currentBlock delete.	currentBlock := nil.	self checkForFullRows.	self score: score + 10.	delay := delay - 2 max: 80.! !!TetrisBoard methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:07'!defaultBounds"answer the default bounds for the receiver"	^ 0 @ 0 extent: self numColumns @ self numRows * self cellSize + (1 @ 1)! !!TetrisBoard methodsFor: 'initialization' stamp: 'dgd 2/17/2003 19:38'!defaultColor	"answer the default color/fill style for the receiver"	^ Color		  lightBlue! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 14:03'!dropAllTheWay	self running ifFalse: [^ self].	[currentBlock dropByOne] whileTrue: [		self score: score + 1	].! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 11:17'!moveLeft	self running ifFalse: [^ self].	currentBlock moveDeltaX: -1 deltaY: 0 deltaAngle: 0.! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 11:17'!moveRight	self running ifFalse: [^ self].	currentBlock moveDeltaX: 1 deltaY: 0 deltaAngle: 0.! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 13:20'!newGame	self removeAllMorphs.	gameOver := paused := false.	delay := 500.	currentBlock := nil.	self score: 0.! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 11:16'!pause	gameOver ifTrue: [^ self].	paused := paused not.! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 11:17'!rotateAntiClockWise	self running ifFalse: [^ self].	currentBlock moveDeltaX: 0 deltaY: 0 deltaAngle: -1.! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 11:17'!rotateClockWise	self running ifFalse: [^ self].	currentBlock moveDeltaX: 0 deltaY: 0 deltaAngle: 1.! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 8/28/1999 22:31'!running	^currentBlock notNil and: [paused not]! !!TetrisBoard methodsFor: 'data' stamp: 'RAA 1/8/2000 13:16'!emptyAt: aPoint	| cellOrigin |	(aPoint x between: 1 and: self numColumns) ifFalse: [^ false].	(aPoint y < 1) ifTrue: [^ true].	"handle early phases"	(aPoint y <= self numRows) ifFalse: [^ false].	cellOrigin := self originForCell: aPoint.	^(self submorphsSatisfying: [ :each | each topLeft = cellOrigin]) isEmpty! !!TetrisBoard methodsFor: 'data' stamp: 'RAA 8/28/1999 23:29'!numColumns	^10	! !!TetrisBoard methodsFor: 'data' stamp: 'RAA 8/28/1999 23:30'!numRows	^27	! !!TetrisBoard methodsFor: 'accessing' stamp: 'RAA 1/7/2000 22:34'!game: aTetris	game := aTetris! !!TetrisBoard methodsFor: 'accessing' stamp: 'RAA 1/7/2000 22:38'!score: aNumber	score := aNumber.	game score: score.! !!TetrisBoard methodsFor: 'stepping and presenter' stamp: 'RAA 1/8/2000 15:59'!step	(self ownerThatIsA: HandMorph) ifNotNil: [^self].	paused ifTrue: [^ self]. 	currentBlock ifNil: [		currentBlock := TetrisBlock new.		self addMorphFront: currentBlock.		currentBlock board: self.	] ifNotNil: [		currentBlock dropByOne ifFalse: [self storePieceOnBoard]	].! !!TetrisBoard methodsFor: 'testing' stamp: 'bf 9/25/2008 14:55'!stepTime	^ delay! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TetrisBoard class	instanceVariableNames: ''!!TetrisBoard class methodsFor: 'new-morph participation' stamp: 'RAA 1/7/2000 22:56'!includeInNewMorphMenu	^false! !BorderedMorph subclass: #WordGameLetterMorph	instanceVariableNames: 'letter originalLetter idString linkedLetters predecessor successor indexInQuote lineMorph letterMorph style'	classVariableNames: 'IDFont IDHeight LetterFont LetterHeight'	poolDictionaries: ''	category: 'Etoys-Squeakland-Morphic-Games'!!WordGameLetterMorph commentStamp: '<historical>' prior: 0!WordGameLetterMorph implements letter boxes for type-in and display of letter in word games.  Several variant displays are supported, depending on the setting of style, and blanks can be displayed as black boxes or empty letter boxes.Default support for type-in is distributed between this class and WordGamePaneMorphletter			the Character stored in this morph.				Can be either blank or nil as well as a letter.indexInQuote	a retained copy of the index of this character				Facilitates responses to, eg, clicking or typing in this box.				If indexInQuote==nil, then this is displayed as a black boxpredecessor		another LetterMorph or nil				Used for linked typing and, eg, word selectionsuccessor		another LetterMorph or nil				Used for linked typing and, eg, word selectionstyle			a Symbol, one of #(plain boxed underlined)				Boxed and underlined display further depends on whether				the id strings are nil or not.				Each format has an associated default sizeThe following two variables are also submorphs, as are the id strings if present.letterMorph		a StringMorph for displaying the letter				Used when changing the letter to be displayedlineMorph		a PolygonMorph used to display the underline				and also to place the id string in underlined format!!WordGameLetterMorph methodsFor: 'style inits' stamp: 'di 5/7/2000 17:00'!boxed	style := #boxed! !!WordGameLetterMorph methodsFor: 'style inits' stamp: 'di 5/7/2000 17:00'!plain	style := #plain! !!WordGameLetterMorph methodsFor: 'style inits' stamp: 'di 5/7/2000 17:01'!underlined	style := #underlined! !!WordGameLetterMorph methodsFor: 'event handling' stamp: 'di 10/14/2000 22:36'!handlesKeyboard: evt	^ true! !!WordGameLetterMorph methodsFor: 'event handling' stamp: 'di 5/9/2000 16:20'!keyboardFocusChange: boolean	| panel |	boolean ifFalse:		[panel := self nearestOwnerThat: [:m | m respondsTo: #checkForLostFocus].		panel ifNotNil: [panel checkForLostFocus]]! !!WordGameLetterMorph methodsFor: 'initialization' stamp: 'di 5/11/2000 07:33'!id2: idString	"Add further clue id for acrostic puzzles."	| idMorph |	idString ifNotNil:		[idMorph := StringMorph contents: idString font: IDFont.		idMorph align: idMorph bounds topRight with: self bounds topRight + (-1@ -1).		self addMorph: idMorph].! !!WordGameLetterMorph methodsFor: 'initialization' stamp: 'dgd 2/21/2003 23:15'!indexInQuote: qi id1: aString 	"Initialize me with the given index and an optional aString"	| idMorph y |	style = #boxed		ifTrue: [aString isNil				ifTrue: [self extent: 18 @ 16;						 borderWidth: 1]				ifFalse: [self extent: 26 @ 24;						 borderWidth: 1]]		ifFalse: [aString isNil				ifTrue: [self extent: 18 @ 16;						 borderWidth: 0]				ifFalse: [self extent: 18 @ 26;						 borderWidth: 0]].	qi		ifNil: [^ self color: Color gray].	"blank"	self color: self normalColor.	indexInQuote := qi.	style == #underlined		ifTrue: [y := self bottom - 2.			aString				ifNotNil: [y := y - IDFont ascent + 2].			lineMorph := PolygonMorph						vertices: {self left + 2 @ y. self right - 3 @ y}						color: Color gray						borderWidth: 1						borderColor: Color gray.			self addMorph: lineMorph.			aString				ifNil: [^ self].			idMorph := StringMorph contents: aString font: IDFont.			idMorph align: idMorph bounds bottomCenter with: self bounds bottomCenter + (0 @ (IDFont descent - 1)).			self addMorphBack: idMorph]		ifFalse: [aString				ifNil: [^ self].			idMorph := StringMorph contents: aString font: IDFont.			idMorph align: idMorph bounds topLeft with: self bounds topLeft + (2 @ -1).			self addMorph: idMorph			" 			World addMorph: (WordGameLetterMorph new boxed  			indexInQuote: 123 id1: '123';  			id2: 'H'; setLetter: $W).  			World addMorph: (WordGameLetterMorph new underlined  			indexInQuote: 123 id1: '123';  			setLetter: $W).  			World addMorph: (WordGameLetterMorph new underlined  			indexInQuote: 123 id1: nil;  			setLetter: $W). 			"]! !!WordGameLetterMorph methodsFor: 'initialization' stamp: 'di 5/8/2000 11:22'!normalColor	^ Color r: 1.0 g: 0.8 b: 0.2! !!WordGameLetterMorph methodsFor: 'initialization' stamp: 'di 5/7/2000 23:58'!setLetter: aLetter	^ self setLetter: aLetter color: Color black! !!WordGameLetterMorph methodsFor: 'initialization' stamp: 'dgd 2/21/2003 23:15'!setLetter: aLetter color: aColor 	letterMorph ifNotNil: [letterMorph delete].	letter := aLetter.	letter ifNil: [^letterMorph := nil].	letterMorph := StringMorph contents: aLetter asString font: LetterFont.	letterMorph color: aColor.	style == #boxed 		ifTrue: 			[letterMorph align: letterMorph bounds bottomCenter				with: self bounds bottomCenter + (0 @ (LetterFont descent - 2))]		ifFalse: 			[lineMorph isNil 				ifTrue: 					[letterMorph align: letterMorph bounds bottomCenter						with: self bounds bottomCenter + (0 @ (LetterFont descent - 4))]				ifFalse: 					[letterMorph align: letterMorph bounds bottomCenter						with: self center x @ (lineMorph top + LetterFont descent)]].	self addMorphBack: letterMorph! !!WordGameLetterMorph methodsFor: 'accessing' stamp: 'di 5/7/2000 13:42'!indexInQuote	^ indexInQuote! !!WordGameLetterMorph methodsFor: 'accessing' stamp: 'dgd 2/21/2003 23:15'!isBlank	^indexInQuote isNil! !!WordGameLetterMorph methodsFor: 'accessing' stamp: 'di 5/7/2000 23:31'!letter	^ letter! !!WordGameLetterMorph methodsFor: 'accessing' stamp: 'di 5/7/2000 13:43'!predecessor	^ predecessor! !!WordGameLetterMorph methodsFor: 'accessing' stamp: 'di 5/7/2000 13:25'!predecessor: pred	predecessor := pred! !!WordGameLetterMorph methodsFor: 'accessing' stamp: 'di 5/7/2000 13:43'!successor	^ successor! !!WordGameLetterMorph methodsFor: 'accessing' stamp: 'di 5/7/2000 13:25'!successor: succ	successor := succ! !!WordGameLetterMorph methodsFor: 'linking' stamp: 'dgd 2/21/2003 23:15'!morphsInWordDo: aBlock 	aBlock value: self.	(successor isNil or: [successor isBlank]) ifTrue: [^self].	successor morphsInWordDo: aBlock! !!WordGameLetterMorph methodsFor: 'linking' stamp: 'di 5/7/2000 14:06'!nextTypeableLetter	successor ifNil: [^ self].	successor isBlank ifTrue: [^ successor nextTypeableLetter].	^ successor! !!WordGameLetterMorph methodsFor: 'linking' stamp: 'di 5/7/2000 14:19'!previousTypeableLetter	predecessor ifNil: [^ self].	predecessor isBlank ifTrue: [^ predecessor previousTypeableLetter].	^ predecessor! !!WordGameLetterMorph methodsFor: 'linking' stamp: 'dgd 2/21/2003 23:15'!startOfWord	(predecessor isNil or: [predecessor isBlank]) ifTrue: [^self].	^predecessor startOfWord! !!WordGameLetterMorph methodsFor: 'typing' stamp: 'di 5/8/2000 11:21'!unhighlight	(self isBlank or: [self color = self normalColor])		ifFalse: [self color: self normalColor]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WordGameLetterMorph class	instanceVariableNames: ''!!WordGameLetterMorph class methodsFor: 'new-morph participation' stamp: 'di 5/10/2000 07:42'!includeInNewMorphMenu	^ false! !!WordGameLetterMorph class methodsFor: 'class initialization' stamp: 'di 5/11/2000 07:15'!initialize  "WordGameLetterMorph initialize"	IDFont := StrikeFont familyName: 'ComicPlain' size: 13.	IDHeight := IDFont height.	LetterFont := StrikeFont familyName: 'ComicBold' size: 19.	LetterHeight := LetterFont height.! !BorderedMorph subclass: #WordGamePanelMorph	instanceVariableNames: 'letterMorphs haveTypedHere'	classVariableNames: ''	poolDictionaries: ''	category: 'Etoys-Squeakland-Morphic-Games'!!WordGamePanelMorph commentStamp: '<historical>' prior: 0!WordGamePanelMorph provides some default support for clicking and typing in a panel with letterMorphs.letterMorphs		a collection of LetterMorphs					Useful in referring specifically to active letterMorphs					when submorphs may contain other morphshaveTypedHere		a Boolean used to determine how backspace should be handled!!WordGamePanelMorph methodsFor: 'menus' stamp: 'di 5/9/2000 21:53'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Include our modest command set in the ctrl-menu"	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	self addMenuItemsTo: aCustomMenu hand: aHandMorph! !!WordGamePanelMorph methodsFor: 'menu' stamp: 'di 5/9/2000 22:07'!addMenuItemsTo: aCustomMenu hand: aHandMorph	"override with actual menu items"! !!WordGamePanelMorph methodsFor: 'events' stamp: 'di 5/10/2000 08:45'!checkForLostFocus	"Determine if the user has clicked outside this panel"	self activeHand ifNil: [^ self].	(self containsPoint: self activeHand position) ifFalse: [self lostFocus]! !!WordGamePanelMorph methodsFor: 'events' stamp: 'aoy 2/15/2003 21:25'!keyStrokeEvent: evt letterMorph: morph 	"Handle typing.  Calls keyCharacter:atIndex:nextFocus: for further behavior."	| affectedMorph keyCharacter nextFocus |	evt keyCharacter = Character backspace 		ifTrue: 			["<delete> zaps the current selection if there has been no typing,				but it zaps the previous selection if there has been prior typing."			affectedMorph := haveTypedHere 						ifTrue: [morph previousTypeableLetter]						ifFalse: [morph]. 			keyCharacter := Character space.			nextFocus := morph previousTypeableLetter]		ifFalse: 			[affectedMorph := morph.			keyCharacter := evt keyCharacter asUppercase.			(keyCharacter isLetter or: [keyCharacter = Character space]) 				ifFalse: [^self].			haveTypedHere := true.			nextFocus := morph nextTypeableLetter.			nextFocus == morph 				ifTrue: 					["If hit end of a word, change backspace mode"					haveTypedHere := false]].	evt hand newKeyboardFocus: nextFocus.	self unhighlight.	nextFocus color: Color green.	self 		keyCharacter: keyCharacter		atIndex: affectedMorph indexInQuote		nextFocus: nextFocus! !!WordGamePanelMorph methodsFor: 'events' stamp: 'di 5/10/2000 09:30'!mouseDownEvent: evt letterMorph: morph	haveTypedHere := false.	evt hand newKeyboardFocus: morph.	self highlight: morph! !!WordGamePanelMorph methodsFor: 'defaults' stamp: 'di 5/12/2000 00:28'!clearTyping	"Clear out all letters entered as a solution."	letterMorphs do: [:m | (m letter notNil and: [m letter isLetter])							ifTrue: [m setLetter: Character space]].	self unhighlight.! !!WordGamePanelMorph methodsFor: 'defaults' stamp: 'di 5/10/2000 09:31'!highlight: morph	self unhighlight.	morph color: Color green! !!WordGamePanelMorph methodsFor: 'defaults' stamp: 'di 5/12/2000 00:53'!isClean	"Return true only if all cells are blank."	letterMorphs do:		[:m | (m letter notNil and: [m letter ~= $ ]) ifTrue: [^ false]].	^ true! !!WordGamePanelMorph methodsFor: 'defaults' stamp: 'di 5/10/2000 08:37'!keyCharacter: keyCharacter atIndex: indexOfAffectedMorph nextFocus: nextFocus	"Override with actual response"! !!WordGamePanelMorph methodsFor: 'defaults' stamp: 'di 5/10/2000 08:44'!lostFocus	self unhighlight! !!WordGamePanelMorph methodsFor: 'defaults' stamp: 'di 5/12/2000 09:54'!unhighlight	letterMorphs do: [:m | m ifNotNil: [m unhighlight]]! !!WordGamePanelMorph methodsFor: 'event handling' stamp: 'di 5/11/2000 22:38'!handlesMouseDown: event	"Absorb mouseDown so stray clicks will not pick up the panel"	^ true! !!WordGamePanelMorph methodsFor: 'access' stamp: 'di 5/9/2000 22:27'!letterMorphs	^ letterMorphs! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WordGamePanelMorph class	instanceVariableNames: ''!!WordGamePanelMorph class methodsFor: 'new-morph participation' stamp: 'di 5/10/2000 07:41'!includeInNewMorphMenu	^ false! !WordGamePanelMorph subclass: #CipherPanel	instanceVariableNames: 'originalText quote originalMorphs decodingMorphs'	classVariableNames: ''	poolDictionaries: ''	category: 'Etoys-Squeakland-Morphic-Games'!!CipherPanel commentStamp: '<historical>' prior: 0!The CipherPanel, as its name suggests, is a tool for decoding simple substitution codes, such as are presented on the puzzle pages of many Sunday newspapers.  Most of the capability is inherited from the two WordGame classes used.  To try it out, choose newMorph/Games/CipherPanel in a morphic project, or execute, in any project:	CipherPanel new openInWorld!!CipherPanel methodsFor: 'menu' stamp: 'asm 11/25/2003 22:21'!addMenuItemsTo: aMenu hand: aHandMorph 	aMenu		add: 'show cipher help' translated		target: self		action: #showHelpWindow.	aMenu		add: 'show cipher hints' translated		target: self		action: #showHintsWindow.	aMenu		add: 'clear cipher typing' translated		target: self		action: #clearTyping.	aMenu		add: 'enter a new cipher' translated		target: self		action: #enterANewCipher.	aMenu		add: 'quote from Squeak' translated		target: self		action: #squeakCipher! !!CipherPanel methodsFor: 'menu' stamp: 'KR 3/28/2008 02:31'!buttonRow	| row aButton |	row := AlignmentMorph newRow color: self color;				 hResizing: #shrinkWrap;				 vResizing: #shrinkWrap.	#('show help' 'show hints' 'clear typing' 'enter a new cipher' 'quote from Squeak' ) translatedNoop		with: #(#showHelpWindow #showHintsWindow #clearTyping #enterANewCipher #squeakCipher )		do: [:label :selector | 			aButton := SimpleButtonMorph new target: self.			aButton color: Color transparent;				 borderWidth: 1;				 borderColor: Color black.			aButton actionSelector: selector.			aButton label: label translated.			row addMorphBack: aButton.			row addTransparentSpacerOfSize: 3 @ 0].	^ row! !!CipherPanel methodsFor: 'menu' stamp: 'di 5/8/2000 10:46'!cipherStats	| letterCounts digraphs d digraphCounts |	letterCounts := (quote copyWithout: Character space) asBag sortedCounts.	digraphs := Bag new.	quote withIndexDo:		[:c :i |		i < quote size ifTrue:			[d := quote at: i+1.			(c ~= Character space and: [d ~= Character space]) ifTrue:				[digraphs add: (String with: c with: d)]]].	digraphCounts := digraphs sortedCounts.	^ String streamContents:		[:strm |		1 to: 10 do:			[:i |			strm cr; tab; nextPut: (letterCounts at: i) value.			strm tab; print: (letterCounts at: i) key.			(digraphCounts at: i) key > 1 ifTrue:				[strm tab; tab; tab; nextPutAll: (digraphCounts at: i) value.				strm tab; print: (digraphCounts at: i) key]]]! !!CipherPanel methodsFor: 'menu' stamp: 'asm 11/25/2003 22:23'!enterANewCipher	self clearTyping;		encodedQuote: (FillInTheBlank request: 'Type a cipher text to work on here below...' translated)! !!CipherPanel methodsFor: 'menu' stamp: 'tpr 9/19/2017 18:57'!showHelpWindow	((PluggableTextMorph new setText: 'The Cipher Panel displays an encrypted message.  The encryption is a simple substitution code;  each letter of the alphabet has been changed to a different one.You can solve the cipher by clicking above any letter in the message, and typing the letter you think it should be.  The Cipher Panel automatically makes the same substitution anywhere else that letter occurs in the encoded message.If you are having trouble, you can use the command menu to ''show cipher hints''.  That will display how many of each letter occurs, which is often a help in solving ciphers.' translated )		embeddedInMorphicWindowLabeled: 'About the Cipher Panel' translated)		setWindowColor: (Color				r: 1.0				g: 0.6				b: 0.0);		 openInWorld: self world extent: 389 @ 209! !!CipherPanel methodsFor: 'menu' stamp: 'tpr 9/19/2017 18:58'!showHintsWindow	((PluggableTextMorph new setText: 'Most bodies of english text follow a general pattern of letter usage.  The following are the most common letters, in approximate order of frequency:	E  T  A  O  N  I  R  S  HThe following are the most common digraphs:	EN  ER  RE  NT  TH  ON  INThe message you are trying to decode has the following specific statistics:' translated , self cipherStats , 'Good luck!!' translated)		embeddedInMorphicWindowLabeled: 'Some Useful Statistics' translated)		setWindowColor: (Color				r: 1.0				g: 0.6				b: 0.0);		 openInWorld: self world extent: 318 @ 326! !!CipherPanel methodsFor: 'menu' stamp: 'di 10/4/2000 10:48'!squeakCipher	self encodedQuote: (CipherPanel encode: (CipherPanel randomComment))! !!CipherPanel methodsFor: 'defaults' stamp: 'asm 11/25/2003 22:22'!clearTyping	self isClean		ifTrue: [^ self].	(self confirm: 'Are you sure you want to discard all typing?' translated)		ifFalse: [^ self].	super clearTyping! !!CipherPanel methodsFor: 'defaults' stamp: 'di 5/12/2000 00:52'!keyCharacter: aLetter atIndex: indexInQuote nextFocus: nextFocus	| encodedLetter |	encodedLetter := quote at: indexInQuote.	originalMorphs with: decodingMorphs do:		[:e :d | e letter = encodedLetter ifTrue: [d setLetter: aLetter color: Color red]].! !!CipherPanel methodsFor: 'initialization' stamp: 'asm 11/25/2003 22:21'!encodedQuote: aString 	"World addMorph: CipherPanel new"	| morph prev |	aString isEmpty		ifTrue: [^ self].	(letterMorphs isNil			or: [self isClean])		ifFalse: [(self confirm: 'Are you sure you want to discard all typing?' translated)				ifFalse: [^ self]].	haveTypedHere := false.	quote := aString asUppercase.	prev := nil.	originalMorphs := quote asArray				collectWithIndex: [:c :i | WordGameLetterMorph new plain indexInQuote: i id1: nil;												setLetter: (quote at: i)].	letterMorphs := OrderedCollection new.	decodingMorphs := quote asArray				collectWithIndex: [:c :i | (quote at: i) isLetter						ifTrue: [morph := WordGameLetterMorph new underlined indexInQuote: i id1: nil.							morph								on: #mouseDown								send: #mouseDownEvent:letterMorph:								to: self.							morph								on: #keyStroke								send: #keyStrokeEvent:letterMorph:								to: self.							letterMorphs addLast: morph.							morph predecessor: prev.							prev								ifNotNil: [prev successor: morph].							prev := morph]						ifFalse: [WordGameLetterMorph new plain indexInQuote: i id1: nil;																setLetter: (quote at: i)]].	self color: originalMorphs first color.	self extent: 500 @ 500! !!CipherPanel methodsFor: 'geometry' stamp: 'di 2/14/2001 13:50'!extent: newExtent 	"Lay out with word wrap, alternating bewteen decoded and encoded lines."	"Currently not tolerant of narrow (less than a word) margins"	| w h relLoc topLeft thisWord i m corner row firstWord |	self removeAllMorphs.	w := originalMorphs first width - 1.  h := originalMorphs first height * 2 + 10.	topLeft := self position + self borderWidth + (0@10).	thisWord := OrderedCollection new.	i := 1.  firstWord := true.  relLoc := 0@0.  corner := topLeft.	[i <= originalMorphs size] whileTrue:		[m := originalMorphs at: i.		thisWord addLast: ((decodingMorphs at: i) position: topLeft + relLoc).		thisWord addLast: (m position: topLeft + relLoc + (0@m height)).		(m letter = Character space or: [i = originalMorphs size])			ifTrue: [self addAllMorphs: thisWord.					corner := corner max: thisWord last bounds bottomRight.					thisWord reset.  firstWord := false].		relLoc := relLoc + (w@0).		(relLoc x + w) > newExtent x			ifTrue: [firstWord						ifTrue: ["No spaces -- force a line break"								thisWord removeLast; removeLast.								self addAllMorphs: thisWord.								corner := corner max: thisWord last bounds bottomRight]						ifFalse: [i := i - (thisWord size//2) + 1].					thisWord reset.  firstWord := true.					relLoc := 0@(relLoc y + h)]			ifFalse: [i := i + 1]].	row := self buttonRow. row fullBounds.	self addMorph: row.	super extent: (corner - topLeft) + (self borderWidth * 2) + (0@row height+10).	row align: row bounds bottomCenter with: self bounds bottomCenter - (0@2).! !!CipherPanel methodsFor: 'parts bin' stamp: 'sw 6/28/2001 17:58'!initializeToStandAlone 	super initializeToStandAlone.	self encodedQuote: self class sampleString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CipherPanel class	instanceVariableNames: ''!!CipherPanel class methodsFor: 'parts bin' stamp: 'tak 7/25/2007 00:04'!descriptionForPartsBin	^ self partName:	'Cipher' translatedNoop		categories:		{'Games' translatedNoop}		documentation:	'The Cipher Panel: A playground for cryptograms, by Dan Ingalls' translatedNoop! !!CipherPanel class methodsFor: 'as yet unclassified' stamp: 'di 10/4/2000 10:42'!encode: aString	"CipherPanel encode: 'Now is the time for all good men to come to the aid of their country.'"	| dict repeat |	dict := Dictionary new.	repeat := true.	[repeat] whileTrue:		[repeat := false.		($A to: $Z) with: ($A to: $Z) shuffled do:			[:a :b | a = b ifTrue: [repeat := true].			dict at: a put: b]].	^ aString asUppercase collect: [:a | dict at: a ifAbsent: [a]]! !!CipherPanel class methodsFor: 'as yet unclassified' stamp: 'di 5/10/2000 10:06'!newFromQuote: encodedString	"Use this to creat new panels instead of new."	^ super new encodedQuote: encodedString! !!CipherPanel class methodsFor: 'as yet unclassified' stamp: 'asm 11/25/2003 22:20'!randomComment	"CipherPanel randomComment"	"Generate cryptic puzzles from method comments in the system"	| c s |	s := 'none'.	[s = 'none']		whileTrue: [s := ((c := SystemNavigation new allClasses atRandom) selectors						collect: [:sel | (c firstCommentAt: sel) asString])						detect: [:str | str size between: 100 and: 200]						ifNone: ['none' translated]].	^ s! !!CipherPanel class methodsFor: 'as yet unclassified' stamp: 'di 5/8/2000 11:58'!sampleString	^'E SGJC OSCVC LICGNV, ENGRCV, JEVEMAV. E SGJC OSEV QGVVEMA XMI [SMWWDHMML] ... EO''V HMALCIXKW OM SGJC VMNCOSEAR OSGO EAVQEICV GAL LIEJCV DMK. -- ZGIZIG VOICEVGAL'! !!CipherPanel class methodsFor: 'as yet unclassified' stamp: 'di 10/4/2000 10:45'!tedsHack  	"Generate cryptic puzzles from method comments in the system"	(self newFromQuote: (self encode: (self randomComment))) openInWorld"CipherPanel tedsHack"! !!CipherPanel class methodsFor: 'new-morph participation' stamp: 'di 5/10/2000 09:52'!includeInNewMorphMenu	^ true! !!CipherPanel class methodsFor: 'instance creation' stamp: 'di 5/10/2000 10:08'!new	"NOTE: Use newFromQuote: rather than new to create new CipherPanels"	^ self newFromQuote: self sampleString" Here are some other examples...World addMorph: (CipherPanel newFromQuote: 'BPFFXY LZY PK ROY RPBY PG XPAY HOYG EJCM SXJROYK FJG''R APR QCR PR''K EJC HOJ GYYF ROY LXRYMLRPJGK.  KJCMSY CGNGJHG')World addMorph: (CipherPanel newFromQuote: 'Y FRV TRK HJRH QVL QS HJL BPLRHLTH WZLRTXPLT YV ZYSL YT OQYVB MJRH WLQWZL TRK KQX FRVVQH OQ.')World addMorph: (CipherPanel newFromQuote: 'XI''H SAZRG: SDCIZCIZT EZDEAZ TD CDI SGZRIZ EGDPGZHH.')World addMorph: (CipherPanel newFromQuote: 'PY MOJ WPMMWJ MZGYR ZL MOJ GZSWH PM''R YZ RZZYJS HZYJ MOBY RBPH.')World addMorph: (CipherPanel newFromQuote: 'PYSLHYA DJP VBHHLXYAA BPY BGNBMA PLUVQ LX AQMGY; QVY HPLXSLHBG LXUPYCLYXQA BPY NBPK BXC DPLYXCGM AKLGYA.')World addMorph: (CipherPanel newFromQuote: 'U HWVS RJ AHOST RLO FOOQOST TJUSM AJIO LOVNC WUXRUSM VST HWVCUSM LVSTZVWW. -- TVNUT WORROEIVS VXROE LUA KGUSRGHWO-ZCHVAA LOVER JHOEVRUJS')"! !WordGamePanelMorph subclass: #CrosticPanel	instanceVariableNames: 'crosticPanel quotePanel cluesCol2 answers quote clues cluesPanel'	classVariableNames: ''	poolDictionaries: ''	category: 'Etoys-Squeakland-Morphic-Games'!!CrosticPanel commentStamp: '<historical>' prior: 0!The CrosticPanel, as its name suggests, is a tool for decoding acrostic puzzles, such as are presented on the puzzle pages of some Sunday newspapers.  Much of the capability is inherited from the two WordGame classes used.  To try it out, choose newMorph/Games/CrosticPanel in a morphic project, or execute, in any project:	CrosticPanel new openInWorldThe instance variables of this class include...	letterMorphs (in superclass)  a collection of all the letterMorphs in this panel	quote		a string, being the entire quote in uppercase with no blanks	clues		a collection of the clue strings	answers		a collection of the answer indices.				For each answer, this is an array of the indices into the quote string.The final structure of a CrosticPanel is as follows	self					a CrosticPanel			the overall holder		quotePanel		a CrosticQuotePanel		holds the grid of letters from the quote		cluesPanel		an AlignmentMorph		holds most of the clue rows		cluesCol2		an AlignmentMorph		holds the rest of the clue rowsEach clue row is a horizontal AlignmentMorph with a textMorph and another alignmentMorph full of the letterMorphs for the answer.!!CrosticPanel methodsFor: 'menu' stamp: 'asm 11/25/2003 22:27'!addMenuItemsTo: aMenu hand: aHandMorph 	aMenu		add: 'show crostic help' translated		target: self		action: #showHelpWindow.	aMenu		add: 'show crostic hints' translated		target: self		action: #showHintsWindow.	aMenu		add: 'show crostic errors' translated		target: self		action: #showErrors.	aMenu		add: 'clear crostic typing' translated		target: self		action: #clearTyping.	aMenu		add: 'open crostic file...' translated		target: self		action: #openFile! !!CrosticPanel methodsFor: 'menu' stamp: 'KR 3/28/2008 02:37'!buttonRow	| row aButton |	row := AlignmentMorph newRow color: self color;				 hResizing: #shrinkWrap;				 vResizing: #shrinkWrap.	#('show help' 'show errors' 'show hints' 'clear' 'open...' ) translatedNoop		with: #(#showHelpWindow #showErrors #showHintsWindow #clearTyping #openFile )		do: [:label :selector | 			aButton := SimpleButtonMorph new target: self.			aButton color: Color transparent;				 borderWidth: 1;				 borderColor: Color black.			aButton actionSelector: selector.			aButton label: label translated.			row addMorphBack: aButton.			row addTransparentSpacerOfSize: 3 @ 0].	^ row! !!CrosticPanel methodsFor: 'menu' stamp: 'tpr 3/4/2018 14:51'!openFile	| fileName crostic file |	fileName := FileChooserDialog openOn: FileDirectory default suffixList: { 'crostic' } label: 'Select a Crostic file...' translated.	fileName ifNil: [^nil].	 	file := FileStream readOnlyFileNamed: fileName.	crostic := CrosticPanel newFromFile: file.	file close.	(self isClean			or: [self confirm: 'Is it OK to discard this crostic?' translated])		ifTrue: [self world				addMorphFront: (crostic position: self position).			self delete]		ifFalse: [self world addMorphFront: crostic]! !!CrosticPanel methodsFor: 'menu' stamp: 'di 5/12/2000 15:09'!showErrors	letterMorphs do:		[:m | (m letter ~= Character space and: [m letter ~= (quote at: m indexInQuote)])			ifTrue: [m color: Color red.					(quotePanel letterMorphs at: m indexInQuote) color: Color red]]! !!CrosticPanel methodsFor: 'menu' stamp: 'tpr 9/19/2017 18:59'!showHelpWindow	((PluggableTextMorph new setText: 'The Crostic Panel presents an acrostic puzzle for solution.  As you type in answers for the clues, the letters also get entered in the text of the hidden quote.  Conversely, as you guess words in the quote, those letters will fill in missing places in your answers.  In addition, the first letters of all the answers together form the author''s name and title of the work from which the quote is taken.If you wish to make up other acrostic puzzles, follow the obvious file format in the sampleFile method.  If you wish to print an acrostic to work it on paper, then change the oldStyle method to return true, and it will properly cross-index all the cells.Have fun.' translated)		embeddedInMorphicWindowLabeled: 'About the Crostic Panel' translated)		setWindowColor: (Color				r: 1.0				g: 0.6				b: 0.0);		 openInWorld: self world extent: 409 @ 207! !!CrosticPanel methodsFor: 'menu' stamp: 'tpr 9/19/2017 18:59'!showHintsWindow	| hints |	(self confirm: 'As hints, you will be given the five longest answers.Do you really want to do this?' translated)		ifFalse: [^ self].	hints := (answers sorted: [:x :y | x size > y size]) first: 5.	((PluggableTextMorph new setText: 'The five longest answers are...' translated			, (String					streamContents: [:strm | 						hints							do: [:hint | strm cr;									nextPutAll: (hint											collect: [:i | quote at: i])].						strm cr; cr]) , 'Good luck!!' translated)		embeddedInMorphicWindowLabeled: 'Crostic Hints' translated)		setWindowColor: (Color				r: 1.0				g: 0.6				b: 0.0);		 openInWorld: self world extent: 198 @ 154! !!CrosticPanel methodsFor: 'initialization' stamp: 'di 11/25/2000 19:17'!breakColumnAndResizeWithButtons: buttonRow	| indexToSplit yToSplit |	"The column of clues has been laid out, and the crostic panel has been resized to that width and embedded as a submorph.  This method breaks the clues in two, placing the long part to the left of the crostic and the short one below it."	yToSplit := cluesPanel height + quotePanel height // 2 + self top.	indexToSplit := cluesPanel submorphs findFirst: [:m | m bottom > yToSplit].	cluesCol2 := AlignmentMorph newColumn color: self color;		hResizing: #shrinkWrap; vResizing: #shrinkWrap; layoutInset: 0;		cellPositioning: #topLeft.	cluesCol2 addAllMorphs: (cluesPanel submorphs copyFrom: indexToSplit + 1							to: cluesPanel submorphs size).	cluesPanel position: self position + self borderWidth + (0 @ 4).	quotePanel position: self position + (quotePanel width @ 0).	cluesCol2 position: self position + quotePanel extent + (0 @ 4).	self addMorph: cluesCol2.	self addMorph: buttonRow.	buttonRow align: buttonRow topLeft with: cluesCol2 bottomLeft.	self extent: 100@100; bounds: ((self fullBounds topLeft - self borderWidth asPoint)							corner: (self fullBounds bottomRight - (2@0))).! !!CrosticPanel methodsFor: 'initialization' stamp: 'di 11/28/2000 10:40'!quote: indexableQuote clues: clueStrings answers: answerIndices quotePanel: panel	| row clue answer answerMorph letterMorph prev clueText clueStyle |	quote := indexableQuote.	quotePanel := panel.	clues := clueStrings.	answers := answerIndices.	cluesPanel := AlignmentMorph newColumn color: self color;		hResizing: #shrinkWrap; vResizing: #shrinkWrap;		cellPositioning: #topLeft; layoutInset: 1.	letterMorphs := Array new: quotePanel letterMorphs size.	clueStyle := nil.	1 to: clues size do:		[:i |  clue := clues at: i.  answer := answers at: i.		row := AlignmentMorph newRow cellPositioning: #bottomLeft.		clueText := (TextMorph newBounds: (0@0 extent: 120@20) color: Color black)				string: (CrosticPanel oldStyle							ifTrue: [(($A to: $Z) at: i) asString , '.  ' , clue]							ifFalse: [clue])				fontName: 'ComicPlain' size: 13.		clueStyle ifNil: ["Make up a special style with decreased leading"						clueStyle := clueText textStyle copy.						clueStyle gridForFont: 1 withLead: -2].		clueText text: clueText asText textStyle: clueStyle.  "All clues share same style"		clueText composeToBounds.		row addMorphBack: clueText.		answerMorph := AlignmentMorph newRow layoutInset: 0.		prev := nil.		answer do:			[:n | letterMorph := WordGameLetterMorph new underlined						indexInQuote: n						id1: (CrosticPanel oldStyle ifTrue: [n printString] ifFalse: [nil]);						setLetter: Character space.			letterMorph on: #mouseDown send: #mouseDownEvent:letterMorph: to: self.			letterMorph on: #keyStroke send: #keyStrokeEvent:letterMorph: to: self.			letterMorph predecessor: prev.			prev ifNotNil: [prev successor: letterMorph].			prev := letterMorph.			letterMorphs at: n put: letterMorph.			answerMorph addMorphBack: letterMorph].		answerMorph color: answerMorph firstSubmorph color.		row addMorphBack: answerMorph.row fullBounds.		row color: answerMorph firstSubmorph color.		cluesPanel addMorphBack: row].	self addMorph: cluesPanel.	self bounds: cluesPanel fullBounds.! !!CrosticPanel methodsFor: 'defaults' stamp: 'asm 11/25/2003 22:24'!clearTyping	self isClean		ifTrue: [^ self].	(self confirm: 'Are you sure you want to discard all typing?' translated)		ifFalse: [^ self].	super clearTyping.	quotePanel clearTyping! !!CrosticPanel methodsFor: 'defaults' stamp: 'di 5/11/2000 20:44'!highlight: morph	self unhighlight.	quotePanel unhighlight.	morph startOfWord morphsInWordDo:		[:m | m color: Color lightGreen.		(quotePanel letterMorphs at: m indexInQuote) color: Color lightMagenta].	morph color: Color green.	(quotePanel letterMorphs at: morph indexInQuote) color: Color magenta.! !!CrosticPanel methodsFor: 'defaults' stamp: 'di 5/11/2000 20:44'!keyCharacter: aLetter atIndex: indexInQuote nextFocus: nextFocus	(self letterMorphs at: indexInQuote) setLetter: aLetter.	(quotePanel letterMorphs at: indexInQuote) setLetter: aLetter.	self highlight: nextFocus! !!CrosticPanel methodsFor: 'defaults' stamp: 'di 5/11/2000 20:44'!lostFocus	self unhighlight.	quotePanel unhighlight! !!CrosticPanel methodsFor: 'parts bin' stamp: 'asm 11/25/2003 22:24'!initializeToStandAlone	| aStream quoteWithBlanks indexableQuote citation clue numberLine numbers buttonRow quoteWidth |	super initializeToStandAlone.	aStream := ReadStream on: self class sampleFile.	quoteWithBlanks := aStream nextLine.	quoteWithBlanks := quoteWithBlanks asUppercase				select: [:c | c isLetter						or: [' -' includes: c]].	indexableQuote := quoteWithBlanks				select: [:c | c isLetter].	citation := aStream nextLine.	aStream nextLine.	clues := OrderedCollection new.	answers := OrderedCollection new.	[aStream atEnd]		whileFalse: [clue := aStream nextLine.			"Transcript cr; show: clue."			clues addLast: clue.			numberLine := aStream nextLine.			numbers := Scanner new scanTokens: numberLine.			answers addLast: numbers].	aStream close.	"Consistency check:"	(citation asUppercase			select: [:c | c isLetter])			= (String					withAll: (answers							collect: [:a | indexableQuote at: a first]))		ifFalse: [self error: 'mal-formed crostic file' translated].	quotePanel := CrosticQuotePanel new				quote: quoteWithBlanks				answers: answers				cluesPanel: self.	self color: quotePanel firstSubmorph color;				quote: indexableQuote		clues: clues		answers: answers		quotePanel: quotePanel.	buttonRow := self buttonRow.	quoteWidth := self width + quotePanel firstSubmorph width max: buttonRow width.	quotePanel extent: quoteWidth @ 9999.	self addMorph: quotePanel.	self breakColumnAndResizeWithButtons: buttonRow! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CrosticPanel class	instanceVariableNames: ''!!CrosticPanel class methodsFor: 'parts bin' stamp: 'tak 7/25/2007 00:04'!descriptionForPartsBin	^ self partName:	'Crostic' translatedNoop		categories:		{'Games' translatedNoop}		documentation:	'The Crostic Panel: A classic word diagram game, by Dan Ingalls' translatedNoop! !!CrosticPanel class methodsFor: 'new-morph participation' stamp: 'di 5/11/2000 20:37'!includeInNewMorphMenu	^ true! !!CrosticPanel class methodsFor: 'instance creation' stamp: 'di 5/11/2000 20:37'!new	"NOTE: Use newFromFile: rather than new to create new CrosticPanels"	^ self newFromFile: (ReadStream on: self sampleFile)! !!CrosticPanel class methodsFor: 'instance creation' stamp: 'asm 11/25/2003 22:28'!newFromFile: aStream 	"World addMorph: CrosticPanel new"	"World addMorph: (CrosticPanel newFromFile: (FileStream 	readOnlyFileNamed: 'first.crostic'))"	| quoteWithBlanks citation clue numberLine numbers clues answers indexableQuote quotePanel crosticPanel buttonRow quoteWidth |	aStream next asciiValue = 31 & (aStream next asciiValue = 139)		ifTrue: ["It's gzipped..."			aStream skip: -2.			^ self newFromFile: aStream asUnZippedStream ascii].	aStream skip: -2.	quoteWithBlanks := aStream nextLine.	quoteWithBlanks := quoteWithBlanks asUppercase				select: [:c | c isLetter						or: [' -' includes: c]].	indexableQuote := quoteWithBlanks				select: [:c | c isLetter].	citation := aStream nextLine.	aStream nextLine.	clues := OrderedCollection new.	answers := OrderedCollection new.	[aStream atEnd]		whileFalse: [clue := aStream nextLine.			"Transcript cr; show: clue."			clues addLast: clue.			numberLine := aStream nextLine.			numbers := Scanner new scanTokens: numberLine.			answers addLast: numbers].	aStream close.	"Consistency check:"	(citation asUppercase			select: [:c | c isLetter])			= (String					withAll: (answers							collect: [:a | indexableQuote at: a first]))		ifFalse: [self error: 'mal-formed crostic file' translated].	crosticPanel := super new.	quotePanel := CrosticQuotePanel new				quote: quoteWithBlanks				answers: answers				cluesPanel: crosticPanel.	crosticPanel color: quotePanel firstSubmorph color;				quote: indexableQuote		clues: clues		answers: answers		quotePanel: quotePanel.	buttonRow := crosticPanel buttonRow.	quoteWidth := crosticPanel width + quotePanel firstSubmorph width max: buttonRow width.	quotePanel extent: quoteWidth @ 9999.	crosticPanel addMorph: quotePanel.	^ crosticPanel breakColumnAndResizeWithButtons: buttonRow! !!CrosticPanel class methodsFor: 'as yet unclassified' stamp: 'di 5/12/2000 15:12'!oldStyle	"return true if we should cross-index all the cells (takes more space)."	^ false! !!CrosticPanel class methodsFor: 'as yet unclassified' stamp: 'di 11/30/2000 10:15'!sampleFile 	"If you want to enter a new acrostic, follow this format exactly with regard to CRs and the like, and store it in a file.  Do not double the string quotes as here -- that is only because they are embedded in a string.  Finally, compress the file in the fileList (so it will be easy to transport and hard to read), and name it 'yourName.crostic' so that the 'open' button on the panel will recognize it."	^'Men and women do not feel the same way about dirt.  Women for some hormonal reason can see individual dirt molecules, whereas men tend not to notice them until they join together into clumps large enough to support commercial agriculture.Dave Barry''s Guide to MarriageBoccaccio''s collection of tales74 19 175 156 9 122 84 113 104Wooden instrument of Swiss herders67 184 153 103 14 142 148 54 3Evening service76 99 154 171 89 194 69Russian-born American anarchist (2 wds)159 102 177 25 186 134 128 82 50 62 11Apple-polish (2 wds)32 190 129 126 179 157 79 170Visual-gesture means of communication4 178 27 168 150 185 114Postponed contest173 58 77 65 8 124 85Groundbreaking invention98 15 116 162 112 37 92 155 70 187Material used to make English longbows132 195 28Gracile48 191 145 152Have the effrontery; experience a high (2 wds)164 61 137 33 17 45Florentine painter who experimented with perspective91 181 189 2 20 81 167Sondheim opus (3 wds)72 109 147 13 192 165 93 40 115 138 6 63Spanish rake108 56 44 133 193 29 125Emergence  as of an adult butterfly106 149 59 41 24 135 87 68Type of rifle (hyph)111 7 143 73 39 30 105 95 53Free of charge (3 wds)176 107 120 130 160 22 46 34 94 71Pie filling86 75 136 118 43Master filmmaker31 151 174 51 163 144Longtime sportswriter for the NY Herald tribune (2 wds)60 140 12 101 55 188 166 121Birthplace of Erasmus47 64 141 21 10 180 36 80 1Mae West classic (3 wds)127 123 161 110 183 5 139 97 88Element that glows blue in the dark100 90 35 182 146 117 169 26Sturm und Drang writer158 172 119 16 52 23Starfish or sea cucumber18 66 96 83 57 49 78 131 38 42'! !WordGamePanelMorph subclass: #CrosticQuotePanel	instanceVariableNames: 'cluesPanel'	classVariableNames: ''	poolDictionaries: ''	category: 'Etoys-Squeakland-Morphic-Games'!!CrosticQuotePanel methodsFor: 'geometry' stamp: 'di 5/7/2000 11:59'!extent: newExtent	| w h nAcross relLoc topLeft |	w := self firstSubmorph width - 1.  h := self firstSubmorph height - 1.	nAcross := newExtent x - (self borderWidth-1*2)-1 // w.	topLeft := self position + self borderWidth - 1.	submorphs withIndexDo:		[:m :i | 		relLoc := (i-1 \\ nAcross * w) @ (i-1 // nAcross * h).		m position: topLeft + relLoc].	super extent: ((w * nAcross + 1) @ (submorphs size - 1 // nAcross + 1 * h+1))					+ (self borderWidth - 1 * 2).! !!CrosticQuotePanel methodsFor: 'defaults' stamp: 'di 5/11/2000 09:37'!highlight: morph	self unhighlight.	cluesPanel unhighlight.	morph startOfWord morphsInWordDo:		[:m | m color: Color lightGreen.		(cluesPanel letterMorphs at: m indexInQuote) color: Color lightMagenta].	morph color: Color green.	(cluesPanel letterMorphs at: morph indexInQuote) color: Color magenta.! !!CrosticQuotePanel methodsFor: 'defaults' stamp: 'di 5/10/2000 09:25'!keyCharacter: aLetter atIndex: indexInQuote nextFocus: nextFocus	(self letterMorphs at: indexInQuote) setLetter: aLetter.	(cluesPanel letterMorphs at: indexInQuote) setLetter: aLetter.	self highlight: nextFocus! !!CrosticQuotePanel methodsFor: 'defaults' stamp: 'di 5/10/2000 08:49'!lostFocus	self unhighlight.	cluesPanel unhighlight! !!CrosticQuotePanel methodsFor: 'initialization' stamp: 'di 5/12/2000 00:07'!quote: quoteWithBlanks answers: theAnswers cluesPanel: panel	| n morph prev clueIxs |	cluesPanel := panel.	self color: Color gray.	clueIxs := Array new: quoteWithBlanks size.	theAnswers withIndexDo: [:a :i | a do: [:j | clueIxs at: j put: i]].	letterMorphs := OrderedCollection new.	prev := nil.	self addAllMorphs: (quoteWithBlanks asArray collect:		[:c |		c isLetter			ifTrue: [n := letterMorphs size + 1.					morph := WordGameLetterMorph new boxed.					CrosticPanel oldStyle						ifTrue: [morph indexInQuote: n id1: n printString.								morph id2: (($A to: $Z) at: (clueIxs at: n)) asString]						ifFalse: [morph indexInQuote: n id1: nil].					morph setLetter: Character space.					morph on: #mouseDown send: #mouseDownEvent:letterMorph: to: self.					morph on: #keyStroke send: #keyStrokeEvent:letterMorph: to: self.					letterMorphs addLast: morph]			ifFalse: [morph := WordGameLetterMorph new boxed indexInQuote: nil id1: nil.					CrosticPanel oldStyle ifTrue: [morph extent: 26@24  "Oops"]].		morph predecessor: prev.		prev ifNotNil: [prev successor: morph].		prev := morph]).! !FreeCell initialize!PlayingCard initialize!WordGameLetterMorph initialize!