'From Cuis 5.0 [latest update: #4241] on 8 July 2020 at 2:56:53 pm'!
'Description Port of FreeCell from Squeak'!
!provides: 'Etoys-Squeakland-Morphic-Games' 1 6!
!requires: 'Cuis-Base' 50 4241 nil!
!requires: 'Graphics-Files-Additional' 1 23 nil!
!requires: 'Morphic-Misc1' 1 160 nil!
!requires: 'SqueakCompatibility' 1 31 nil!
!requires: 'Compression' 1 27 nil!
SystemOrganization addCategory: #'Etoys-Squeakland-Morphic-Games'!


!classDefinition: #PlayingCardMorph category: #'Etoys-Squeakland-Morphic-Games'!
ImageMorph subclass: #PlayingCardMorph
	instanceVariableNames: 'cardNumber suitNumber'
	classVariableNames: 'FormsArray'
	poolDictionaries: ''
	category: 'Etoys-Squeakland-Morphic-Games'!
!classDefinition: 'PlayingCardMorph class' category: #'Etoys-Squeakland-Morphic-Games'!
PlayingCardMorph class
	instanceVariableNames: ''!

!classDefinition: #FreeCell category: #'Etoys-Squeakland-Morphic-Games'!
AlignmentMorph subclass: #FreeCell
	instanceVariableNames: 'board cardsRemainingDisplay elapsedTimeDisplay gameNumberDisplay lastGameLost state autoMoveRecursionCount myFillStyle'
	classVariableNames: 'Statistics'
	poolDictionaries: ''
	category: 'Etoys-Squeakland-Morphic-Games'!
!classDefinition: 'FreeCell class' category: #'Etoys-Squeakland-Morphic-Games'!
FreeCell class
	instanceVariableNames: ''!

!classDefinition: #FreeCellBoard category: #'Etoys-Squeakland-Morphic-Games'!
AlignmentMorph subclass: #FreeCellBoard
	instanceVariableNames: 'cardDeck lastCardDeck freeCells homeCells stacks target actionSelector hardness'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Etoys-Squeakland-Morphic-Games'!
!classDefinition: 'FreeCellBoard class' category: #'Etoys-Squeakland-Morphic-Games'!
FreeCellBoard class
	instanceVariableNames: ''!

!classDefinition: #PlayingCardDeck category: #'Etoys-Squeakland-Morphic-Games'!
FramedLayoutMorph subclass: #PlayingCardDeck
	instanceVariableNames: 'layout stackingPolicy stackingOrder emptyDropPolicy target acceptCardSelector cardDroppedSelector cardDoubleClickSelector cardDraggedSelector seed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Etoys-Squeakland-Morphic-Games'!
!classDefinition: 'PlayingCardDeck class' category: #'Etoys-Squeakland-Morphic-Games'!
PlayingCardDeck class
	instanceVariableNames: ''!

!classDefinition: #FreeCellStatistics category: #'Etoys-Squeakland-Morphic-Games'!
Object subclass: #FreeCellStatistics
	instanceVariableNames: 'sessionWins sessionLosses totalWins totalLosses streakWins streakLosses winsWithReplay lossesWithReplay lastGameWon lastGameLost currentCount currentType window statsMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Etoys-Squeakland-Morphic-Games'!
!classDefinition: 'FreeCellStatistics class' category: #'Etoys-Squeakland-Morphic-Games'!
FreeCellStatistics class
	instanceVariableNames: ''!


!PlayingCardMorph commentStamp: '<historical>' prior: 0!
This class displays images from the PlayingCard class as morphs. 

FormsArray contains images originally generated by Squeak Class PlayingCard.!

!FreeCellBoard commentStamp: '<historical>' prior: 0!
The model of a freecell game.  Holds the stacks of cards.
cardDeck		
lastCardDeck		
freeCells		
homeCells		
stacks		array of CardDecks of the columns of cards.
----
Hardness: a number from 1 to 10000.  
	After dealing, count down the number.  For each count, go to next column, pick a ramdom card (with same generator as deck) and move it one place in its stack.  This is a kind of bubble sort.  Interesting that the slowness of bubble sort is a plus -- gives fine gradation in the hardness.
	Moving a card:  Move red cards to deep half, black to shallow (or vice versa).  Within a color, put low cards deep and high cards shallow.  
	If speed is an issue, move several steps at once, decrementing counter. 
	
	(May make it easier?  If running columns, need a way to make harder in other ways.)
!

!PlayingCardDeck commentStamp: '<historical>' prior: 0!
A stack or column of CardMorphs which are my submorphs!

!PlayingCardMorph class methodsFor: 'instance creation' stamp: 'KenD 7/7/2020 13:49:22'!
initializedInstance
	"Answer the Queen of Hearts"
	^ self the: 12 of: #hearts! !

!PlayingCardMorph methodsFor: 'printing' stamp: 'djp 10/17/1999 20:27'!
printOn: aStream

	aStream
		print: cardNumber;
		nextPutAll: ' of ';
		print: (self class suits at: suitNumber).! !

!PlayingCardDeck methodsFor: 'printing' stamp: 'dgd 2/22/2003 13:38'!
printOn: aStream 
	| cards |
	cards := self cards.
	aStream nextPutAll: 'aCardDeck('.
	cards size > 1 
		ifTrue: 
			[cards allButLast do: 
					[:card | 
					aStream
						print: card;
						nextPutAll: ', ']].
	cards notEmpty ifTrue: [aStream print: cards last].
	aStream nextPut: $)! !

!FreeCellStatistics methodsFor: 'printing' stamp: 'di 3/5/2000 15:22'!
printOn: aStream

	self printSessionOn: aStream.
	aStream cr.
	self printTotalOn: aStream.
	aStream cr.
	self printReplaysOn: aStream.
	aStream cr.
	self printStreaksOn: aStream.! !

!PlayingCardMorph methodsFor: 'access' stamp: 'di 10/21/1999 21:41'!
board

	^ owner owner owner! !

!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/24/1999 03:11'!
cardDeck

	^self owner! !

!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!
cardNumber
	^cardNumber! !

!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!
cardNumber: c suitNumber: s
	cardNumber := c.
	suitNumber := s.! !

!PlayingCardMorph methodsFor: 'access' stamp: 'KenD 7/7/2020 13:44:12'!
cardNumber: c suitNumber: s cardForm: aForm
	cardNumber := c.
	suitNumber := s.
	self image: aForm! !

!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!
suit
	^self class suits at: suitNumber! !

!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!
suitColor
	^#(black red red black) at: suitNumber! !

!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!
suitNumber

	^suitNumber! !

!PlayingCardMorph methodsFor: 'dropping/grabbing' stamp: 'di 12/12/2000 11:47'!
aboutToBeGrabbedBy: aHand
	"I'm about to be grabbed by the hand.  If other cards are above me in a deck,
	then move them from the deck to being submorphs of me"
	| i |
	super aboutToBeGrabbedBy: aHand.
	self removeProperty: #undoGrabCommand.  "So it won't interfere with overall move"
	self board captureStateBeforeGrab.
	i := owner submorphs indexOf: self ifAbsent: [^ self].
	i = 1 ifTrue: [^ self].
	(owner submorphs copyFrom: 1 to: i-1) do:
		[:m | m class = self class ifTrue: [self addMorphBack: m]].
! !

!PlayingCardMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 20:05'!
justDroppedInto: newOwner event: evt

	(newOwner isKindOf: PlayingCardDeck)
		ifFalse: ["Can't drop a card anywhere but on a deck"
				self rejectDropMorphEvent: evt].
	^super justDroppedInto: newOwner event: evt! !

!PlayingCardMorph methodsFor: 'dropping/grabbing' stamp: 'di 12/12/2000 14:52'!
slideBackToFormerSituation: evt

	super slideBackToFormerSituation: evt.
	self board removeProperty: #stateBeforeGrab.
	self hasSubmorphs ifTrue:
		["Just cancelled a drop of multiple cards -- have to unload submorphs"
		self submorphs reverseDo: [:m | owner addMorphFront: m]].
! !

!PlayingCardMorph methodsFor: 'event handling' stamp: 'RAA 2/12/2001 19:22'!
click: evt
	
	"since we really want to know about double-clicks before making our move, ignore this and wait until #firstClickTimedOut: arrives"! !

!PlayingCardMorph methodsFor: 'event handling' stamp: 'djp 10/24/1999 03:12'!
doubleClick: evt

	^self cardDeck doubleClickOnCard: self! !

!PlayingCardMorph methodsFor: 'event handling' stamp: 'dgd 2/22/2003 14:14'!
firstClickTimedOut: evt 
	| root popUp |
	root := owner rootForGrabOf: self.
	root isNil 
		ifTrue: 
			["Display hidden card in front"

			popUp := self copy.
			self board owner owner addMorphFront: popUp.
			self world displayWorld.
			(Delay forMilliseconds: 750) wait.
			popUp delete]
		ifFalse: [evt hand grabMorph: root]! !

!PlayingCardMorph methodsFor: 'event handling' stamp: 'di 10/19/1999 00:01'!
handlesMouseDown: evt

	^ true! !

!PlayingCardMorph methodsFor: 'event handling' stamp: 'jcg 9/21/2001 13:25'!
mouseDown: evt
	"Do nothing upon mouse-down except inform the hand to watch for a double-click; wait until an ensuing click:, doubleClick:, or drag: message gets dispatched"

	evt hand waitForClicksOrDrag: self event: evt selectors: { #click:. #doubleClick:. #firstClickTimedOut:. nil} threshold: 5! !

!PlayingCardMorph class methodsFor: 'instance creation' stamp: 'KenD 7/7/2020 13:13:43'!
the: faceNumber of: suitOrNumber
	"CardNumber is 1..13"
"
	(PlayingCardMorph the: 3 of: #spades) openInWorld.
"
	| suitNumber | 
	suitNumber :=  (suitOrNumber isNumber)
				ifTrue: [suitOrNumber]
				ifFalse: [#(clubs diamonds hearts spades) indexOf: suitOrNumber].
	^ self new cardNumber: faceNumber 
			suitNumber: suitNumber 
			cardForm: (FormsArray at: ((faceNumber - 1) * 4) + suitNumber)! !

!PlayingCardMorph class methodsFor: 'class initialization' stamp: 'KenD 7/7/2020 12:53:51'!
initialize
"
	PlayingCardMorph initialize.
"
	self initializeFromPNG! !

!PlayingCardMorph class methodsFor: 'class initialization' stamp: 'KenD 7/7/2020 12:51:39'!
initializeFromPNG
	| imageDirNamePrefix |
	FormsArray := Array new: 53.
	imageDirNamePrefix := 'SqueakCardImages/'. 
	1 to: 13 do: [ :faceNum |
		#( $c $d $h $s ) do: [ :char |	
			FormsArray 	
				at: ((faceNum - 1) * 4) + (#($c $d $h $s) indexOf: char)
				put: ((Form fromFileNamed: 
				 (imageDirNamePrefix, faceNum asString, char asString, '.png')) asFormOfDepth: 32)]].
	FormsArray 
		at: 53 
		put: ((Form fromFileNamed: (imageDirNamePrefix , 'back.png')) asFormOfDepth: 32)! !

!PlayingCardMorph class methodsFor: 'access' stamp: 'KenD 7/7/2020 13:19:46'!
cardSize

	^ (self width ) @ (self height)! !

!PlayingCardMorph class methodsFor: 'access' stamp: 'KenD 7/7/2020 13:17:06'!
height
	^ (FormsArray at: 1) height! !

!PlayingCardMorph class methodsFor: 'access' stamp: 'djp 10/15/1999 07:14'!
suits
	^ #(clubs diamonds hearts spades)! !

!PlayingCardMorph class methodsFor: 'access' stamp: 'KenD 7/7/2020 13:21:59'!
width
	 ^ (FormsArray at: 1) width! !

!FreeCell methodsFor: 'actions' stamp: 'djp 10/31/1999 21:17'!
autoMovingHome

	elapsedTimeDisplay pause.
	autoMoveRecursionCount := autoMoveRecursionCount + 1.! !

!FreeCell methodsFor: 'actions' stamp: 'djp 10/31/1999 21:35'!
boardAction: actionSymbol

	actionSymbol = #cardMovedHome 	ifTrue: [^self cardMovedHome].
	actionSymbol = #autoMovingHome	ifTrue: [^self autoMovingHome].! !

!FreeCell methodsFor: 'actions' stamp: 'di 3/5/2000 15:30'!
cardMovedHome

	cardsRemainingDisplay value: (cardsRemainingDisplay value - 1).
	autoMoveRecursionCount := autoMoveRecursionCount - 1 max: 0.
	cardsRemainingDisplay value = 0 
		ifTrue: [self gameWon]
		ifFalse: [autoMoveRecursionCount = 0 ifTrue: [elapsedTimeDisplay continue]].! !

!FreeCell methodsFor: 'actions' stamp: 'di 3/5/2000 16:20'!
gameLost

	state := #lost.
	elapsedTimeDisplay stop.
	cardsRemainingDisplay highlighted: true; flash: true.
	Statistics gameLost: self currentGame! !

!FreeCell methodsFor: 'actions' stamp: 'di 3/5/2000 16:20'!
gameWon

	state := #won.
	elapsedTimeDisplay stop; highlighted: true; flash: true.
	Statistics gameWon: self currentGame! !

!FreeCell methodsFor: 'actions' stamp: 'asm 11/24/2003 22:49'!
help
	| window helpMorph |
	window := SystemWindow labelled: 'FreeCell Help' translated.
	window model: self.
	helpMorph := (PluggableTextMorph new editString: self helpText) lock.
	window
		addMorph: helpMorph
		frame: (0 @ 0 extent: 1 @ 1).
	window openInWorld! !

!FreeCell methodsFor: 'actions' stamp: 'di 12/12/2000 13:08'!
inAutoMove
	"Return true if an automove sequence is in progress"

	^ autoMoveRecursionCount > 0! !

!FreeCell methodsFor: 'actions' stamp: 'di 1/16/2000 10:35'!
newGame
	Collection initialize.
	self newGameNumber: nil.
	state := #newGame! !

!FreeCell methodsFor: 'actions' stamp: 'di 3/5/2000 16:21'!
newGameNumber: aSeedOrNil 
	cardsRemainingDisplay value ~~ 0 ifTrue: [self gameLost].
	cardsRemainingDisplay flash: false; highlighted: false; value: 52.
	elapsedTimeDisplay flash: false; highlighted: false.
	"board handles nil case"
	self board pickGame: aSeedOrNil.
	elapsedTimeDisplay reset; start.
	gameNumberDisplay value: self currentGame! !

!FreeCell methodsFor: 'actions' stamp: 'th 12/15/1999 15:05'!
pickGame
	| seed |
	seed := self promptForSeed.
	seed isNil ifTrue: [^ self].
	self newGameNumber: seed.
	state := #pickGame! !

!FreeCell methodsFor: 'actions' stamp: 'asm 11/24/2003 22:50'!
promptForSeed
	| ss ii hh |
	[hh := board hardness
				ifNil: [0].
	ss := FillInTheBlank request: 'Pick a game number between 1 and 32000.
or
set the hardness of the next game by typing ''H 30''.
Above 100 is very hard.  Zero is standard game.
Current hardness is: ' translated , hh printString.
	"Let the user cancel."
	ss isEmpty
		ifTrue: [^ nil].
	ss := ss withoutQuoting.
	ss first asLowercase == $h
		ifTrue: ["Set the hardness"
			[ii := ss numericSuffix]
				on: Error
				do: [ii := 0].
			board hardness: ii.
			^ nil].
	[ii := ss asNumber asInteger]
		on: Error
		do: [ii := 0].
	ii between: 1 and: 32000] whileFalse.
	^ ii! !

!FreeCell methodsFor: 'actions' stamp: 'di 3/5/2000 15:35'!
quit
	cardsRemainingDisplay value ~~ 0 ifTrue: [self gameLost].

	self owner == self world
		ifTrue: [self delete]
		ifFalse: [self owner delete].
	Statistics close! !

!FreeCell methodsFor: 'actions' stamp: 'th 12/15/1999 15:03'!
sameGame
	self newGameNumber: self currentGame.
	state := #sameGame.

! !

!FreeCell methodsFor: 'actions' stamp: 'djp 10/24/1999 15:07'!
statistics

	Statistics display! !

!FreeCell methodsFor: 'accessing' stamp: 'djp 10/31/1999 19:28'!
board

	board ifNil: 
		[board := FreeCellBoard new
			target: self;
			actionSelector: #boardAction:].
	^board! !

!FreeCell methodsFor: 'accessing' stamp: 'djp 10/24/1999 21:36'!
currentGame

	^self board cardDeck seed! !

!FreeCell methodsFor: 'accessing' stamp: 'asm 11/24/2003 22:48'!
helpText
	^ 'The objective of FreeCell is to move all of the cards to the four "home cells" in the upper right corner.  Each home cell will hold one suit and must be filled sequentially starting with the Ace.

There are four "free cells" in the upper left corner that can each hold one card.  Cards can be moved from the bottom of a stack to a free cell or to another stack.  

When moving a card to another stack, it must have a value that is one less than the exposed card and of a different color.' translated! !

!FreeCell methodsFor: 'private' stamp: 'KenD 7/8/2020 14:54:11'!
buildButton: aButton target: aTarget label: aLabel selector: aSelector
	"wrap a button or switch in an alignmentMorph to provide some space around the button"

"	| a |"
	aButton 
		model: aTarget;
		label: aLabel;
		action: aSelector;
		"borderStyle: (BorderStyle raised width: 2);"
		color: Color gray.
"	a := AlignmentMorph newColumn
		wrapCentering: #center; cellPositioning: #topCenter;
		hResizing: #shrinkWrap;
		vResizing: #shrinkWrap;
		color: Color transparent;
		layoutInset: 1.
	a addMorph: aButton."
	"@@@ ??LayoutSpec?? @@@"
	^ aButton


! !

!FreeCell methodsFor: 'private' stamp: 'ar 11/9/2000 21:17'!
wrapPanel: anLedPanel label: aLabel
	"wrap an LED panel in an alignmentMorph with a label to its left"

	| a |
	a := AlignmentMorph newRow
		wrapCentering: #center; cellPositioning: #leftCenter;
		hResizing: #shrinkWrap;
		vResizing: #shrinkWrap;
		borderWidth: 0;
		layoutInset: 5;
		color: Color transparent.
	a addMorph: anLedPanel.
	a addMorph: (StringMorph contents: aLabel). 
	^ a
! !

!FreeCell methodsFor: 'visual properties' stamp: 'RAA 3/3/2000 23:28'!
colorNearBottom

	^Color r: 0.0 g: 0.455 b: 0.18! !

!FreeCell methodsFor: 'visual properties' stamp: 'RAA 3/4/2000 10:26'!
colorNearTop

	^ (Color r: 0.304 g: 0.833 b: 0.075)! !

!FreeCell methodsFor: 'visual properties' stamp: 'RAA 3/4/2000 17:01'!
fillStyle

	myFillStyle ifNil: [
		myFillStyle := GradientFillStyle ramp: {
			0.0 -> self colorNearTop. 
			1.0 -> self colorNearBottom
		}.
	].
	^myFillStyle
		origin: self position;
		direction: (self width // 2)@self height
! !

!FreeCell methodsFor: 'user interface' stamp: 'RAA 3/3/2000 23:29'!
defaultBackgroundColor

	^Color r: 0.365 g: 1.0 b: 0.09! !

!FreeCell methodsFor: 'user interface' stamp: 'th 12/15/1999 15:20'!
modelSleep
	"When fixing #contains: calls beware of reinventing #includes:"
	(#(newGame sameGame pickGame won lost ) includes: state)
		ifTrue: [elapsedTimeDisplay pause]! !

!FreeCell methodsFor: 'user interface' stamp: 'th 12/15/1999 15:22'!
modelWakeUp
	"Maybe less performant but more readable"
	(#(won lost) includes: state)
		ifFalse: [elapsedTimeDisplay resume]! !

!FreeCell methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:27'!
defaultBorderWidth
	"answer the default border width for the receiver"
	^ 2! !

!FreeCell methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:26'!
defaultColor
	"answer the default color/fill style for the receiver"
	^ self colorNearTop! !

!FreeCell methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:27'!
initialize
	"initialize the state of the receiver"
	super initialize.
	""
	Statistics newSession.
	autoMoveRecursionCount := 0.
	self listDirection: #topToBottom.
	self wrapCentering: #center;
		 cellPositioning: #topCenter.
	self vResizing: #shrinkWrap.
	self hResizing: #shrinkWrap.
	self
		 addMorph: self makeControls;
		 addMorph: self board;
		 newGame! !

!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:47'!
makeCardsRemainingDisplay
	cardsRemainingDisplay := LedMorph new digits: 2;
				 extent: 2 * 10 @ 15.
	^ self wrapPanel: cardsRemainingDisplay label: 'Cards Left: ' translated! !

!FreeCell methodsFor: 'initialization' stamp: 'mt 4/10/2018 10:58'!
makeControlBar

	^AlignmentMorph newRow
		color: self colorNearBottom;
		borderStyle: (BorderStyle inset width: 2);
		layoutInset: 0;
		hResizing: #spaceFill; vResizing: #shrinkWrap; wrapCentering: #center; cellPositioning: #leftCenter;
		yourself.! !

!FreeCell methodsFor: 'initialization' stamp: 'djp 10/24/1999 14:38'!
makeControls

	^self makeControlBar
		addMorph: AlignmentMorph newVariableTransparentSpacer;
		addMorph: self makeHelpButton;
		addMorph: self makeQuitButton;
		addMorph: self makeStatisticsButton;
		addMorph: self makeGameNumberDisplay;
		addMorph: self makePickGameButton;
		addMorph: self makeSameGameButton;
		addMorph: self makeNewGameButton;
		addMorph: self makeElapsedTimeDisplay;
		addMorph: self makeCardsRemainingDisplay;
		yourself.! !

!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:47'!
makeElapsedTimeDisplay
	elapsedTimeDisplay := LedTimerMorph new digits: 3;
				 extent: 3 * 10 @ 15.
	^ self wrapPanel: elapsedTimeDisplay label: 'Elapsed Time: ' translated! !

!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:47'!
makeGameNumberDisplay
	gameNumberDisplay := LedMorph new digits: 5;
				 extent: 5 * 10 @ 15.
	^ self wrapPanel: gameNumberDisplay label: 'Game #: ' translated! !

!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:47'!
makeHelpButton
	^ self
		buildButton: SimpleButtonMorph new
		target: self
		label: 'Help' translated
		selector: #help! !

!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:47'!
makeNewGameButton
	^ self
		buildButton: SimpleButtonMorph new
		target: self
		label: 'New game' translated
		selector: #newGame! !

!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:47'!
makePickGameButton
	^ self
		buildButton: SimpleButtonMorph new
		target: self
		label: 'Pick game' translated
		selector: #pickGame! !

!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:48'!
makeQuitButton
	^ self
		buildButton: SimpleButtonMorph new
		target: self
		label: 'Quit' translated
		selector: #quit! !

!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:48'!
makeSameGameButton
	^ self
		buildButton: SimpleButtonMorph new
		target: self
		label: 'Same game' translated
		selector: #sameGame! !

!FreeCell methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:48'!
makeStatisticsButton
	^ self
		buildButton: SimpleButtonMorph new
		target: self
		label: 'Statistics' translated
		selector: #statistics! !

!FreeCell methodsFor: 'initialization' stamp: 'djp 10/31/1999 18:48'!
openInWindowLabeled: aString inWorld: aWorld

	^(super openInWindowLabeled: aString inWorld: aWorld)
		model: self;
		yourself! !

!FreeCell class methodsFor: 'class initialization' stamp: 'djp 10/24/1999 14:50'!
initialize

	Statistics := FreeCellStatistics new.! !

!FreeCellBoard methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:27'!
defaultColor
	"answer the default color/fill style for the receiver"
	^ Color green! !

!FreeCellBoard methodsFor: 'initialization' stamp: 'KenD 7/8/2020 14:14:49'!
initialize
	"initialize the state of the receiver"
	super initialize.
	""
"	self listDirection: #topToBottom;
	  hResizing: #shrinkWrap;
	  vResizing: #rigid;
	  height: 500;
	  layout
"
	self morphHeight: 500! !

!FreeCellBoard methodsFor: 'initialization' stamp: 'ul 3/13/2017 00:18'!
pickGame: aSeedOrNil 
	| sorted msg |
	cardDeck := PlayingCardDeck newDeck.
	aSeedOrNil == 1
		ifTrue: ["Special case of game 1 does a time profile playing the entire 
			(trivial) game."
			sorted := cardDeck submorphs
						sorted: [:a :b | a cardNumber >= b cardNumber].
			cardDeck removeAllMorphs; addAllMorphs: sorted.
			self resetBoard.
			self world doOneCycle.
			Utilities
				informUser: 'Game #1 is a special case
for performance analysis' translated
				during: [msg := self world firstSubmorph.
					msg align: msg topRight with: owner bottomRight.
					MessageTally
						spyOn: [sorted last owner doubleClickOnCard: sorted last]]]
		ifFalse: [aSeedOrNil
				ifNotNil: [cardDeck seed: aSeedOrNil].
			cardDeck shuffle.
			self resetBoard]! !

!FreeCellBoard methodsFor: 'initialization' stamp: 'tk 3/30/2001 12:20'!
resetBoard

	self purgeAllCommands.
	self resetFreeCells;
		resetHomeCells;
		resetStacks;
		addHardness;
		changed.! !

!FreeCellBoard methodsFor: 'initialization' stamp: 'djp 10/16/1999 20:06'!
resetFreeCells

	freeCells do: [:deck | deck removeAllCards]! !

!FreeCellBoard methodsFor: 'initialization' stamp: 'djp 10/16/1999 20:06'!
resetHomeCells

	homeCells do: [:deck | deck removeAllCards]! !

!FreeCellBoard methodsFor: 'initialization' stamp: 'djp 10/16/1999 20:06'!
resetStacks
	| card stackStream stack |

	stacks do: [:deck | deck removeAllCards].
	stackStream := ReadStream on: stacks.
	[card := cardDeck deal.
	card notNil] whileTrue: [
		stack := stackStream next ifNil: [stackStream reset; next].
		stack addCard: card].
! !

!FreeCellBoard methodsFor: 'drawing' stamp: 'RAA 3/4/2000 17:02'!
drawOn: aCanvas

	"we don't have anything to draw, but we need a color so the inset border of one of our submorphs will work"
! !

!FreeCellBoard methodsFor: 'card in a stack' stamp: 'KenD 7/8/2020 14:16:40'!
stack
	^ PlayingCardDeck newRow color: Color transparent;
	 layout: #stagger;
	 listDirection: #topToBottom;
	 enableDragNDrop;
	 stackingPolicy: #altStraight;
	 stackingOrder: #descending;
	 emptyDropPolicy: #any;
	 target: self;
	 cardDroppedSelector: #cardMoved;
	 cardDraggedSelector: #dragCard:fromStack:;
	 acceptCardSelector: #acceptCard:onStack:;
	 cardDoubleClickSelector: #doubleClickInStack:OnCard:! !

!FreeCellBoard methodsFor: 'undo' stamp: 'di 12/12/2000 11:54'!
captureStateBeforeGrab

	self removeProperty: #stateBeforeGrab.
	self setProperty: #stateBeforeGrab toValue: self capturedState
! !

!FreeCellBoard methodsFor: 'undo' stamp: 'di 12/12/2000 11:50'!
capturedState

	self valueOfProperty: #stateBeforeGrab ifPresentDo: [:st | ^ st].
	^ {	freeCells collect: [:deck | deck submorphs].
		homeCells collect: [:deck | deck submorphs].
		stacks collect: [:deck | deck submorphs] }
! !

!FreeCellBoard methodsFor: 'undo' stamp: 'di 12/12/2000 12:14'!
rememberUndoableAction: aBlock named: caption

	self inAutoMove ifTrue: [^ aBlock value].
	^ super rememberUndoableAction: aBlock named: caption! !

!FreeCellBoard methodsFor: 'undo' stamp: 'di 12/12/2000 08:12'!
undoFromCapturedState: st
	freeCells with: st first do: [:deck :morphs | deck removeAllMorphs; addAllMorphs: morphs].
	homeCells with: st second do: [:deck :morphs | deck removeAllMorphs; addAllMorphs: morphs].
	stacks with: st third do: [:deck :morphs | deck removeAllMorphs; addAllMorphs: morphs]! !

!FreeCellBoard methodsFor: 'private' stamp: 'RAA 3/4/2000 10:48'!
autoMoveCardsHome
	| first |

	first := false.
	(self stacks, self freeCells) do: [:deck |
		self homeCells do: [ :homeCell |
			deck hasCards ifTrue: [
				(homeCell repelCard: deck topCard) ifFalse: [
					(self isPlayableCardInHomeCells: deck topCard) ifTrue: [
						first ifFalse: [ " trigger autoMoving event on first move."
							first := true.
							self performActionSelector: #autoMovingHome
						].
						self visiblyMove: deck topCard to: homeCell.
					]
				]
			]
		]
	].

! !

!FreeCellBoard methodsFor: 'private' stamp: 'RAA 3/4/2000 17:11'!
isPlayableCardInHomeCells: aPlayingCard
	| unplayedOther topsThisColor topsOtherColor unplayedSame | 
	" are all cards that could be played on this card if it stayed on the stack present in the
	home cells?"

	aPlayingCard cardNumber <= 2 ifTrue: [^true].	"special case for Aces and 2's"
	topsThisColor := OrderedCollection new.
	topsOtherColor := OrderedCollection new.
	self homeCells do: [ :deck |
		deck hasCards ifTrue: [
			(aPlayingCard suitColor == deck topCard suitColor 
					ifTrue: [topsThisColor] ifFalse: [topsOtherColor]) add: deck topCard cardNumber.
		]
	].
	unplayedOther := topsOtherColor size < 2 ifTrue: [1] ifFalse: [topsOtherColor min + 1].
	unplayedSame := topsThisColor size < 2 ifTrue: [1] ifFalse: [topsThisColor min + 1].
	unplayedOther > (aPlayingCard cardNumber - 1) ifTrue: [^true].
	unplayedOther < (aPlayingCard cardNumber - 1) ifTrue: [^false].
	^unplayedSame >= (unplayedOther - 1)
! !

!FreeCellBoard methodsFor: 'private' stamp: 'djp 10/24/1999 00:50'!
maxDraggableStackSize: dropIntoEmptyStack
	"Note: dropIntoEmptyStack, means one less empty stack to work with.
		This needs to be reevaluated at time of drop."
	"Not super smart - doesn't use stacks that are buildable though not empty"

	| nFree nEmptyStacks |
	nFree := (freeCells select: [:d | d hasCards not]) size.
	nEmptyStacks := (stacks select: [:d | d hasCards not]) size.
	dropIntoEmptyStack ifTrue: [nEmptyStacks := nEmptyStacks - 1].
	^ (1 + nFree) * (2 raisedTo: nEmptyStacks)! !

!FreeCellBoard methodsFor: 'private' stamp: 'dgd 2/22/2003 18:45'!
performActionSelector: actionSymbol 
	(target notNil and: [actionSelector notNil]) 
		ifTrue: [target perform: actionSelector with: actionSymbol]! !

!FreeCellBoard methodsFor: 'private' stamp: 'di 12/12/2000 13:09'!
visiblyMove: aCard to: aCell
	| p1 p2 nSteps |
	self inAutoMove ifFalse: [self captureStateBeforeGrab].
	owner owner addMorphFront: aCard.
	p1 := aCard position.
	p2 := aCell position.
	nSteps := 10.
	1 to: nSteps-1 do: "Note final step happens with actual drop"
		[:i | aCard position: ((p2*i) + (p1*(nSteps-i))) // nSteps.
		self world displayWorld].
	aCell acceptDroppingMorph: aCard event: nil! !

!FreeCellBoard methodsFor: 'hardness' stamp: 'tk 3/30/2001 11:53'!
addHardness
	| cnt rand pileInd pile |
	"post process the layout of cards to make it harder.  See class comment."

	hardness ifNil: [^ self].
	cnt := hardness.
	rand := Random new seed: cardDeck seed.  "Same numbers but different purpose"
	pileInd := 1. 
	[(cnt := cnt - 1) > 0] whileTrue: [
		pile := stacks atWrap: (pileInd := pileInd + 1).
		cnt := cnt - (self makeHarder: pile rand: rand toDo: cnt)].  "mostly 0, but moves cards"! !

!FreeCellBoard methodsFor: 'hardness' stamp: 'tk 3/30/2001 12:22'!
makeHarder: pile rand: rand toDo: cnt
	| deepColor ind thisPile thisCard otherCard |
	"Move cards in a stack to make it harder.  Pick a card from the pile.  Only consider moving it deeper (toward last of pile)."

	deepColor := stacks first cards last suitColor.
	ind := ((pile cards size - 1) atRandom: rand).	"front card"
	thisPile := pile cards.  "submorphs array. We will stomp it."
	thisCard := thisPile at: ind.
	otherCard := thisPile at: ind+1.

	"Move deepColor cards deeper, past cards of the other color"
	(thisCard suitColor == deepColor) & (otherCard suitColor ~~ deepColor) ifTrue: [
		thisPile at: ind put: otherCard.
		thisPile at: ind+1 put: thisCard.
		^ 0].	"single moves for now.  Make multiple when it's too slow this way"

	"When colors the same, move low numbered cards deeper, past high cards"
	(thisCard suitColor == otherCard suitColor) ifTrue: [
		(thisCard cardNumber < otherCard cardNumber) ifTrue: [
			thisPile at: ind put: otherCard.
			thisPile at: ind+1 put: thisCard.
			^ 0]].	"single moves for now.  Make multiple when it's too slow this way"
	^ 0! !

!FreeCellBoard methodsFor: 'accessing' stamp: 'djp 10/16/1999 16:21'!
actionSelector: aSymbolOrString

	(nil = aSymbolOrString or:
	 ['nil' = aSymbolOrString or:
	 [aSymbolOrString isEmpty]])
		ifTrue: [^ actionSelector := nil].

	actionSelector := aSymbolOrString asSymbol.
! !

!FreeCellBoard methodsFor: 'accessing' stamp: 'djp 10/11/1999 15:51'!
cardDeck
	^cardDeck! !

!FreeCellBoard methodsFor: 'accessing' stamp: 'tk 3/30/2001 13:08'!
hardness
	^ hardness! !

!FreeCellBoard methodsFor: 'accessing' stamp: 'tk 3/30/2001 13:08'!
hardness: integer
	hardness := integer	"or nil"! !

!FreeCellBoard methodsFor: 'accessing' stamp: 'djp 10/16/1999 15:33'!
target: anObject

	target := anObject! !

!FreeCellBoard methodsFor: 'actions' stamp: 'th 12/9/1999 19:10'!
acceptCard: aCard onStack: aDeck
	" assumes that number of cards was check at drag time, need to reduce count if dropping
	into an empty stack"
	aCard hasSubmorphs 
		ifTrue: [
			aDeck ifEmpty: [
				(aCard submorphCount+1) > (self maxDraggableStackSize: true)
					ifTrue: [^false]]]
		ifFalse: [^ nil].
	^nil.

! !

!FreeCellBoard methodsFor: 'actions' stamp: 'th 12/15/1999 16:17'!
acceptSingleCard: aCard on: aDeck 
	"Home cells and free cells don't accept multiple cards on a home cell, 
	defer to deck for other cases"
	aCard hasSubmorphs
		ifTrue: [^ false]
		ifFalse: [^ nil]! !

!FreeCellBoard methodsFor: 'actions' stamp: 'th 12/15/1999 16:15'!
cardMoved
	"Free cells and stacks do nothing special here - yet - th 12/15/1999 
	16:15 "
	self autoMoveCardsHome! !

!FreeCellBoard methodsFor: 'actions' stamp: 'djp 10/31/1999 22:02'!
cardMovedHome

	self autoMoveCardsHome.
	self performActionSelector: #cardMovedHome.! !

!FreeCellBoard methodsFor: 'actions' stamp: 'RAA 3/4/2000 17:07'!
doubleClickInStack: aDeck OnCard: aCard

	"if there is an empty free cell, move the card there. otherwise try for an empty stack"

	aCard == aDeck topCard ifFalse: [^self].
	freeCells do: [:freeCell |
		freeCell ifEmpty: [
			self visiblyMove: aCard to: freeCell.
			^ aCard
		]
	].
	stacks do: [ :each |
		each ifEmpty: [
			self visiblyMove: aCard to: each.
			^ aCard
		]
	].
! !

!FreeCellBoard methodsFor: 'actions' stamp: 'djp 10/24/1999 03:08'!
dragCard: aCard fromHome: aCardDeck

	^nil		"don't allow any cards to be dragged from a home cell"! !

!FreeCellBoard methodsFor: 'actions' stamp: 'djp 10/24/1999 00:46'!
dragCard: aCard fromStack: aCardDeck
	| i cards |

	cards := aCardDeck cards.
	i := cards indexOf: aCard ifAbsent: [^ nil].
	i > (self maxDraggableStackSize: false) ifTrue: [^ nil].
	[i > 1] whileTrue:
		[(aCardDeck inStackingOrder: (cards at: i-1) 
					onTopOf: (cards at: i)) ifFalse: [^ nil].
		i := i-1].
	^ aCard! !

!FreeCellBoard methodsFor: 'actions' stamp: 'di 12/12/2000 13:08'!
inAutoMove
	"Return true if an automove sequence is in progress"

	^ owner inAutoMove! !

!FreeCellBoard methodsFor: 'layout' stamp: 'ar 11/20/2000 19:08'!
cardCell

	^PlayingCardDeck new
		layout: #pile; 
		listDirection: #topToBottom;
		enableDragNDrop;
		color: Color transparent;
		borderColor: (Color gray alpha: 0.5);
		borderWidth: 2;
		layoutBounds: (0@0 extent: PlayingCardMorph width @ PlayingCardMorph height);
		yourself! !

!FreeCellBoard methodsFor: 'layout' stamp: 'RAA 3/3/2000 23:33'!
cellsRow
	| row |

	row := (AlignmentMorph newRow)
		vResizing: #shrinkWrap;
		hResizing: #shrinkWrap;
		color: Color transparent;
		addAllMorphs: self freeCells;
		addMorphBack: self cellsRowSpacer;
		addAllMorphs: self homeCells;
		yourself.
	^row! !

!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/17/1999 18:25'!
cellsRowSpacer
	| column |

	column := (AlignmentMorph newColumn)
		vResizing: #rigid;
		hResizing: #rigid;
		color: Color transparent;
		extent: PlayingCardMorph cardSize;
		yourself.
	^column! !

!FreeCellBoard methodsFor: 'layout' stamp: 'th 12/15/1999 16:14'!
freeCell
	| freeCell |
	freeCell := self cardCell.
	freeCell stackingPolicy: #single;
	 emptyDropPolicy: #any;
	 target: self;
	 cardDroppedSelector: #cardMoved;
	 acceptCardSelector: #acceptSingleCard:on:.
	^ freeCell! !

!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/11/1999 16:41'!
freeCells

	^freeCells ifNil: [freeCells := (1 to: 4) collect: [:i | self freeCell]]! !

!FreeCellBoard methodsFor: 'layout' stamp: 'th 12/15/1999 16:12'!
homeCell
	| homeCell |
	homeCell := self cardCell.
	homeCell stackingPolicy: #straight;
	 stackingOrder: #ascending;
	 emptyDropPolicy: #inOrder;
	 target: self;
	 cardDroppedSelector: #cardMovedHome;
	 cardDraggedSelector: #dragCard:fromHome:;
	 acceptCardSelector: #acceptSingleCard:on:.
	^ homeCell! !

!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/11/1999 16:41'!
homeCells

	^homeCells ifNil: [homeCells := (1 to: 4) collect: [:i | self homeCell]]! !

!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/11/1999 18:27'!
layout

	self 
		addMorphBack: self cellsRow;
		addMorphBack: self stacksRow.
! !

!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/11/1999 16:41'!
stacks

	^stacks ifNil: [stacks:= (1 to: 8) collect: [:i | self stack]]! !

!FreeCellBoard methodsFor: 'layout' stamp: 'ar 11/20/2000 18:58'!
stacksRow
	| row |

	row := (AlignmentMorph newRow)
		vResizing: #spaceFill;
		hResizing: #spaceFill;
		wrapCentering: #topLeft;
		cellPositioning: #topLeft;
		color: Color transparent;
		yourself.
	self stacks do: [:stack |
		row 
			addMorphBack: AlignmentMorph newVariableTransparentSpacer;
			addMorphBack: stack].
	row addMorphBack: AlignmentMorph newVariableTransparentSpacer.
	^row! !

!FreeCellBoard class methodsFor: 'new-morph participation' stamp: 'KenD 7/8/2020 13:53:07'!
includeInNewMorphMenu

	^false! !

!PlayingCardDeck methodsFor: 'initialization' stamp: 'KenD 7/7/2020 14:15:39'!
initialize
	super initialize.
	"self cellPositioning: #topLeft."
	"self reverseTableCells: true."
	self layout: #grid.
	"self hResizing: #shrinkWrap.
	self vResizing: #shrinkWrap."
	self borderWidth: 0.
	"self layoutInset: 0."
	stackingPolicy := #stagger.
	stackingOrder := #ascending.
	emptyDropPolicy := #any.
	self newSeed.
	^self! !

!PlayingCardDeck methodsFor: 'initialization' stamp: 'djp 10/17/1999 18:25'!
newDeck
	| cards |
	cards := OrderedCollection new: 52.
	PlayingCardMorph suits 
		do: [:suit | 1 to: 13
			do: [:cardNo | cards add: (PlayingCardMorph the: cardNo of: suit)]].
	self addAllMorphs: cards.
	^self! !

!PlayingCardDeck methodsFor: 'initialization' stamp: 'djp 10/17/1999 18:25'!
newSuit: suit
	| cards |
	cards := OrderedCollection new: 13.
	1 to: 13 do: [:cardNo | cards add: (PlayingCardMorph the: cardNo of: suit)].
	self addAllMorphs: cards.
	^self! !

!PlayingCardDeck methodsFor: 'testing' stamp: 'KenD 7/8/2020 14:09:25'!
hasCards

	^self hasSubmorphs! !

!PlayingCardDeck methodsFor: 'testing' stamp: 'KenD 7/8/2020 14:10:21'!
isEmpty

	^ (submorphs size = 0)! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 01:40'!
acceptCardSelector: aSymbolOrString

	acceptCardSelector := self nilOrSymbol: aSymbolOrString.! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'KenD 7/8/2020 14:08:45'!
addCard: aPlayingCard

	| newPos |
	(self hasCards not)
		ifTrue: [newPos := 0 @ 0]
		ifFalse: [newPos := (0 @ (self pixelsPerOverlap * self numberOfCards))].
	self addMorph: aPlayingCard.
	aPlayingCard morphPosition: newPos.
	self! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 03:13'!
cardDoubleClickSelector: aSymbolOrString

	cardDoubleClickSelector := self nilOrSymbol: aSymbolOrString.! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 01:39'!
cardDraggedSelector: aSymbolOrString

	cardDraggedSelector := self nilOrSymbol: aSymbolOrString.! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 17:27'!
cardDroppedSelector: aSymbolOrString

	cardDroppedSelector := self nilOrSymbol: aSymbolOrString.! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/15/1999 10:46'!
cards

	^submorphs! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 13:18'!
emptyDropPolicy: aSymbol
	"#any #inOrder #anyClub #anyDiamond #anyHeart #anySpade"

	emptyDropPolicy := aSymbol! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'KenD 7/7/2020 14:18:04'!
layout: aSymbol
	" #grid #pile #stagger"
	layout := aSymbol.
	"@@FIXME: Adjust Layout Mechanics @@"
"	layout == #grid 
		ifTrue:[self maxCellSize: SmallInteger maxVal].
	layout == #pile 
		ifTrue:[self maxCellSize: 0].
	layout == #stagger 
		ifTrue:[self maxCellSize: self staggerOffset].
"! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/23/1999 22:44'!
newSeed
	seed := (1 to: 32000) atRandom! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 20:05'!
removeAllCards
	self removeAllMorphs! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/23/1999 22:22'!
seed
	
	^seed! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/23/1999 22:21'!
seed: anInteger
	
	seed := anInteger! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/15/1999 16:39'!
stackingOrder: aSymbol
	"#ascending #descending"

	stackingOrder := aSymbol! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 00:08'!
stackingPolicy

	^ stackingPolicy! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 00:08'!
stackingPolicy: aSymbol
	"#straight #altStraight #single #none"

	stackingPolicy := aSymbol! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 20:20'!
subDeckStartingAt: aCard
	| i subDeck |

	i := submorphs indexOf: aCard ifAbsent: [^ aCard].
	i = 1 ifTrue: [^aCard].
	subDeck := PlayingCardDeck new.
	(submorphs copyFrom: 1 to: i-1) do:
			[:m | m class = aCard class ifTrue: [subDeck addMorphBack: m]].
	^subDeck.
	! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 17:21'!
target: anObject

	target := anObject! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 19:24'!
topCard

	^self firstSubmorph! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'th 12/10/1999 16:07'!
acceptCard: aCard default: aBoolean 
	"if target and acceptCardSelector are both not nil, send to target, if not  
	nil answer  
	else answer aBoolean"
	"Rewrote this a little (SmallLint calls this 'intention revealing')-th"
	^ (target isNil or: [acceptCardSelector isNil])
		ifTrue: [aBoolean]
		ifFalse: [(target
				perform: acceptCardSelector
				with: aCard
				with: self)
				ifNil: [aBoolean]]! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/16/1999 13:14'!
emptyDropNotOk: aPlayingCard

	^(self emptyDropOk: aPlayingCard) not! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/16/1999 13:15'!
emptyDropOk: aPlayingCard

	emptyDropPolicy = #any 			ifTrue: [^true].
	emptyDropPolicy = #inOrder			ifTrue: [^self inStackingOrder: aPlayingCard].
	emptyDropPolicy = #anyClub 		ifTrue: [^aPlayingCard suit = #club].
	emptyDropPolicy = #anyDiamond		ifTrue: [^aPlayingCard suit = #diamond].
	emptyDropPolicy = #anyHeart		ifTrue: [^aPlayingCard suit = #heart].
	emptyDropPolicy = #anySpade		ifTrue: [^aPlayingCard suit = #spade].! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/16/1999 13:10'!
ifEmpty: aBlock

	self hasSubmorphs not ifTrue: [^aBlock value]! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/24/1999 02:17'!
ifEmpty: aBlock1 ifNotEmpty: aBlock2

	self hasSubmorphs not 
		ifTrue: [^aBlock1 value]
		ifFalse: [^aBlock2 value]! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/16/1999 21:54'!
inStackingOrder: aPlayingCard

	^self inStackingOrder: aPlayingCard event: nil! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'di 10/19/1999 15:45'!
inStackingOrder: aCard event: evt

	self hasSubmorphs 
		ifTrue: [^ self inStackingOrder: aCard onTopOf: self topCard]
		ifFalse: [stackingOrder = #ascending ifTrue: [^ aCard cardNumber = 1].
				stackingOrder = #descending ifTrue: [^ aCard cardNumber = 13]].
	^ false.! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'di 10/21/1999 22:03'!
inStackingOrder: aCard onTopOf: cardBelow
	| diff |
	(stackingPolicy = #altStraight and: [aCard suitColor = cardBelow suitColor]) ifTrue: [^ false].
	(stackingPolicy = #straight and: [aCard suit ~= cardBelow suit]) ifTrue: [^ false].
	diff := aCard cardNumber - cardBelow cardNumber.
	stackingOrder = #ascending 	ifTrue: [^ diff = 1].
	stackingOrder = #descending	ifTrue: [^ diff = -1].
	^ false.! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/15/1999 12:43'!
insertionIndexFor: aMorph
	"Return the index at which the given morph should be inserted into the submorphs of the receiver."

	^1! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'th 12/10/1999 18:34'!
repelCard: aCard 
	stackingPolicy = #none ifTrue: [^ self repelCard: aCard default: true].
	stackingPolicy = #single ifTrue: [^ self ifEmpty: [self repelCard: aCard default: false]
			ifNotEmpty: [true]].
	(stackingPolicy = #altStraight or: [stackingPolicy = #straight])
		ifTrue: [self ifEmpty: [^ self repelCard: aCard default: (self emptyDropNotOk: aCard)]
				ifNotEmpty: [(self inStackingOrder: aCard onTopOf: self topCard)
						ifFalse: [^ self repelCard: aCard default: true]]].
	^ false! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/24/1999 04:09'!
repelCard: aCard default: aBoolean
	
	^(self acceptCard: aCard default: aBoolean not) not! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/24/1999 02:20'!
repelsMorph: aMorph event: evt

	(aMorph isKindOf: PlayingCardMorph) 
		ifTrue: [^self repelCard: aMorph]
		ifFalse: [^true]! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'dgd 2/22/2003 18:49'!
rootForGrabOf: aCard 
	self hasSubmorphs ifFalse: [^nil].
	(target notNil and: [cardDraggedSelector notNil]) 
		ifTrue: 
			[^target 
				perform: cardDraggedSelector
				with: aCard
				with: self]
		ifFalse: [^self firstSubmorph]! !

!PlayingCardDeck methodsFor: 'layout' stamp: 'asm 11/25/2003 22:37'!
acceptDroppingMorph: aMorph event: evt 
	target
		rememberUndoableAction: [target inAutoMove
				ifFalse: [target removeProperty: #stateBeforeGrab].
			self addMorph: aMorph.
			aMorph hasSubmorphs
				ifTrue: ["Just dropped a sub-deck of cards"
					aMorph submorphs
						reverseDo: [:m | self addMorphFront: m]].
			(target notNil
					and: [cardDroppedSelector notNil])
				ifTrue: [target perform: cardDroppedSelector]]
		named: 'move card' translated! !

!PlayingCardDeck methodsFor: 'layout' stamp: 'djp 10/15/1999 11:25'!
staggerOffset
	^18! !

!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'dgd 2/22/2003 13:37'!
deal
	| card |
	^ self cards notEmpty 
		ifTrue: 
			[card := self topCard.
			card delete.
			card]
		ifFalse: [nil]! !

!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'djp 10/10/1999 18:48'!
deal: anInteger

	^(1 to: anInteger) collect: [:i | self deal]! !

!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'ar 11/12/2000 22:40'!
reverse
	self invalidRect: self fullBounds.
	submorphs := submorphs reversed.
	self layoutChanged.! !

!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'ar 11/12/2000 22:40'!
shuffle
	self invalidRect: self fullBounds.
	submorphs := submorphs shuffledBy: (Random new seed: seed).
	self layoutChanged.! !

!PlayingCardDeck methodsFor: 'events' stamp: 'dgd 2/22/2003 18:49'!
doubleClickOnCard: aCard 
	(target notNil and: [cardDoubleClickSelector notNil]) 
		ifTrue: 
			[^target 
				perform: cardDoubleClickSelector
				with: self
				with: aCard]! !

!PlayingCardDeck methodsFor: 'private' stamp: 'djp 10/16/1999 17:27'!
nilOrSymbol: aSymbolOrString

	(nil = aSymbolOrString or:
	 ['nil' = aSymbolOrString or:
	 [aSymbolOrString isEmpty]])
		ifTrue: [^nil]
		ifFalse: [^aSymbolOrString asSymbol]! !

!PlayingCardDeck class methodsFor: 'instance creation' stamp: 'KenD 7/7/2020 14:06:12'!
newDeck
	^self newColumn newDeck! !

!PlayingCardDeck class methodsFor: 'instance creation' stamp: 'KenD 7/7/2020 14:06:33'!
newSuit: suit
	^self newColumn newSuit: suit! !

!PlayingCardDeck class methodsFor: 'symbols' stamp: 'djp 10/10/1999 18:06'!
suits

	^{#Clubs. #Diamonds. #Hearts. #Spades}! !

!PlayingCardDeck class methodsFor: 'symbols' stamp: 'djp 10/17/1999 18:05'!
values

	^#(Ace),((2 to: 9) collect: [:i | i printString asSymbol]), #(Jack Queen King)! !

!PlayingCardDeck class methodsFor: 'new-morph participation' stamp: 'di 1/16/2000 10:38'!
includeInNewMorphMenu

	^false! !

!FreeCellStatistics methodsFor: 'user interface' stamp: 'KenD 7/8/2020 14:55:39'!
buildButton: aButton target: aTarget label: aLabel selector: aSelector
	"wrap a button or switch in an alignmentMorph to provide some space around the button"

	| a |
	aButton 
		model: aTarget;
		label: aLabel;
		action: aSelector;
		"borderStyle: (BorderStyle raised width: 2);"
		color: Color gray.
	a := AlignmentMorph newColumn
"		wrapCentering: #center; cellPositioning: #topCenter;
		hResizing: #spaceFill;
		vResizing: #shrinkWrap;"
		color: Color transparent";
		layoutInset: 1".
	a addMorph: aButton.
	^ a

! !

!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 19:20'!
close

	window ifNotNil: [
		window delete.
		window := nil].! !

!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 16:42'!
color

	^Color green darker! !

!FreeCellStatistics methodsFor: 'user interface' stamp: 'asm 11/24/2003 22:55'!
display
	| panel |

	(window notNil and: [window owner notNil]) ifTrue: [window activate. ^nil].
	panel := AlignmentMorph newColumn.
	panel
		wrapCentering: #center; cellPositioning: #topCenter;
		hResizing: #rigid;
		vResizing: #rigid;
		extent: 250@150;
		color: self color;
		addMorphBack: self makeStatistics;
		addMorphBack: self makeControls.
	window := panel openInWindowLabeled: 'FreeCell Statistics' translated.! !

!FreeCellStatistics methodsFor: 'user interface' stamp: 'mt 4/10/2018 10:59'!
makeControls
	| row |

	row := AlignmentMorph newRow.
	row
		wrapCentering: #center; cellPositioning: #leftCenter;
		hResizing: #spaceFill;
		vResizing: #shrinkWrap;
		color: self color;
		borderStyle: (BorderStyle inset width: 2);
		addMorphBack: self makeOkButton;
		addMorphBack: self makeResetButton.
	^row.! !

!FreeCellStatistics methodsFor: 'user interface' stamp: 'KR 3/28/2008 02:11'!
makeOkButton

	^self
		buildButton: SimpleButtonMorph new
		target: self
		label: 'OK' translated
		selector: #ok! !

!FreeCellStatistics methodsFor: 'user interface' stamp: 'KR 3/28/2008 02:11'!
makeResetButton

	^self
		buildButton: SimpleButtonMorph new
		target: self
		label: 'Reset' translated
		selector: #reset! !

!FreeCellStatistics methodsFor: 'user interface' stamp: 'mt 4/10/2018 10:59'!
makeStatistics
	| row |

	row := AlignmentMorph newRow.
	row
		wrapCentering: #center; cellPositioning: #leftCenter;
		hResizing: #spaceFill;
		vResizing: #spaceFill;
		color: self color;
		borderStyle: (BorderStyle inset width: 2);
		addMorphBack: (AlignmentMorph newColumn
			wrapCentering: #center; cellPositioning: #topCenter;
			color: self color;
			addMorph: (statsMorph := TextMorph new contents: self statsText)).
	^row.! !

!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 19:04'!
statsText

	^ String cr,self printString,String cr! !

!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 15:56'!
stringMorphFromPrintOn: aSelector
	
	^StringMorph new 
		contents: (String streamContents: [:s | self perform: aSelector with: s]);
		yourself.! !

!FreeCellStatistics methodsFor: 'actions' stamp: 'di 3/5/2000 14:30'!
gameLost: gameNumber

	"Don't count multiple losses of the same game"
	gameNumber = lastGameLost ifTrue: [^ self].
	lastGameLost := gameNumber.

	sessionLosses := sessionLosses + 1.
	totalLosses := totalLosses + 1.
	lossesWithReplay := lossesWithReplay + 1.
	currentType = #losses
		ifTrue: [currentCount := currentCount + 1]
		ifFalse: 
			[currentCount := 1.
			currentType := #losses].
	self updateStreak.
	self changed! !

!FreeCellStatistics methodsFor: 'actions' stamp: 'di 3/5/2000 16:48'!
gameWon: gameNumber
	sessionWins := sessionWins + 1.
	totalWins := totalWins + 1.
	gameNumber = lastGameWon ifFalse:
		[gameNumber = lastGameLost ifTrue:
			["Finally won a game by replaying"
			lossesWithReplay := lossesWithReplay - 1].
		winsWithReplay := winsWithReplay + 1].
	lastGameWon := gameNumber.
	currentType = #wins
		ifTrue: [currentCount := currentCount + 1]
		ifFalse: [currentCount := 1.
				currentType := #wins].
	self updateStreak.
	self changed! !

!FreeCellStatistics methodsFor: 'actions' stamp: 'djp 10/24/1999 19:21'!
newSession

	sessionWins := 0.
	sessionLosses := 0.
	currentCount := 0.
	currentType := nil.
	self changed.! !

!FreeCellStatistics methodsFor: 'actions' stamp: 'djp 10/24/1999 17:15'!
ok

	window delete.
	window := nil.! !

!FreeCellStatistics methodsFor: 'actions' stamp: 'di 3/5/2000 14:30'!
reset

	sessionWins 		_ 0.
	sessionLosses 	_ 0.
	totalWins 		_ 0.
	totalLosses 		_ 0.
	streakWins		_ 0.
	streakLosses 	_ 0.
 	winsWithReplay := 0.
	lossesWithReplay := 0.
	lastGameWon	_ 0.
	lastGameLost 	_ 0.
	currentCount 	_ 0.
	currentType		_ nil.
	self changed.
	

	! !

!FreeCellStatistics methodsFor: 'actions' stamp: 'th 12/20/1999 20:42'!
updateStreak
	"I moved the code from #printWins:on: and #printLosses:on: here because 
	 it is basically the same. I hope this increases the maintainability. 
	th 12/20/1999 20:41"
	currentType = #losses ifTrue: [streakLosses := streakLosses max: currentCount].
	currentType = #wins ifTrue: [streakWins := streakWins max: currentCount]! !

!FreeCellStatistics methodsFor: 'printing' stamp: 'asm 11/24/2003 22:57'!
print: aNumber type: type on: aStream 
	"I moved the code from #printWins:on: and #printLosses:on: here because 
	it is basically 
	the same. I hope this increases the maintainability. - th 12/20/1999 20:37"
	aStream print: aNumber.
	type = #wins
		ifTrue: [aNumber = 1
				ifTrue: [aStream nextPutAll: ' win' translated]
				ifFalse: [aStream nextPutAll: ' wins' translated]].
	type = #losses
		ifTrue: [aNumber = 1
				ifTrue: [aStream nextPutAll: ' loss' translated]
				ifFalse: [aStream nextPutAll: ' losses' translated]]! !

!FreeCellStatistics methodsFor: 'printing' stamp: 'asm 11/24/2003 23:02'!
printReplaysOn: aStream 
	| total |
	aStream nextPutAll: 'With replays: ' translated;
		 tab.
	self
		print: winsWithReplay
		type: #wins
		on: aStream.
	aStream nextPutAll: ', '.
	self
		print: lossesWithReplay
		type: #losses
		on: aStream.
	total := winsWithReplay + lossesWithReplay.
	total ~~ 0
		ifTrue: [aStream nextPutAll: ', ';
				 print: (winsWithReplay / total * 100) asInteger;
				 nextPut: $%]! !

!FreeCellStatistics methodsFor: 'printing' stamp: 'asm 11/24/2003 23:02'!
printSessionOn: aStream 
	| total |
	aStream nextPutAll: 'This session: ' translated, String tab.
	self
		print: sessionWins
		type: #wins
		on: aStream.
	aStream nextPutAll: ', '.
	self
		print: sessionLosses
		type: #losses
		on: aStream.
	total := sessionWins + sessionLosses.
	total ~~ 0
		ifTrue: [aStream nextPutAll: ', ';
				 print: (sessionWins / total * 100) asInteger;
				 nextPut: $%]! !

!FreeCellStatistics methodsFor: 'printing' stamp: 'KR 3/28/2008 02:13'!
printStreaksOn: aStream 
	aStream nextPutAll: 'Streaks: ' translated;
		 tab;
		 tab.
	self
		print: streakWins
		type: #wins
		on: aStream.
	aStream nextPutAll: ', '.
	self
		print: streakLosses
		type: #losses
		on: aStream.
	aStream cr; tab; tab; tab; tab; nextPutAll: 'Current: ' translated.
	self
		print: currentCount
		type: currentType
		on: aStream! !

!FreeCellStatistics methodsFor: 'printing' stamp: 'asm 11/24/2003 23:03'!
printTotalOn: aStream 
	| total |
	aStream nextPutAll: 'Total: ' translated;
		 tab;
		 tab;
		 tab.
	self
		print: totalWins
		type: #wins
		on: aStream.
	aStream nextPutAll: ', '.
	self
		print: totalLosses
		type: #losses
		on: aStream.
	total := totalWins + totalLosses.
	total ~~ 0
		ifTrue: [aStream nextPutAll: ', ';
				 print: (totalWins / total * 100) asInteger;
				 nextPut: $%]! !

!FreeCellStatistics methodsFor: 'initialization' stamp: 'asm 11/24/2003 23:10'!
defaultColor
	"answer the default color/fill style for the receiver"
	^ Color green! !

!FreeCellStatistics methodsFor: 'initialization' stamp: 'asm 11/24/2003 22:56'!
initialize
	super initialize.
	self reset! !

!FreeCellStatistics methodsFor: 'updating' stamp: 'djp 10/24/1999 19:04'!
changed

	window ifNotNil: [
		statsMorph ifNotNil: [statsMorph contents: self statsText]]! !

!FreeCellStatistics class methodsFor: 'instance creation' stamp: 'di 1/16/2000 10:39'!
includeInNewMorphMenu

	^false! !
PlayingCardMorph initialize!
FreeCell initialize!
