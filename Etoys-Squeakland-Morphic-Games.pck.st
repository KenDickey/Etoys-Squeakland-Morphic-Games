'From Cuis 5.0 [latest update: #4241] on 7 July 2020 at 2:21:39 pm'!
'Description '!
!provides: 'Etoys-Squeakland-Morphic-Games' 1 0!
!requires: 'Cuis-Base' 50 4241 nil!
!requires: 'Compression' 1 27 nil!
!requires: 'Graphics-Files-Additional' 1 23 nil!
SystemOrganization addCategory: #'Etoys-Squeakland-Morphic-Games'!


!classDefinition: #PlayingCardMorph category: #'Etoys-Squeakland-Morphic-Games'!
ImageMorph subclass: #PlayingCardMorph
	instanceVariableNames: 'cardNumber suitNumber'
	classVariableNames: 'FormsArray'
	poolDictionaries: ''
	category: 'Etoys-Squeakland-Morphic-Games'!
!classDefinition: 'PlayingCardMorph class' category: #'Etoys-Squeakland-Morphic-Games'!
PlayingCardMorph class
	instanceVariableNames: ''!

!classDefinition: #PlayingCardDeck category: #'Etoys-Squeakland-Morphic-Games'!
LayoutMorph subclass: #PlayingCardDeck
	instanceVariableNames: 'layout stackingPolicy stackingOrder emptyDropPolicy target acceptCardSelector cardDroppedSelector cardDoubleClickSelector cardDraggedSelector seed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Etoys-Squeakland-Morphic-Games'!
!classDefinition: 'PlayingCardDeck class' category: #'Etoys-Squeakland-Morphic-Games'!
PlayingCardDeck class
	instanceVariableNames: ''!


!PlayingCardMorph commentStamp: '<historical>' prior: 0!
This class displays images from the PlayingCard class as morphs. 

FormsArray contains images originally generated by Squeak Class PlayingCard.!

!PlayingCardDeck commentStamp: '<historical>' prior: 0!
A stack or column of CardMorphs which are my submorphs!

!PlayingCardMorph class methodsFor: 'instance creation' stamp: 'KenD 7/7/2020 13:49:22'!
initializedInstance
	"Answer the Queen of Hearts"
	^ self the: 12 of: #hearts! !

!PlayingCardMorph methodsFor: 'printing' stamp: 'djp 10/17/1999 20:27'!
printOn: aStream

	aStream
		print: cardNumber;
		nextPutAll: ' of ';
		print: (self class suits at: suitNumber).! !

!PlayingCardDeck methodsFor: 'printing' stamp: 'dgd 2/22/2003 13:38'!
printOn: aStream 
	| cards |
	cards := self cards.
	aStream nextPutAll: 'aCardDeck('.
	cards size > 1 
		ifTrue: 
			[cards allButLast do: 
					[:card | 
					aStream
						print: card;
						nextPutAll: ', ']].
	cards notEmpty ifTrue: [aStream print: cards last].
	aStream nextPut: $)! !

!PlayingCardMorph methodsFor: 'access' stamp: 'di 10/21/1999 21:41'!
board

	^ owner owner owner! !

!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/24/1999 03:11'!
cardDeck

	^self owner! !

!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!
cardNumber
	^cardNumber! !

!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!
cardNumber: c suitNumber: s
	cardNumber := c.
	suitNumber := s.! !

!PlayingCardMorph methodsFor: 'access' stamp: 'KenD 7/7/2020 13:44:12'!
cardNumber: c suitNumber: s cardForm: aForm
	cardNumber := c.
	suitNumber := s.
	self image: aForm! !

!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!
suit
	^self class suits at: suitNumber! !

!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!
suitColor
	^#(black red red black) at: suitNumber! !

!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!
suitNumber

	^suitNumber! !

!PlayingCardMorph methodsFor: 'dropping/grabbing' stamp: 'di 12/12/2000 11:47'!
aboutToBeGrabbedBy: aHand
	"I'm about to be grabbed by the hand.  If other cards are above me in a deck,
	then move them from the deck to being submorphs of me"
	| i |
	super aboutToBeGrabbedBy: aHand.
	self removeProperty: #undoGrabCommand.  "So it won't interfere with overall move"
	self board captureStateBeforeGrab.
	i := owner submorphs indexOf: self ifAbsent: [^ self].
	i = 1 ifTrue: [^ self].
	(owner submorphs copyFrom: 1 to: i-1) do:
		[:m | m class = self class ifTrue: [self addMorphBack: m]].
! !

!PlayingCardMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 20:05'!
justDroppedInto: newOwner event: evt

	(newOwner isKindOf: PlayingCardDeck)
		ifFalse: ["Can't drop a card anywhere but on a deck"
				self rejectDropMorphEvent: evt].
	^super justDroppedInto: newOwner event: evt! !

!PlayingCardMorph methodsFor: 'dropping/grabbing' stamp: 'di 12/12/2000 14:52'!
slideBackToFormerSituation: evt

	super slideBackToFormerSituation: evt.
	self board removeProperty: #stateBeforeGrab.
	self hasSubmorphs ifTrue:
		["Just cancelled a drop of multiple cards -- have to unload submorphs"
		self submorphs reverseDo: [:m | owner addMorphFront: m]].
! !

!PlayingCardMorph methodsFor: 'event handling' stamp: 'RAA 2/12/2001 19:22'!
click: evt
	
	"since we really want to know about double-clicks before making our move, ignore this and wait until #firstClickTimedOut: arrives"! !

!PlayingCardMorph methodsFor: 'event handling' stamp: 'djp 10/24/1999 03:12'!
doubleClick: evt

	^self cardDeck doubleClickOnCard: self! !

!PlayingCardMorph methodsFor: 'event handling' stamp: 'dgd 2/22/2003 14:14'!
firstClickTimedOut: evt 
	| root popUp |
	root := owner rootForGrabOf: self.
	root isNil 
		ifTrue: 
			["Display hidden card in front"

			popUp := self copy.
			self board owner owner addMorphFront: popUp.
			self world displayWorld.
			(Delay forMilliseconds: 750) wait.
			popUp delete]
		ifFalse: [evt hand grabMorph: root]! !

!PlayingCardMorph methodsFor: 'event handling' stamp: 'di 10/19/1999 00:01'!
handlesMouseDown: evt

	^ true! !

!PlayingCardMorph methodsFor: 'event handling' stamp: 'jcg 9/21/2001 13:25'!
mouseDown: evt
	"Do nothing upon mouse-down except inform the hand to watch for a double-click; wait until an ensuing click:, doubleClick:, or drag: message gets dispatched"

	evt hand waitForClicksOrDrag: self event: evt selectors: { #click:. #doubleClick:. #firstClickTimedOut:. nil} threshold: 5! !

!PlayingCardMorph class methodsFor: 'class initialization' stamp: 'KenD 7/7/2020 12:53:51'!
initialize
"
	PlayingCardMorph initialize.
"
	self initializeFromPNG! !

!PlayingCardMorph class methodsFor: 'class initialization' stamp: 'KenD 7/7/2020 12:51:39'!
initializeFromPNG
	| imageDirNamePrefix |
	FormsArray := Array new: 53.
	imageDirNamePrefix := 'SqueakCardImages/'. 
	1 to: 13 do: [ :faceNum |
		#( $c $d $h $s ) do: [ :char |	
			FormsArray 	
				at: ((faceNum - 1) * 4) + (#($c $d $h $s) indexOf: char)
				put: ((Form fromFileNamed: 
				 (imageDirNamePrefix, faceNum asString, char asString, '.png')) asFormOfDepth: 32)]].
	FormsArray 
		at: 53 
		put: ((Form fromFileNamed: (imageDirNamePrefix , 'back.png')) asFormOfDepth: 32)! !

!PlayingCardMorph class methodsFor: 'instance creation' stamp: 'KenD 7/7/2020 13:13:43'!
the: faceNumber of: suitOrNumber
	"CardNumber is 1..13"
"
	(PlayingCardMorph the: 3 of: #spades) openInWorld.
"
	| suitNumber | 
	suitNumber :=  (suitOrNumber isNumber)
				ifTrue: [suitOrNumber]
				ifFalse: [#(clubs diamonds hearts spades) indexOf: suitOrNumber].
	^ self new cardNumber: faceNumber 
			suitNumber: suitNumber 
			cardForm: (FormsArray at: ((faceNumber - 1) * 4) + suitNumber)! !

!PlayingCardMorph class methodsFor: 'access' stamp: 'KenD 7/7/2020 13:19:46'!
cardSize

	^ (self width ) @ (self height)! !

!PlayingCardMorph class methodsFor: 'access' stamp: 'KenD 7/7/2020 13:17:06'!
height
	^ (FormsArray at: 1) height! !

!PlayingCardMorph class methodsFor: 'access' stamp: 'djp 10/15/1999 07:14'!
suits
	^ #(clubs diamonds hearts spades)! !

!PlayingCardMorph class methodsFor: 'access' stamp: 'KenD 7/7/2020 13:21:59'!
width
	 ^ (FormsArray at: 1) width! !

!PlayingCardDeck methodsFor: 'initialization' stamp: 'KenD 7/7/2020 14:15:39'!
initialize
	super initialize.
	"self cellPositioning: #topLeft."
	"self reverseTableCells: true."
	self layout: #grid.
	"self hResizing: #shrinkWrap.
	self vResizing: #shrinkWrap."
	self borderWidth: 0.
	"self layoutInset: 0."
	stackingPolicy := #stagger.
	stackingOrder := #ascending.
	emptyDropPolicy := #any.
	self newSeed.
	^self! !

!PlayingCardDeck methodsFor: 'initialization' stamp: 'djp 10/17/1999 18:25'!
newDeck
	| cards |
	cards := OrderedCollection new: 52.
	PlayingCardMorph suits 
		do: [:suit | 1 to: 13
			do: [:cardNo | cards add: (PlayingCardMorph the: cardNo of: suit)]].
	self addAllMorphs: cards.
	^self! !

!PlayingCardDeck methodsFor: 'initialization' stamp: 'djp 10/17/1999 18:25'!
newSuit: suit
	| cards |
	cards := OrderedCollection new: 13.
	1 to: 13 do: [:cardNo | cards add: (PlayingCardMorph the: cardNo of: suit)].
	self addAllMorphs: cards.
	^self! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 01:40'!
acceptCardSelector: aSymbolOrString

	acceptCardSelector := self nilOrSymbol: aSymbolOrString.! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/15/1999 11:07'!
addCard: aPlayingCard
	self addMorph: aPlayingCard! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 03:13'!
cardDoubleClickSelector: aSymbolOrString

	cardDoubleClickSelector := self nilOrSymbol: aSymbolOrString.! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 01:39'!
cardDraggedSelector: aSymbolOrString

	cardDraggedSelector := self nilOrSymbol: aSymbolOrString.! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 17:27'!
cardDroppedSelector: aSymbolOrString

	cardDroppedSelector := self nilOrSymbol: aSymbolOrString.! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/15/1999 10:46'!
cards

	^submorphs! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 13:18'!
emptyDropPolicy: aSymbol
	"#any #inOrder #anyClub #anyDiamond #anyHeart #anySpade"

	emptyDropPolicy := aSymbol! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 19:41'!
hasCards

	^self hasSubmorphs! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'KenD 7/7/2020 14:18:04'!
layout: aSymbol
	" #grid #pile #stagger"
	layout := aSymbol.
	"@@FIXME: Adjust Layout Mechanics @@"
"	layout == #grid 
		ifTrue:[self maxCellSize: SmallInteger maxVal].
	layout == #pile 
		ifTrue:[self maxCellSize: 0].
	layout == #stagger 
		ifTrue:[self maxCellSize: self staggerOffset].
"! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/23/1999 22:44'!
newSeed
	seed := (1 to: 32000) atRandom! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 20:05'!
removeAllCards
	self removeAllMorphs! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/23/1999 22:22'!
seed
	
	^seed! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/23/1999 22:21'!
seed: anInteger
	
	seed := anInteger! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/15/1999 16:39'!
stackingOrder: aSymbol
	"#ascending #descending"

	stackingOrder := aSymbol! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 00:08'!
stackingPolicy

	^ stackingPolicy! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 00:08'!
stackingPolicy: aSymbol
	"#straight #altStraight #single #none"

	stackingPolicy := aSymbol! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 20:20'!
subDeckStartingAt: aCard
	| i subDeck |

	i := submorphs indexOf: aCard ifAbsent: [^ aCard].
	i = 1 ifTrue: [^aCard].
	subDeck := PlayingCardDeck new.
	(submorphs copyFrom: 1 to: i-1) do:
			[:m | m class = aCard class ifTrue: [subDeck addMorphBack: m]].
	^subDeck.
	! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 17:21'!
target: anObject

	target := anObject! !

!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 19:24'!
topCard

	^self firstSubmorph! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'th 12/10/1999 16:07'!
acceptCard: aCard default: aBoolean 
	"if target and acceptCardSelector are both not nil, send to target, if not  
	nil answer  
	else answer aBoolean"
	"Rewrote this a little (SmallLint calls this 'intention revealing')-th"
	^ (target isNil or: [acceptCardSelector isNil])
		ifTrue: [aBoolean]
		ifFalse: [(target
				perform: acceptCardSelector
				with: aCard
				with: self)
				ifNil: [aBoolean]]! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/16/1999 13:14'!
emptyDropNotOk: aPlayingCard

	^(self emptyDropOk: aPlayingCard) not! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/16/1999 13:15'!
emptyDropOk: aPlayingCard

	emptyDropPolicy = #any 			ifTrue: [^true].
	emptyDropPolicy = #inOrder			ifTrue: [^self inStackingOrder: aPlayingCard].
	emptyDropPolicy = #anyClub 		ifTrue: [^aPlayingCard suit = #club].
	emptyDropPolicy = #anyDiamond		ifTrue: [^aPlayingCard suit = #diamond].
	emptyDropPolicy = #anyHeart		ifTrue: [^aPlayingCard suit = #heart].
	emptyDropPolicy = #anySpade		ifTrue: [^aPlayingCard suit = #spade].! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/16/1999 13:10'!
ifEmpty: aBlock

	self hasSubmorphs not ifTrue: [^aBlock value]! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/24/1999 02:17'!
ifEmpty: aBlock1 ifNotEmpty: aBlock2

	self hasSubmorphs not 
		ifTrue: [^aBlock1 value]
		ifFalse: [^aBlock2 value]! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/16/1999 21:54'!
inStackingOrder: aPlayingCard

	^self inStackingOrder: aPlayingCard event: nil! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'di 10/19/1999 15:45'!
inStackingOrder: aCard event: evt

	self hasSubmorphs 
		ifTrue: [^ self inStackingOrder: aCard onTopOf: self topCard]
		ifFalse: [stackingOrder = #ascending ifTrue: [^ aCard cardNumber = 1].
				stackingOrder = #descending ifTrue: [^ aCard cardNumber = 13]].
	^ false.! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'di 10/21/1999 22:03'!
inStackingOrder: aCard onTopOf: cardBelow
	| diff |
	(stackingPolicy = #altStraight and: [aCard suitColor = cardBelow suitColor]) ifTrue: [^ false].
	(stackingPolicy = #straight and: [aCard suit ~= cardBelow suit]) ifTrue: [^ false].
	diff := aCard cardNumber - cardBelow cardNumber.
	stackingOrder = #ascending 	ifTrue: [^ diff = 1].
	stackingOrder = #descending	ifTrue: [^ diff = -1].
	^ false.! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/15/1999 12:43'!
insertionIndexFor: aMorph
	"Return the index at which the given morph should be inserted into the submorphs of the receiver."

	^1! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'th 12/10/1999 18:34'!
repelCard: aCard 
	stackingPolicy = #none ifTrue: [^ self repelCard: aCard default: true].
	stackingPolicy = #single ifTrue: [^ self ifEmpty: [self repelCard: aCard default: false]
			ifNotEmpty: [true]].
	(stackingPolicy = #altStraight or: [stackingPolicy = #straight])
		ifTrue: [self ifEmpty: [^ self repelCard: aCard default: (self emptyDropNotOk: aCard)]
				ifNotEmpty: [(self inStackingOrder: aCard onTopOf: self topCard)
						ifFalse: [^ self repelCard: aCard default: true]]].
	^ false! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/24/1999 04:09'!
repelCard: aCard default: aBoolean
	
	^(self acceptCard: aCard default: aBoolean not) not! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/24/1999 02:20'!
repelsMorph: aMorph event: evt

	(aMorph isKindOf: PlayingCardMorph) 
		ifTrue: [^self repelCard: aMorph]
		ifFalse: [^true]! !

!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'dgd 2/22/2003 18:49'!
rootForGrabOf: aCard 
	self hasSubmorphs ifFalse: [^nil].
	(target notNil and: [cardDraggedSelector notNil]) 
		ifTrue: 
			[^target 
				perform: cardDraggedSelector
				with: aCard
				with: self]
		ifFalse: [^self firstSubmorph]! !

!PlayingCardDeck methodsFor: 'layout' stamp: 'asm 11/25/2003 22:37'!
acceptDroppingMorph: aMorph event: evt 
	target
		rememberUndoableAction: [target inAutoMove
				ifFalse: [target removeProperty: #stateBeforeGrab].
			self addMorph: aMorph.
			aMorph hasSubmorphs
				ifTrue: ["Just dropped a sub-deck of cards"
					aMorph submorphs
						reverseDo: [:m | self addMorphFront: m]].
			(target notNil
					and: [cardDroppedSelector notNil])
				ifTrue: [target perform: cardDroppedSelector]]
		named: 'move card' translated! !

!PlayingCardDeck methodsFor: 'layout' stamp: 'djp 10/15/1999 11:25'!
staggerOffset
	^18! !

!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'dgd 2/22/2003 13:37'!
deal
	| card |
	^ self cards notEmpty 
		ifTrue: 
			[card := self topCard.
			card delete.
			card]
		ifFalse: [nil]! !

!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'djp 10/10/1999 18:48'!
deal: anInteger

	^(1 to: anInteger) collect: [:i | self deal]! !

!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'ar 11/12/2000 22:40'!
reverse
	self invalidRect: self fullBounds.
	submorphs := submorphs reversed.
	self layoutChanged.! !

!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'ar 11/12/2000 22:40'!
shuffle
	self invalidRect: self fullBounds.
	submorphs := submorphs shuffledBy: (Random new seed: seed).
	self layoutChanged.! !

!PlayingCardDeck methodsFor: 'events' stamp: 'dgd 2/22/2003 18:49'!
doubleClickOnCard: aCard 
	(target notNil and: [cardDoubleClickSelector notNil]) 
		ifTrue: 
			[^target 
				perform: cardDoubleClickSelector
				with: self
				with: aCard]! !

!PlayingCardDeck methodsFor: 'private' stamp: 'djp 10/16/1999 17:27'!
nilOrSymbol: aSymbolOrString

	(nil = aSymbolOrString or:
	 ['nil' = aSymbolOrString or:
	 [aSymbolOrString isEmpty]])
		ifTrue: [^nil]
		ifFalse: [^aSymbolOrString asSymbol]! !

!PlayingCardDeck class methodsFor: 'instance creation' stamp: 'KenD 7/7/2020 14:06:12'!
newDeck
	^self newColumn newDeck! !

!PlayingCardDeck class methodsFor: 'instance creation' stamp: 'KenD 7/7/2020 14:06:33'!
newSuit: suit
	^self newColumn newSuit: suit! !

!PlayingCardDeck class methodsFor: 'symbols' stamp: 'djp 10/10/1999 18:06'!
suits

	^{#Clubs. #Diamonds. #Hearts. #Spades}! !

!PlayingCardDeck class methodsFor: 'symbols' stamp: 'djp 10/17/1999 18:05'!
values

	^#(Ace),((2 to: 9) collect: [:i | i printString asSymbol]), #(Jack Queen King)! !

!PlayingCardDeck class methodsFor: 'new-morph participation' stamp: 'di 1/16/2000 10:38'!
includeInNewMorphMenu

	^false! !
PlayingCardMorph initialize!
